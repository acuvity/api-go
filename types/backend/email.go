// Code generated by elegen. DO NOT EDIT.
// Source: go.acuvity.ai/elemental (templates/model.gotpl)

package api

import (
	"fmt"

	"github.com/globalsign/mgo/bson"
	"github.com/mitchellh/copystructure"
	"go.acuvity.ai/elemental"
)

// EmailContentTypeValue represents the possible values for attribute "contentType".
type EmailContentTypeValue string

const (
	// EmailContentTypeHTML represents the value HTML.
	EmailContentTypeHTML EmailContentTypeValue = "HTML"

	// EmailContentTypeText represents the value Text.
	EmailContentTypeText EmailContentTypeValue = "Text"
)

// EmailIdentity represents the Identity of the object.
var EmailIdentity = elemental.Identity{
	Name:     "email",
	Category: "emails",
	Package:  "avi",
	Private:  true,
}

// EmailsList represents a list of Emails
type EmailsList []*Email

// Identity returns the identity of the objects in the list.
func (o EmailsList) Identity() elemental.Identity {

	return EmailIdentity
}

// Copy returns a pointer to a copy the EmailsList.
func (o EmailsList) Copy() elemental.Identifiables {

	out := append(EmailsList{}, o...)
	return &out
}

// Append appends the objects to the a new copy of the EmailsList.
func (o EmailsList) Append(objects ...elemental.Identifiable) elemental.Identifiables {

	out := append(EmailsList{}, o...)
	for _, obj := range objects {
		out = append(out, obj.(*Email))
	}

	return out
}

// List converts the object to an elemental.IdentifiablesList.
func (o EmailsList) List() elemental.IdentifiablesList {

	out := make(elemental.IdentifiablesList, len(o))
	for i := 0; i < len(o); i++ {
		out[i] = o[i]
	}

	return out
}

// DefaultOrder returns the default ordering fields of the content.
func (o EmailsList) DefaultOrder() []string {

	return []string{}
}

// ToSparse returns the EmailsList converted to SparseEmailsList.
// Objects in the list will only contain the given fields. No field means entire field set.
func (o EmailsList) ToSparse(fields ...string) elemental.Identifiables {

	out := make(SparseEmailsList, len(o))
	for i := 0; i < len(o); i++ {
		out[i] = o[i].ToSparse(fields...).(*SparseEmail)
	}

	return out
}

// Version returns the version of the content.
func (o EmailsList) Version() int {

	return 1
}

// Email represents the model of a email
type Email struct {
	// The list of email recipients to set for the BCC field.
	BCC []string `json:"BCC,omitempty" msgpack:"BCC,omitempty" bson:"-" mapstructure:"BCC,omitempty"`

	// The list of email recipients to set for the CC field.
	CC []string `json:"CC,omitempty" msgpack:"CC,omitempty" bson:"-" mapstructure:"CC,omitempty"`

	// The attachment(s) to send with the email.
	Attachments map[string][]byte `json:"attachments,omitempty" msgpack:"attachments,omitempty" bson:"-" mapstructure:"attachments,omitempty"`

	// The body of the email.
	Body string `json:"body" msgpack:"body" bson:"-" mapstructure:"body,omitempty"`

	// The type of content being sent.
	ContentType EmailContentTypeValue `json:"contentType" msgpack:"contentType" bson:"-" mapstructure:"contentType,omitempty"`

	// If set, the email to set for the From field.
	From string `json:"from,omitempty" msgpack:"from,omitempty" bson:"-" mapstructure:"from,omitempty"`

	// The subject of the email.
	Subject string `json:"subject" msgpack:"subject" bson:"-" mapstructure:"subject,omitempty"`

	// The list of email recipients to set for the To field.
	To []string `json:"to" msgpack:"to" bson:"-" mapstructure:"to,omitempty"`

	ModelVersion int `json:"-" msgpack:"-" bson:"_modelversion"`
}

// NewEmail returns a new *Email
func NewEmail() *Email {

	return &Email{
		ModelVersion: 1,
		BCC:          []string{},
		CC:           []string{},
		Attachments:  map[string][]byte{},
		ContentType:  EmailContentTypeText,
		To:           []string{},
	}
}

// Identity returns the Identity of the object.
func (o *Email) Identity() elemental.Identity {

	return EmailIdentity
}

// Identifier returns the value of the object's unique identifier.
func (o *Email) Identifier() string {

	return ""
}

// SetIdentifier sets the value of the object's unique identifier.
func (o *Email) SetIdentifier(id string) {

}

// GetBSON implements the bson marshaling interface.
// This is used to transparently convert ID to MongoDBID as ObectID.
func (o *Email) GetBSON() (any, error) {

	if o == nil {
		return nil, nil
	}

	s := &mongoAttributesEmail{}

	return s, nil
}

// SetBSON implements the bson marshaling interface.
// This is used to transparently convert ID to MongoDBID as ObectID.
func (o *Email) SetBSON(raw bson.Raw) error {

	if o == nil {
		return nil
	}

	s := &mongoAttributesEmail{}
	if err := raw.Unmarshal(s); err != nil {
		return err
	}

	return nil
}

// Version returns the hardcoded version of the model.
func (o *Email) Version() int {

	return 1
}

// BleveType implements the bleve.Classifier Interface.
func (o *Email) BleveType() string {

	return "email"
}

// DefaultOrder returns the list of default ordering fields.
func (o *Email) DefaultOrder() []string {

	return []string{}
}

// Doc returns the documentation for the object
func (o *Email) Doc() string {

	return `Send an email based on the provided configuration.`
}

func (o *Email) String() string {

	return fmt.Sprintf("<%s:%s>", o.Identity().Name, o.Identifier())
}

// ToSparse returns the sparse version of the model.
// The returned object will only contain the given fields. No field means entire field set.
func (o *Email) ToSparse(fields ...string) elemental.SparseIdentifiable {

	if len(fields) == 0 {
		// nolint: goimports
		return &SparseEmail{
			BCC:         &o.BCC,
			CC:          &o.CC,
			Attachments: &o.Attachments,
			Body:        &o.Body,
			ContentType: &o.ContentType,
			From:        &o.From,
			Subject:     &o.Subject,
			To:          &o.To,
		}
	}

	sp := &SparseEmail{}
	for _, f := range fields {
		switch f {
		case "BCC":
			sp.BCC = &(o.BCC)
		case "CC":
			sp.CC = &(o.CC)
		case "attachments":
			sp.Attachments = &(o.Attachments)
		case "body":
			sp.Body = &(o.Body)
		case "contentType":
			sp.ContentType = &(o.ContentType)
		case "from":
			sp.From = &(o.From)
		case "subject":
			sp.Subject = &(o.Subject)
		case "to":
			sp.To = &(o.To)
		}
	}

	return sp
}

// Patch apply the non nil value of a *SparseEmail to the object.
func (o *Email) Patch(sparse elemental.SparseIdentifiable) {
	if !sparse.Identity().IsEqual(o.Identity()) {
		panic("cannot patch from a parse with different identity")
	}

	so := sparse.(*SparseEmail)
	if so.BCC != nil {
		o.BCC = *so.BCC
	}
	if so.CC != nil {
		o.CC = *so.CC
	}
	if so.Attachments != nil {
		o.Attachments = *so.Attachments
	}
	if so.Body != nil {
		o.Body = *so.Body
	}
	if so.ContentType != nil {
		o.ContentType = *so.ContentType
	}
	if so.From != nil {
		o.From = *so.From
	}
	if so.Subject != nil {
		o.Subject = *so.Subject
	}
	if so.To != nil {
		o.To = *so.To
	}
}

// DeepCopy returns a deep copy if the Email.
func (o *Email) DeepCopy() *Email {

	if o == nil {
		return nil
	}

	out := &Email{}
	o.DeepCopyInto(out)

	return out
}

// DeepCopyInto copies the receiver into the given *Email.
func (o *Email) DeepCopyInto(out *Email) {

	target, err := copystructure.Copy(o)
	if err != nil {
		panic(fmt.Sprintf("Unable to deepcopy Email: %s", err))
	}

	*out = *target.(*Email)
}

// Validate valides the current information stored into the structure.
func (o *Email) Validate() error {

	errors := elemental.Errors{}
	requiredErrors := elemental.Errors{}

	if err := ValidateEmails("BCC", o.BCC); err != nil {
		errors = errors.Append(err)
	}

	if err := ValidateEmails("CC", o.CC); err != nil {
		errors = errors.Append(err)
	}

	if err := elemental.ValidateRequiredString("body", o.Body); err != nil {
		requiredErrors = requiredErrors.Append(err)
	}

	if err := elemental.ValidateRequiredString("contentType", string(o.ContentType)); err != nil {
		requiredErrors = requiredErrors.Append(err)
	}

	if err := elemental.ValidateStringInList("contentType", string(o.ContentType), []string{"HTML", "Text"}, false); err != nil {
		errors = errors.Append(err)
	}

	if err := ValidateEmail("from", o.From); err != nil {
		errors = errors.Append(err)
	}

	if err := elemental.ValidateRequiredString("subject", o.Subject); err != nil {
		requiredErrors = requiredErrors.Append(err)
	}

	if err := elemental.ValidateRequiredExternal("to", o.To); err != nil {
		requiredErrors = requiredErrors.Append(err)
	}

	if err := ValidateEmails("to", o.To); err != nil {
		errors = errors.Append(err)
	}

	if len(requiredErrors) > 0 {
		return requiredErrors
	}

	if len(errors) > 0 {
		return errors
	}

	return nil
}

// SpecificationForAttribute returns the AttributeSpecification for the given attribute name key.
func (*Email) SpecificationForAttribute(name string) elemental.AttributeSpecification {

	if v, ok := EmailAttributesMap[name]; ok {
		return v
	}

	// We could not find it, so let's check on the lower case indexed spec map
	return EmailLowerCaseAttributesMap[name]
}

// AttributeSpecifications returns the full attribute specifications map.
func (*Email) AttributeSpecifications() map[string]elemental.AttributeSpecification {

	return EmailAttributesMap
}

// ValueForAttribute returns the value for the given attribute.
// This is a very advanced function that you should not need but in some
// very specific use cases.
func (o *Email) ValueForAttribute(name string) any {

	switch name {
	case "BCC":
		return o.BCC
	case "CC":
		return o.CC
	case "attachments":
		return o.Attachments
	case "body":
		return o.Body
	case "contentType":
		return o.ContentType
	case "from":
		return o.From
	case "subject":
		return o.Subject
	case "to":
		return o.To
	}

	return nil
}

// EmailAttributesMap represents the map of attribute for Email.
var EmailAttributesMap = map[string]elemental.AttributeSpecification{
	"BCC": {
		AllowedChoices: []string{},
		ConvertedName:  "BCC",
		Description:    `The list of email recipients to set for the BCC field.`,
		Exposed:        true,
		Name:           "BCC",
		SubType:        "string",
		Type:           "list",
	},
	"CC": {
		AllowedChoices: []string{},
		ConvertedName:  "CC",
		Description:    `The list of email recipients to set for the CC field.`,
		Exposed:        true,
		Name:           "CC",
		SubType:        "string",
		Type:           "list",
	},
	"Attachments": {
		AllowedChoices: []string{},
		ConvertedName:  "Attachments",
		Description:    `The attachment(s) to send with the email.`,
		Exposed:        true,
		Name:           "attachments",
		SubType:        "map[string][]byte",
		Type:           "external",
	},
	"Body": {
		AllowedChoices: []string{},
		ConvertedName:  "Body",
		Description:    `The body of the email.`,
		Exposed:        true,
		Name:           "body",
		Required:       true,
		Type:           "string",
	},
	"ContentType": {
		AllowedChoices: []string{"HTML", "Text"},
		ConvertedName:  "ContentType",
		DefaultValue:   EmailContentTypeText,
		Description:    `The type of content being sent.`,
		Exposed:        true,
		Name:           "contentType",
		Required:       true,
		Type:           "enum",
	},
	"From": {
		AllowedChoices: []string{},
		ConvertedName:  "From",
		Description:    `If set, the email to set for the From field.`,
		Exposed:        true,
		Name:           "from",
		Type:           "string",
	},
	"Subject": {
		AllowedChoices: []string{},
		ConvertedName:  "Subject",
		Description:    `The subject of the email.`,
		Exposed:        true,
		Name:           "subject",
		Required:       true,
		Type:           "string",
	},
	"To": {
		AllowedChoices: []string{},
		ConvertedName:  "To",
		Description:    `The list of email recipients to set for the To field.`,
		Exposed:        true,
		Name:           "to",
		Required:       true,
		SubType:        "string",
		Type:           "list",
	},
}

// EmailLowerCaseAttributesMap represents the map of attribute for Email.
var EmailLowerCaseAttributesMap = map[string]elemental.AttributeSpecification{
	"bcc": {
		AllowedChoices: []string{},
		ConvertedName:  "BCC",
		Description:    `The list of email recipients to set for the BCC field.`,
		Exposed:        true,
		Name:           "BCC",
		SubType:        "string",
		Type:           "list",
	},
	"cc": {
		AllowedChoices: []string{},
		ConvertedName:  "CC",
		Description:    `The list of email recipients to set for the CC field.`,
		Exposed:        true,
		Name:           "CC",
		SubType:        "string",
		Type:           "list",
	},
	"attachments": {
		AllowedChoices: []string{},
		ConvertedName:  "Attachments",
		Description:    `The attachment(s) to send with the email.`,
		Exposed:        true,
		Name:           "attachments",
		SubType:        "map[string][]byte",
		Type:           "external",
	},
	"body": {
		AllowedChoices: []string{},
		ConvertedName:  "Body",
		Description:    `The body of the email.`,
		Exposed:        true,
		Name:           "body",
		Required:       true,
		Type:           "string",
	},
	"contenttype": {
		AllowedChoices: []string{"HTML", "Text"},
		ConvertedName:  "ContentType",
		DefaultValue:   EmailContentTypeText,
		Description:    `The type of content being sent.`,
		Exposed:        true,
		Name:           "contentType",
		Required:       true,
		Type:           "enum",
	},
	"from": {
		AllowedChoices: []string{},
		ConvertedName:  "From",
		Description:    `If set, the email to set for the From field.`,
		Exposed:        true,
		Name:           "from",
		Type:           "string",
	},
	"subject": {
		AllowedChoices: []string{},
		ConvertedName:  "Subject",
		Description:    `The subject of the email.`,
		Exposed:        true,
		Name:           "subject",
		Required:       true,
		Type:           "string",
	},
	"to": {
		AllowedChoices: []string{},
		ConvertedName:  "To",
		Description:    `The list of email recipients to set for the To field.`,
		Exposed:        true,
		Name:           "to",
		Required:       true,
		SubType:        "string",
		Type:           "list",
	},
}

// SparseEmailsList represents a list of SparseEmails
type SparseEmailsList []*SparseEmail

// Identity returns the identity of the objects in the list.
func (o SparseEmailsList) Identity() elemental.Identity {

	return EmailIdentity
}

// Copy returns a pointer to a copy the SparseEmailsList.
func (o SparseEmailsList) Copy() elemental.Identifiables {

	copy := append(SparseEmailsList{}, o...)
	return &copy
}

// Append appends the objects to the a new copy of the SparseEmailsList.
func (o SparseEmailsList) Append(objects ...elemental.Identifiable) elemental.Identifiables {

	out := append(SparseEmailsList{}, o...)
	for _, obj := range objects {
		out = append(out, obj.(*SparseEmail))
	}

	return out
}

// List converts the object to an elemental.IdentifiablesList.
func (o SparseEmailsList) List() elemental.IdentifiablesList {

	out := make(elemental.IdentifiablesList, len(o))
	for i := 0; i < len(o); i++ {
		out[i] = o[i]
	}

	return out
}

// DefaultOrder returns the default ordering fields of the content.
func (o SparseEmailsList) DefaultOrder() []string {

	return []string{}
}

// ToPlain returns the SparseEmailsList converted to EmailsList.
func (o SparseEmailsList) ToPlain() elemental.IdentifiablesList {

	out := make(elemental.IdentifiablesList, len(o))
	for i := 0; i < len(o); i++ {
		out[i] = o[i].ToPlain()
	}

	return out
}

// Version returns the version of the content.
func (o SparseEmailsList) Version() int {

	return 1
}

// SparseEmail represents the sparse version of a email.
type SparseEmail struct {
	// The list of email recipients to set for the BCC field.
	BCC *[]string `json:"BCC,omitempty" msgpack:"BCC,omitempty" bson:"-" mapstructure:"BCC,omitempty"`

	// The list of email recipients to set for the CC field.
	CC *[]string `json:"CC,omitempty" msgpack:"CC,omitempty" bson:"-" mapstructure:"CC,omitempty"`

	// The attachment(s) to send with the email.
	Attachments *map[string][]byte `json:"attachments,omitempty" msgpack:"attachments,omitempty" bson:"-" mapstructure:"attachments,omitempty"`

	// The body of the email.
	Body *string `json:"body,omitempty" msgpack:"body,omitempty" bson:"-" mapstructure:"body,omitempty"`

	// The type of content being sent.
	ContentType *EmailContentTypeValue `json:"contentType,omitempty" msgpack:"contentType,omitempty" bson:"-" mapstructure:"contentType,omitempty"`

	// If set, the email to set for the From field.
	From *string `json:"from,omitempty" msgpack:"from,omitempty" bson:"-" mapstructure:"from,omitempty"`

	// The subject of the email.
	Subject *string `json:"subject,omitempty" msgpack:"subject,omitempty" bson:"-" mapstructure:"subject,omitempty"`

	// The list of email recipients to set for the To field.
	To *[]string `json:"to,omitempty" msgpack:"to,omitempty" bson:"-" mapstructure:"to,omitempty"`

	ModelVersion int `json:"-" msgpack:"-" bson:"_modelversion"`
}

// NewSparseEmail returns a new  SparseEmail.
func NewSparseEmail() *SparseEmail {
	return &SparseEmail{}
}

// Identity returns the Identity of the sparse object.
func (o *SparseEmail) Identity() elemental.Identity {

	return EmailIdentity
}

// Identifier returns the value of the sparse object's unique identifier.
func (o *SparseEmail) Identifier() string {

	return ""
}

// SetIdentifier sets the value of the sparse object's unique identifier.
func (o *SparseEmail) SetIdentifier(id string) {

}

// GetBSON implements the bson marshaling interface.
// This is used to transparently convert ID to MongoDBID as ObectID.
func (o *SparseEmail) GetBSON() (any, error) {

	if o == nil {
		return nil, nil
	}

	s := &mongoAttributesSparseEmail{}

	return s, nil
}

// SetBSON implements the bson marshaling interface.
// This is used to transparently convert ID to MongoDBID as ObectID.
func (o *SparseEmail) SetBSON(raw bson.Raw) error {

	if o == nil {
		return nil
	}

	s := &mongoAttributesSparseEmail{}
	if err := raw.Unmarshal(s); err != nil {
		return err
	}

	return nil
}

// Version returns the hardcoded version of the model.
func (o *SparseEmail) Version() int {

	return 1
}

// ToPlain returns the plain version of the sparse model.
func (o *SparseEmail) ToPlain() elemental.PlainIdentifiable {

	out := NewEmail()
	if o.BCC != nil {
		out.BCC = *o.BCC
	}
	if o.CC != nil {
		out.CC = *o.CC
	}
	if o.Attachments != nil {
		out.Attachments = *o.Attachments
	}
	if o.Body != nil {
		out.Body = *o.Body
	}
	if o.ContentType != nil {
		out.ContentType = *o.ContentType
	}
	if o.From != nil {
		out.From = *o.From
	}
	if o.Subject != nil {
		out.Subject = *o.Subject
	}
	if o.To != nil {
		out.To = *o.To
	}

	return out
}

// DeepCopy returns a deep copy if the SparseEmail.
func (o *SparseEmail) DeepCopy() *SparseEmail {

	if o == nil {
		return nil
	}

	out := &SparseEmail{}
	o.DeepCopyInto(out)

	return out
}

// DeepCopyInto copies the receiver into the given *SparseEmail.
func (o *SparseEmail) DeepCopyInto(out *SparseEmail) {

	target, err := copystructure.Copy(o)
	if err != nil {
		panic(fmt.Sprintf("Unable to deepcopy SparseEmail: %s", err))
	}

	*out = *target.(*SparseEmail)
}

type mongoAttributesEmail struct {
}
type mongoAttributesSparseEmail struct {
}
