// Code generated by elegen. DO NOT EDIT.
// Source: go.acuvity.ai/elemental (templates/model.gotpl)

package api

import (
	"fmt"
	"slices"
	"time"

	"github.com/globalsign/mgo/bson"
	"github.com/mitchellh/copystructure"
	"go.acuvity.ai/elemental"
)

// ProxyRoundtripDecisionValue represents the possible values for attribute "decision".
type ProxyRoundtripDecisionValue string

const (
	// ProxyRoundtripDecisionAllow represents the value Allow.
	ProxyRoundtripDecisionAllow ProxyRoundtripDecisionValue = "Allow"

	// ProxyRoundtripDecisionAsk represents the value Ask.
	ProxyRoundtripDecisionAsk ProxyRoundtripDecisionValue = "Ask"

	// ProxyRoundtripDecisionBypassed represents the value Bypassed.
	ProxyRoundtripDecisionBypassed ProxyRoundtripDecisionValue = "Bypassed"

	// ProxyRoundtripDecisionDeny represents the value Deny.
	ProxyRoundtripDecisionDeny ProxyRoundtripDecisionValue = "Deny"

	// ProxyRoundtripDecisionForbiddenUser represents the value ForbiddenUser.
	ProxyRoundtripDecisionForbiddenUser ProxyRoundtripDecisionValue = "ForbiddenUser"

	// ProxyRoundtripDecisionSkipped represents the value Skipped.
	ProxyRoundtripDecisionSkipped ProxyRoundtripDecisionValue = "Skipped"
)

// ProxyRoundtripProxyFunctionValue represents the possible values for attribute "proxyFunction".
type ProxyRoundtripProxyFunctionValue string

const (
	// ProxyRoundtripProxyFunctionForwardProxy represents the value ForwardProxy.
	ProxyRoundtripProxyFunctionForwardProxy ProxyRoundtripProxyFunctionValue = "ForwardProxy"

	// ProxyRoundtripProxyFunctionReverseProxy represents the value ReverseProxy.
	ProxyRoundtripProxyFunctionReverseProxy ProxyRoundtripProxyFunctionValue = "ReverseProxy"
)

// ProxyRoundtripTypeValue represents the possible values for attribute "type".
type ProxyRoundtripTypeValue string

const (
	// ProxyRoundtripTypeInput represents the value Input.
	ProxyRoundtripTypeInput ProxyRoundtripTypeValue = "Input"

	// ProxyRoundtripTypeOutput represents the value Output.
	ProxyRoundtripTypeOutput ProxyRoundtripTypeValue = "Output"
)

// ProxyRoundtripIdentity represents the Identity of the object.
var ProxyRoundtripIdentity = elemental.Identity{
	Name:     "proxyroundtrip",
	Category: "proxyroundtrips",
	Package:  "colektor",
	Private:  false,
}

// ProxyRoundtripsList represents a list of ProxyRoundtrips
type ProxyRoundtripsList []*ProxyRoundtrip

// Identity returns the identity of the objects in the list.
func (o ProxyRoundtripsList) Identity() elemental.Identity {

	return ProxyRoundtripIdentity
}

// Copy returns a pointer to a copy the ProxyRoundtripsList.
func (o ProxyRoundtripsList) Copy() elemental.Identifiables {

	out := slices.Clone(o)
	return &out
}

// Append appends the objects to the a new copy of the ProxyRoundtripsList.
func (o ProxyRoundtripsList) Append(objects ...elemental.Identifiable) elemental.Identifiables {

	out := slices.Clone(o)
	for _, obj := range objects {
		out = append(out, obj.(*ProxyRoundtrip))
	}

	return out
}

// List converts the object to an elemental.IdentifiablesList.
func (o ProxyRoundtripsList) List() elemental.IdentifiablesList {

	out := make(elemental.IdentifiablesList, len(o))
	for i := range len(o) {
		out[i] = o[i]
	}

	return out
}

// DefaultOrder returns the default ordering fields of the content.
func (o ProxyRoundtripsList) DefaultOrder() []string {

	return []string{}
}

// ToSparse returns the ProxyRoundtripsList converted to SparseProxyRoundtripsList.
// Objects in the list will only contain the given fields. No field means entire field set.
func (o ProxyRoundtripsList) ToSparse(fields ...string) elemental.Identifiables {

	out := make(SparseProxyRoundtripsList, len(o))
	for i := range len(o) {
		out[i] = o[i].ToSparse(fields...).(*SparseProxyRoundtrip)
	}

	return out
}

// Version returns the version of the content.
func (o ProxyRoundtripsList) Version() int {

	return 1
}

// ProxyRoundtrip represents the model of a proxyroundtrip
type ProxyRoundtrip struct {
	// ID is the identifier of the object.
	ID string `json:"ID,omitempty" msgpack:"ID,omitempty" bson:"-" mapstructure:"ID,omitempty"`

	// List of alerts that got raised during the policy resolution.
	Alerts []*AlertEvent `json:"alerts,omitempty" msgpack:"alerts,omitempty" bson:"alerts,omitempty" mapstructure:"alerts,omitempty"`

	// Annotations attached to the log.
	Annotations map[string]string `json:"annotations,omitempty" msgpack:"annotations,omitempty" bson:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// The client used to send the request.
	Client string `json:"client,omitempty" msgpack:"client,omitempty" bson:"client,omitempty" mapstructure:"client,omitempty"`

	// The version of the client used to send the request.
	ClientVersion string `json:"clientVersion,omitempty" msgpack:"clientVersion,omitempty" bson:"clientversion,omitempty" mapstructure:"clientVersion,omitempty"`

	// Tell what was the decision about the data.
	Decision ProxyRoundtripDecisionValue `json:"decision" msgpack:"decision" bson:"decision" mapstructure:"decision,omitempty"`

	// Captures all details of the destination of the request.
	Destination *Destination `json:"destination,omitempty" msgpack:"destination,omitempty" bson:"destination,omitempty" mapstructure:"destination,omitempty"`

	// The encryption details of the connection from the proxy to the origin server.
	EncryptionEgress *TLSState `json:"encryptionEgress,omitempty" msgpack:"encryptionEgress,omitempty" bson:"encryptionegress,omitempty" mapstructure:"encryptionEgress,omitempty"`

	// The encryption details of the connection from the client to the proxy.
	EncryptionIngress *TLSState `json:"encryptionIngress,omitempty" msgpack:"encryptionIngress,omitempty" bson:"encryptioningress,omitempty" mapstructure:"encryptionIngress,omitempty"`

	// The extractions to log.
	Extractions []*Extraction `json:"extractions,omitempty" msgpack:"extractions,omitempty" bson:"extractions,omitempty" mapstructure:"extractions,omitempty"`

	// The hash of the input.
	Hash string `json:"hash" msgpack:"hash" bson:"hash" mapstructure:"hash,omitempty"`

	// The hash of the structure used to compare with new import version.
	ImportHash string `json:"importHash,omitempty" msgpack:"importHash,omitempty" bson:"importhash,omitempty" mapstructure:"importHash,omitempty"`

	// The user-defined import label that allows the system to group resources from the
	// same import operation.
	ImportLabel string `json:"importLabel,omitempty" msgpack:"importLabel,omitempty" bson:"importlabel,omitempty" mapstructure:"importLabel,omitempty"`

	// Information about latency of various stage of request and response.
	Latency *Latency `json:"latency,omitempty" msgpack:"latency,omitempty" bson:"latency,omitempty" mapstructure:"latency,omitempty"`

	// If this is an MCP message, then the MCP message details will be set here.
	McpMessage *MCPMessage `json:"mcpMessage,omitempty" msgpack:"mcpMessage,omitempty" bson:"mcpmessage,omitempty" mapstructure:"mcpMessage,omitempty"`

	// The model used by the request.
	Model string `json:"model" msgpack:"model" bson:"model" mapstructure:"model,omitempty"`

	// The namespace of the object.
	Namespace string `json:"namespace,omitempty" msgpack:"namespace,omitempty" bson:"namespace,omitempty" mapstructure:"namespace,omitempty"`

	// If true, the analysis ran offband. That means that we extracted the data
	// from the user request, assigned team and verified access permissions, but
	// then we forwarded the request as is to the provider untouched
	// immediately, while running the analysis and policies in the background,
	// reporting what we would have done.
	Offband bool `json:"offband" msgpack:"offband" bson:"offband" mapstructure:"offband,omitempty"`

	// If true, the policy has been applied in permissive mode.  That means that
	// we extracted the data from the user request, assigned team, verified
	// access permissions, run analysis, apply content policies and reported what
	// we would have done, but ultimately let the request go to the provider
	// untouched.
	Permissive bool `json:"permissive" msgpack:"permissive" bson:"permissive" mapstructure:"permissive,omitempty"`

	// The name of the particular pipeline that extracted the text.
	PipelineName string `json:"pipelineName" msgpack:"pipelineName" bson:"pipelinename" mapstructure:"pipelineName,omitempty"`

	// List of references to the policies used to make this roundtrip.
	PolicyRefs PolicyRefsList `json:"policyRefs" msgpack:"policyRefs" bson:"policyrefs" mapstructure:"policyRefs,omitempty"`

	// The principal of the object.
	Principal *Principal `json:"principal" msgpack:"principal" bson:"principal" mapstructure:"principal,omitempty"`

	// The provider to use.
	Provider string `json:"provider" msgpack:"provider" bson:"provider" mapstructure:"provider,omitempty"`

	// Denotes the function of this proxy in the chain of servers. By default the apex
	// always sits on the egress side between a client or application and the origin
	// server in which case the apex acts as a forwarding proxy. However, in the case
	// of applications the proxy can also be located before the application as an
	// ingress provider in which case the apex acts as a reverse proxy.
	ProxyFunction ProxyRoundtripProxyFunctionValue `json:"proxyFunction,omitempty" msgpack:"proxyFunction,omitempty" bson:"proxyfunction,omitempty" mapstructure:"proxyFunction,omitempty"`

	// The various reasons returned by the policy engine.
	Reasons []string `json:"reasons,omitempty" msgpack:"reasons,omitempty" bson:"reasons,omitempty" mapstructure:"reasons,omitempty"`

	// The summary of the extractions.
	Summary *ExtractionSummary `json:"summary,omitempty" msgpack:"summary,omitempty" bson:"summary,omitempty" mapstructure:"summary,omitempty"`

	// Set the time of the message request.
	Time time.Time `json:"time,omitempty" msgpack:"time,omitempty" bson:"-" mapstructure:"time,omitempty"`

	// Tool choice instructions for the model of a request.
	ToolChoice *ToolChoice `json:"toolChoice,omitempty" msgpack:"toolChoice,omitempty" bson:"toolchoice,omitempty" mapstructure:"toolChoice,omitempty"`

	// The various tools used by the request.
	Tools map[string]*Tool `json:"tools,omitempty" msgpack:"tools,omitempty" bson:"tools,omitempty" mapstructure:"tools,omitempty"`

	// References to the trace of the request.
	Trace *TraceRef `json:"trace,omitempty" msgpack:"trace,omitempty" bson:"trace,omitempty" mapstructure:"trace,omitempty"`

	// The type of text.
	Type ProxyRoundtripTypeValue `json:"type" msgpack:"type" bson:"type" mapstructure:"type,omitempty"`

	ModelVersion int `json:"-" msgpack:"-" bson:"_modelversion"`
}

// NewProxyRoundtrip returns a new *ProxyRoundtrip
func NewProxyRoundtrip() *ProxyRoundtrip {

	return &ProxyRoundtrip{
		ModelVersion:  1,
		Annotations:   map[string]string{},
		PolicyRefs:    PolicyRefsList{},
		Principal:     NewPrincipal(),
		ProxyFunction: ProxyRoundtripProxyFunctionForwardProxy,
	}
}

// Identity returns the Identity of the object.
func (o *ProxyRoundtrip) Identity() elemental.Identity {

	return ProxyRoundtripIdentity
}

// Identifier returns the value of the object's unique identifier.
func (o *ProxyRoundtrip) Identifier() string {

	return o.ID
}

// SetIdentifier sets the value of the object's unique identifier.
func (o *ProxyRoundtrip) SetIdentifier(id string) {

	o.ID = id
}

// GetBSON implements the bson marshaling interface.
// This is used to transparently convert ID to MongoDBID as ObectID.
func (o *ProxyRoundtrip) GetBSON() (any, error) {

	if o == nil {
		return nil, nil
	}

	s := &mongoAttributesProxyRoundtrip{}

	if o.ID != "" {
		s.ID = bson.ObjectIdHex(o.ID)
	}
	s.Alerts = o.Alerts
	s.Annotations = o.Annotations
	s.Client = o.Client
	s.ClientVersion = o.ClientVersion
	s.Decision = o.Decision
	s.Destination = o.Destination
	s.EncryptionEgress = o.EncryptionEgress
	s.EncryptionIngress = o.EncryptionIngress
	s.Extractions = o.Extractions
	s.Hash = o.Hash
	s.ImportHash = o.ImportHash
	s.ImportLabel = o.ImportLabel
	s.Latency = o.Latency
	s.McpMessage = o.McpMessage
	s.Model = o.Model
	s.Namespace = o.Namespace
	s.Offband = o.Offband
	s.Permissive = o.Permissive
	s.PipelineName = o.PipelineName
	s.PolicyRefs = o.PolicyRefs
	s.Principal = o.Principal
	s.Provider = o.Provider
	s.ProxyFunction = o.ProxyFunction
	s.Reasons = o.Reasons
	s.Summary = o.Summary
	s.ToolChoice = o.ToolChoice
	s.Tools = o.Tools
	s.Trace = o.Trace
	s.Type = o.Type

	return s, nil
}

// SetBSON implements the bson marshaling interface.
// This is used to transparently convert ID to MongoDBID as ObectID.
func (o *ProxyRoundtrip) SetBSON(raw bson.Raw) error {

	if o == nil {
		return nil
	}

	s := &mongoAttributesProxyRoundtrip{}
	if err := raw.Unmarshal(s); err != nil {
		return err
	}

	o.ID = s.ID.Hex()
	o.Alerts = s.Alerts
	o.Annotations = s.Annotations
	o.Client = s.Client
	o.ClientVersion = s.ClientVersion
	o.Decision = s.Decision
	o.Destination = s.Destination
	o.EncryptionEgress = s.EncryptionEgress
	o.EncryptionIngress = s.EncryptionIngress
	o.Extractions = s.Extractions
	o.Hash = s.Hash
	o.ImportHash = s.ImportHash
	o.ImportLabel = s.ImportLabel
	o.Latency = s.Latency
	o.McpMessage = s.McpMessage
	o.Model = s.Model
	o.Namespace = s.Namespace
	o.Offband = s.Offband
	o.Permissive = s.Permissive
	o.PipelineName = s.PipelineName
	o.PolicyRefs = s.PolicyRefs
	o.Principal = s.Principal
	o.Provider = s.Provider
	o.ProxyFunction = s.ProxyFunction
	o.Reasons = s.Reasons
	o.Summary = s.Summary
	o.ToolChoice = s.ToolChoice
	o.Tools = s.Tools
	o.Trace = s.Trace
	o.Type = s.Type

	return nil
}

// Version returns the hardcoded version of the model.
func (o *ProxyRoundtrip) Version() int {

	return 1
}

// BleveType implements the bleve.Classifier Interface.
func (o *ProxyRoundtrip) BleveType() string {

	return "proxyroundtrip"
}

// DefaultOrder returns the list of default ordering fields.
func (o *ProxyRoundtrip) DefaultOrder() []string {

	return []string{}
}

// Doc returns the documentation for the object
func (o *ProxyRoundtrip) Doc() string {

	return `This is a Proxy roundtrip.`
}

func (o *ProxyRoundtrip) String() string {

	return fmt.Sprintf("<%s:%s>", o.Identity().Name, o.Identifier())
}

// GetImportHash returns the ImportHash of the receiver.
func (o *ProxyRoundtrip) GetImportHash() string {

	return o.ImportHash
}

// SetImportHash sets the property ImportHash of the receiver using the given value.
func (o *ProxyRoundtrip) SetImportHash(importHash string) {

	o.ImportHash = importHash
}

// GetImportLabel returns the ImportLabel of the receiver.
func (o *ProxyRoundtrip) GetImportLabel() string {

	return o.ImportLabel
}

// SetImportLabel sets the property ImportLabel of the receiver using the given value.
func (o *ProxyRoundtrip) SetImportLabel(importLabel string) {

	o.ImportLabel = importLabel
}

// GetNamespace returns the Namespace of the receiver.
func (o *ProxyRoundtrip) GetNamespace() string {

	return o.Namespace
}

// SetNamespace sets the property Namespace of the receiver using the given value.
func (o *ProxyRoundtrip) SetNamespace(namespace string) {

	o.Namespace = namespace
}

// ToSparse returns the sparse version of the model.
// The returned object will only contain the given fields. No field means entire field set.
func (o *ProxyRoundtrip) ToSparse(fields ...string) elemental.SparseIdentifiable {

	if len(fields) == 0 {
		// nolint: goimports
		return &SparseProxyRoundtrip{
			ID:                &o.ID,
			Alerts:            &o.Alerts,
			Annotations:       &o.Annotations,
			Client:            &o.Client,
			ClientVersion:     &o.ClientVersion,
			Decision:          &o.Decision,
			Destination:       o.Destination,
			EncryptionEgress:  o.EncryptionEgress,
			EncryptionIngress: o.EncryptionIngress,
			Extractions:       &o.Extractions,
			Hash:              &o.Hash,
			ImportHash:        &o.ImportHash,
			ImportLabel:       &o.ImportLabel,
			Latency:           o.Latency,
			McpMessage:        o.McpMessage,
			Model:             &o.Model,
			Namespace:         &o.Namespace,
			Offband:           &o.Offband,
			Permissive:        &o.Permissive,
			PipelineName:      &o.PipelineName,
			PolicyRefs:        &o.PolicyRefs,
			Principal:         o.Principal,
			Provider:          &o.Provider,
			ProxyFunction:     &o.ProxyFunction,
			Reasons:           &o.Reasons,
			Summary:           o.Summary,
			Time:              &o.Time,
			ToolChoice:        o.ToolChoice,
			Tools:             &o.Tools,
			Trace:             o.Trace,
			Type:              &o.Type,
		}
	}

	sp := &SparseProxyRoundtrip{}
	for _, f := range fields {
		switch f {
		case "ID":
			sp.ID = &(o.ID)
		case "alerts":
			sp.Alerts = &(o.Alerts)
		case "annotations":
			sp.Annotations = &(o.Annotations)
		case "client":
			sp.Client = &(o.Client)
		case "clientVersion":
			sp.ClientVersion = &(o.ClientVersion)
		case "decision":
			sp.Decision = &(o.Decision)
		case "destination":
			sp.Destination = o.Destination
		case "encryptionEgress":
			sp.EncryptionEgress = o.EncryptionEgress
		case "encryptionIngress":
			sp.EncryptionIngress = o.EncryptionIngress
		case "extractions":
			sp.Extractions = &(o.Extractions)
		case "hash":
			sp.Hash = &(o.Hash)
		case "importHash":
			sp.ImportHash = &(o.ImportHash)
		case "importLabel":
			sp.ImportLabel = &(o.ImportLabel)
		case "latency":
			sp.Latency = o.Latency
		case "mcpMessage":
			sp.McpMessage = o.McpMessage
		case "model":
			sp.Model = &(o.Model)
		case "namespace":
			sp.Namespace = &(o.Namespace)
		case "offband":
			sp.Offband = &(o.Offband)
		case "permissive":
			sp.Permissive = &(o.Permissive)
		case "pipelineName":
			sp.PipelineName = &(o.PipelineName)
		case "policyRefs":
			sp.PolicyRefs = &(o.PolicyRefs)
		case "principal":
			sp.Principal = o.Principal
		case "provider":
			sp.Provider = &(o.Provider)
		case "proxyFunction":
			sp.ProxyFunction = &(o.ProxyFunction)
		case "reasons":
			sp.Reasons = &(o.Reasons)
		case "summary":
			sp.Summary = o.Summary
		case "time":
			sp.Time = &(o.Time)
		case "toolChoice":
			sp.ToolChoice = o.ToolChoice
		case "tools":
			sp.Tools = &(o.Tools)
		case "trace":
			sp.Trace = o.Trace
		case "type":
			sp.Type = &(o.Type)
		}
	}

	return sp
}

// Patch apply the non nil value of a *SparseProxyRoundtrip to the object.
func (o *ProxyRoundtrip) Patch(sparse elemental.SparseIdentifiable) {
	if !sparse.Identity().IsEqual(o.Identity()) {
		panic("cannot patch from a parse with different identity")
	}

	so := sparse.(*SparseProxyRoundtrip)
	if so.ID != nil {
		o.ID = *so.ID
	}
	if so.Alerts != nil {
		o.Alerts = *so.Alerts
	}
	if so.Annotations != nil {
		o.Annotations = *so.Annotations
	}
	if so.Client != nil {
		o.Client = *so.Client
	}
	if so.ClientVersion != nil {
		o.ClientVersion = *so.ClientVersion
	}
	if so.Decision != nil {
		o.Decision = *so.Decision
	}
	if so.Destination != nil {
		o.Destination = so.Destination
	}
	if so.EncryptionEgress != nil {
		o.EncryptionEgress = so.EncryptionEgress
	}
	if so.EncryptionIngress != nil {
		o.EncryptionIngress = so.EncryptionIngress
	}
	if so.Extractions != nil {
		o.Extractions = *so.Extractions
	}
	if so.Hash != nil {
		o.Hash = *so.Hash
	}
	if so.ImportHash != nil {
		o.ImportHash = *so.ImportHash
	}
	if so.ImportLabel != nil {
		o.ImportLabel = *so.ImportLabel
	}
	if so.Latency != nil {
		o.Latency = so.Latency
	}
	if so.McpMessage != nil {
		o.McpMessage = so.McpMessage
	}
	if so.Model != nil {
		o.Model = *so.Model
	}
	if so.Namespace != nil {
		o.Namespace = *so.Namespace
	}
	if so.Offband != nil {
		o.Offband = *so.Offband
	}
	if so.Permissive != nil {
		o.Permissive = *so.Permissive
	}
	if so.PipelineName != nil {
		o.PipelineName = *so.PipelineName
	}
	if so.PolicyRefs != nil {
		o.PolicyRefs = *so.PolicyRefs
	}
	if so.Principal != nil {
		o.Principal = so.Principal
	}
	if so.Provider != nil {
		o.Provider = *so.Provider
	}
	if so.ProxyFunction != nil {
		o.ProxyFunction = *so.ProxyFunction
	}
	if so.Reasons != nil {
		o.Reasons = *so.Reasons
	}
	if so.Summary != nil {
		o.Summary = so.Summary
	}
	if so.Time != nil {
		o.Time = *so.Time
	}
	if so.ToolChoice != nil {
		o.ToolChoice = so.ToolChoice
	}
	if so.Tools != nil {
		o.Tools = *so.Tools
	}
	if so.Trace != nil {
		o.Trace = so.Trace
	}
	if so.Type != nil {
		o.Type = *so.Type
	}
}

// DeepCopy returns a deep copy if the ProxyRoundtrip.
func (o *ProxyRoundtrip) DeepCopy() *ProxyRoundtrip {

	if o == nil {
		return nil
	}

	out := &ProxyRoundtrip{}
	o.DeepCopyInto(out)

	return out
}

// DeepCopyInto copies the receiver into the given *ProxyRoundtrip.
func (o *ProxyRoundtrip) DeepCopyInto(out *ProxyRoundtrip) {

	target, err := copystructure.Copy(o)
	if err != nil {
		panic(fmt.Sprintf("Unable to deepcopy ProxyRoundtrip: %s", err))
	}

	*out = *target.(*ProxyRoundtrip)
}

// Validate valides the current information stored into the structure.
func (o *ProxyRoundtrip) Validate() error {

	errors := elemental.Errors{}
	requiredErrors := elemental.Errors{}

	for _, sub := range o.Alerts {
		if sub == nil {
			continue
		}
		elemental.ResetDefaultForZeroValues(sub)
		if err := sub.Validate(); err != nil {
			errors = errors.Append(err)
		}
	}

	if err := elemental.ValidateStringInList("decision", string(o.Decision), []string{"Deny", "Allow", "Ask", "Bypassed", "ForbiddenUser", "Skipped"}, false); err != nil {
		errors = errors.Append(err)
	}

	if o.Destination != nil {
		elemental.ResetDefaultForZeroValues(o.Destination)
		if err := o.Destination.Validate(); err != nil {
			errors = errors.Append(err)
		}
	}

	if o.EncryptionEgress != nil {
		elemental.ResetDefaultForZeroValues(o.EncryptionEgress)
		if err := o.EncryptionEgress.Validate(); err != nil {
			errors = errors.Append(err)
		}
	}

	if o.EncryptionIngress != nil {
		elemental.ResetDefaultForZeroValues(o.EncryptionIngress)
		if err := o.EncryptionIngress.Validate(); err != nil {
			errors = errors.Append(err)
		}
	}

	for _, sub := range o.Extractions {
		if sub == nil {
			continue
		}
		elemental.ResetDefaultForZeroValues(sub)
		if err := sub.Validate(); err != nil {
			errors = errors.Append(err)
		}
	}

	if o.Latency != nil {
		elemental.ResetDefaultForZeroValues(o.Latency)
		if err := o.Latency.Validate(); err != nil {
			errors = errors.Append(err)
		}
	}

	if o.McpMessage != nil {
		elemental.ResetDefaultForZeroValues(o.McpMessage)
		if err := o.McpMessage.Validate(); err != nil {
			errors = errors.Append(err)
		}
	}

	for _, sub := range o.PolicyRefs {
		if sub == nil {
			continue
		}
		elemental.ResetDefaultForZeroValues(sub)
		if err := sub.Validate(); err != nil {
			errors = errors.Append(err)
		}
	}

	if o.Principal != nil {
		elemental.ResetDefaultForZeroValues(o.Principal)
		if err := o.Principal.Validate(); err != nil {
			errors = errors.Append(err)
		}
	}

	if err := elemental.ValidateStringInList("proxyFunction", string(o.ProxyFunction), []string{"ForwardProxy", "ReverseProxy"}, false); err != nil {
		errors = errors.Append(err)
	}

	if o.Summary != nil {
		elemental.ResetDefaultForZeroValues(o.Summary)
		if err := o.Summary.Validate(); err != nil {
			errors = errors.Append(err)
		}
	}

	if o.ToolChoice != nil {
		elemental.ResetDefaultForZeroValues(o.ToolChoice)
		if err := o.ToolChoice.Validate(); err != nil {
			errors = errors.Append(err)
		}
	}

	for _, sub := range o.Tools {
		if sub == nil {
			continue
		}
		elemental.ResetDefaultForZeroValues(sub)
		if err := sub.Validate(); err != nil {
			errors = errors.Append(err)
		}
	}

	if o.Trace != nil {
		elemental.ResetDefaultForZeroValues(o.Trace)
		if err := o.Trace.Validate(); err != nil {
			errors = errors.Append(err)
		}
	}

	if err := elemental.ValidateStringInList("type", string(o.Type), []string{"Input", "Output"}, false); err != nil {
		errors = errors.Append(err)
	}

	if len(requiredErrors) > 0 {
		return requiredErrors
	}

	if len(errors) > 0 {
		return errors
	}

	return nil
}

// SpecificationForAttribute returns the AttributeSpecification for the given attribute name key.
func (*ProxyRoundtrip) SpecificationForAttribute(name string) elemental.AttributeSpecification {

	if v, ok := ProxyRoundtripAttributesMap[name]; ok {
		return v
	}

	// We could not find it, so let's check on the lower case indexed spec map
	return ProxyRoundtripLowerCaseAttributesMap[name]
}

// AttributeSpecifications returns the full attribute specifications map.
func (*ProxyRoundtrip) AttributeSpecifications() map[string]elemental.AttributeSpecification {

	return ProxyRoundtripAttributesMap
}

// ValueForAttribute returns the value for the given attribute.
// This is a very advanced function that you should not need but in some
// very specific use cases.
func (o *ProxyRoundtrip) ValueForAttribute(name string) any {

	switch name {
	case "ID":
		return o.ID
	case "alerts":
		return o.Alerts
	case "annotations":
		return o.Annotations
	case "client":
		return o.Client
	case "clientVersion":
		return o.ClientVersion
	case "decision":
		return o.Decision
	case "destination":
		return o.Destination
	case "encryptionEgress":
		return o.EncryptionEgress
	case "encryptionIngress":
		return o.EncryptionIngress
	case "extractions":
		return o.Extractions
	case "hash":
		return o.Hash
	case "importHash":
		return o.ImportHash
	case "importLabel":
		return o.ImportLabel
	case "latency":
		return o.Latency
	case "mcpMessage":
		return o.McpMessage
	case "model":
		return o.Model
	case "namespace":
		return o.Namespace
	case "offband":
		return o.Offband
	case "permissive":
		return o.Permissive
	case "pipelineName":
		return o.PipelineName
	case "policyRefs":
		return o.PolicyRefs
	case "principal":
		return o.Principal
	case "provider":
		return o.Provider
	case "proxyFunction":
		return o.ProxyFunction
	case "reasons":
		return o.Reasons
	case "summary":
		return o.Summary
	case "time":
		return o.Time
	case "toolChoice":
		return o.ToolChoice
	case "tools":
		return o.Tools
	case "trace":
		return o.Trace
	case "type":
		return o.Type
	}

	return nil
}

// ProxyRoundtripAttributesMap represents the map of attribute for ProxyRoundtrip.
var ProxyRoundtripAttributesMap = map[string]elemental.AttributeSpecification{
	"ID": {
		AllowedChoices: []string{},
		Autogenerated:  true,
		BSONFieldName:  "_id",
		ConvertedName:  "ID",
		Description:    `ID is the identifier of the object.`,
		Exposed:        true,
		Filterable:     true,
		Identifier:     true,
		Name:           "ID",
		Orderable:      true,
		ReadOnly:       true,
		Stored:         true,
		Type:           "string",
	},
	"Alerts": {
		AllowedChoices: []string{},
		BSONFieldName:  "alerts",
		ConvertedName:  "Alerts",
		Description:    `List of alerts that got raised during the policy resolution.`,
		Exposed:        true,
		Name:           "alerts",
		Stored:         true,
		SubType:        "alertevent",
		Type:           "refList",
	},
	"Annotations": {
		AllowedChoices: []string{},
		BSONFieldName:  "annotations",
		ConvertedName:  "Annotations",
		Description:    `Annotations attached to the log.`,
		Exposed:        true,
		Name:           "annotations",
		Stored:         true,
		SubType:        "map[string]string",
		Type:           "external",
	},
	"Client": {
		AllowedChoices: []string{},
		BSONFieldName:  "client",
		ConvertedName:  "Client",
		Description:    `The client used to send the request.`,
		Exposed:        true,
		Name:           "client",
		Stored:         true,
		Type:           "string",
	},
	"ClientVersion": {
		AllowedChoices: []string{},
		BSONFieldName:  "clientversion",
		ConvertedName:  "ClientVersion",
		Description:    `The version of the client used to send the request.`,
		Exposed:        true,
		Name:           "clientVersion",
		Stored:         true,
		Type:           "string",
	},
	"Decision": {
		AllowedChoices: []string{"Deny", "Allow", "Ask", "Bypassed", "ForbiddenUser", "Skipped"},
		BSONFieldName:  "decision",
		ConvertedName:  "Decision",
		Description:    `Tell what was the decision about the data.`,
		Exposed:        true,
		Name:           "decision",
		Stored:         true,
		Type:           "enum",
	},
	"Destination": {
		AllowedChoices: []string{},
		BSONFieldName:  "destination",
		ConvertedName:  "Destination",
		Description:    `Captures all details of the destination of the request.`,
		Exposed:        true,
		Name:           "destination",
		Stored:         true,
		SubType:        "destination",
		Type:           "ref",
	},
	"EncryptionEgress": {
		AllowedChoices: []string{},
		BSONFieldName:  "encryptionegress",
		ConvertedName:  "EncryptionEgress",
		Description:    `The encryption details of the connection from the proxy to the origin server.`,
		Exposed:        true,
		Name:           "encryptionEgress",
		Stored:         true,
		SubType:        "tlsstate",
		Type:           "ref",
	},
	"EncryptionIngress": {
		AllowedChoices: []string{},
		BSONFieldName:  "encryptioningress",
		ConvertedName:  "EncryptionIngress",
		Description:    `The encryption details of the connection from the client to the proxy.`,
		Exposed:        true,
		Name:           "encryptionIngress",
		Stored:         true,
		SubType:        "tlsstate",
		Type:           "ref",
	},
	"Extractions": {
		AllowedChoices: []string{},
		BSONFieldName:  "extractions",
		ConvertedName:  "Extractions",
		Description:    `The extractions to log.`,
		Exposed:        true,
		Name:           "extractions",
		Stored:         true,
		SubType:        "extraction",
		Type:           "refList",
	},
	"Hash": {
		AllowedChoices: []string{},
		BSONFieldName:  "hash",
		ConvertedName:  "Hash",
		Description:    `The hash of the input.`,
		Exposed:        true,
		Name:           "hash",
		Stored:         true,
		Type:           "string",
	},
	"ImportHash": {
		AllowedChoices: []string{},
		Autogenerated:  true,
		BSONFieldName:  "importhash",
		ConvertedName:  "ImportHash",
		CreationOnly:   true,
		Description:    `The hash of the structure used to compare with new import version.`,
		Exposed:        true,
		Getter:         true,
		Name:           "importHash",
		Setter:         true,
		Stored:         true,
		Type:           "string",
	},
	"ImportLabel": {
		AllowedChoices: []string{},
		BSONFieldName:  "importlabel",
		ConvertedName:  "ImportLabel",
		CreationOnly:   true,
		Description: `The user-defined import label that allows the system to group resources from the
same import operation.`,
		Exposed: true,
		Getter:  true,
		Name:    "importLabel",
		Setter:  true,
		Stored:  true,
		Type:    "string",
	},
	"Latency": {
		AllowedChoices: []string{},
		BSONFieldName:  "latency",
		ConvertedName:  "Latency",
		Description:    `Information about latency of various stage of request and response.`,
		Exposed:        true,
		Name:           "latency",
		Stored:         true,
		SubType:        "latency",
		Type:           "ref",
	},
	"McpMessage": {
		AllowedChoices: []string{},
		BSONFieldName:  "mcpmessage",
		ConvertedName:  "McpMessage",
		Description:    `If this is an MCP message, then the MCP message details will be set here.`,
		Exposed:        true,
		Name:           "mcpMessage",
		Stored:         true,
		SubType:        "mcpmessage",
		Type:           "ref",
	},
	"Model": {
		AllowedChoices: []string{},
		BSONFieldName:  "model",
		ConvertedName:  "Model",
		Description:    `The model used by the request.`,
		Exposed:        true,
		Name:           "model",
		Stored:         true,
		Type:           "string",
	},
	"Namespace": {
		AllowedChoices: []string{},
		Autogenerated:  true,
		BSONFieldName:  "namespace",
		ConvertedName:  "Namespace",
		Description:    `The namespace of the object.`,
		Exposed:        true,
		Getter:         true,
		Name:           "namespace",
		Orderable:      true,
		ReadOnly:       true,
		Setter:         true,
		Stored:         true,
		Type:           "string",
	},
	"Offband": {
		AllowedChoices: []string{},
		BSONFieldName:  "offband",
		ConvertedName:  "Offband",
		Description: `If true, the analysis ran offband. That means that we extracted the data
from the user request, assigned team and verified access permissions, but
then we forwarded the request as is to the provider untouched
immediately, while running the analysis and policies in the background,
reporting what we would have done.`,
		Exposed: true,
		Name:    "offband",
		Stored:  true,
		Type:    "boolean",
	},
	"Permissive": {
		AllowedChoices: []string{},
		BSONFieldName:  "permissive",
		ConvertedName:  "Permissive",
		Description: `If true, the policy has been applied in permissive mode.  That means that
we extracted the data from the user request, assigned team, verified
access permissions, run analysis, apply content policies and reported what
we would have done, but ultimately let the request go to the provider
untouched.`,
		Exposed: true,
		Name:    "permissive",
		Stored:  true,
		Type:    "boolean",
	},
	"PipelineName": {
		AllowedChoices: []string{},
		BSONFieldName:  "pipelinename",
		ConvertedName:  "PipelineName",
		Description:    `The name of the particular pipeline that extracted the text.`,
		Exposed:        true,
		Name:           "pipelineName",
		Stored:         true,
		Type:           "string",
	},
	"PolicyRefs": {
		AllowedChoices: []string{},
		BSONFieldName:  "policyrefs",
		ConvertedName:  "PolicyRefs",
		Description:    `List of references to the policies used to make this roundtrip.`,
		Exposed:        true,
		Name:           "policyRefs",
		Stored:         true,
		SubType:        "policyref",
		Type:           "refList",
	},
	"Principal": {
		AllowedChoices: []string{},
		BSONFieldName:  "principal",
		ConvertedName:  "Principal",
		Description:    `The principal of the object.`,
		Exposed:        true,
		Name:           "principal",
		Required:       true,
		Stored:         true,
		SubType:        "principal",
		Type:           "ref",
	},
	"Provider": {
		AllowedChoices: []string{},
		BSONFieldName:  "provider",
		ConvertedName:  "Provider",
		Description:    `The provider to use.`,
		Exposed:        true,
		Name:           "provider",
		Stored:         true,
		Type:           "string",
	},
	"ProxyFunction": {
		AllowedChoices: []string{"ForwardProxy", "ReverseProxy"},
		BSONFieldName:  "proxyfunction",
		ConvertedName:  "ProxyFunction",
		DefaultValue:   ProxyRoundtripProxyFunctionForwardProxy,
		Description: `Denotes the function of this proxy in the chain of servers. By default the apex
always sits on the egress side between a client or application and the origin
server in which case the apex acts as a forwarding proxy. However, in the case
of applications the proxy can also be located before the application as an
ingress provider in which case the apex acts as a reverse proxy.`,
		Exposed: true,
		Name:    "proxyFunction",
		Stored:  true,
		Type:    "enum",
	},
	"Reasons": {
		AllowedChoices: []string{},
		BSONFieldName:  "reasons",
		ConvertedName:  "Reasons",
		Description:    `The various reasons returned by the policy engine.`,
		Exposed:        true,
		Name:           "reasons",
		Stored:         true,
		SubType:        "string",
		Type:           "list",
	},
	"Summary": {
		AllowedChoices: []string{},
		BSONFieldName:  "summary",
		ConvertedName:  "Summary",
		Description:    `The summary of the extractions.`,
		Exposed:        true,
		Name:           "summary",
		Stored:         true,
		SubType:        "extractionsummary",
		Type:           "ref",
	},
	"Time": {
		AllowedChoices: []string{},
		ConvertedName:  "Time",
		Description:    `Set the time of the message request.`,
		Exposed:        true,
		Name:           "time",
		Type:           "time",
	},
	"ToolChoice": {
		AllowedChoices: []string{},
		BSONFieldName:  "toolchoice",
		ConvertedName:  "ToolChoice",
		Description:    `Tool choice instructions for the model of a request.`,
		Exposed:        true,
		Name:           "toolChoice",
		Stored:         true,
		SubType:        "toolchoice",
		Type:           "ref",
	},
	"Tools": {
		AllowedChoices: []string{},
		BSONFieldName:  "tools",
		ConvertedName:  "Tools",
		Description:    `The various tools used by the request.`,
		Exposed:        true,
		Name:           "tools",
		Stored:         true,
		SubType:        "tool",
		Type:           "refMap",
	},
	"Trace": {
		AllowedChoices: []string{},
		BSONFieldName:  "trace",
		ConvertedName:  "Trace",
		Description:    `References to the trace of the request.`,
		Exposed:        true,
		Name:           "trace",
		Stored:         true,
		SubType:        "traceref",
		Type:           "ref",
	},
	"Type": {
		AllowedChoices: []string{"Input", "Output"},
		BSONFieldName:  "type",
		ConvertedName:  "Type",
		Description:    `The type of text.`,
		Exposed:        true,
		Name:           "type",
		Stored:         true,
		Type:           "enum",
	},
}

// ProxyRoundtripLowerCaseAttributesMap represents the map of attribute for ProxyRoundtrip.
var ProxyRoundtripLowerCaseAttributesMap = map[string]elemental.AttributeSpecification{
	"id": {
		AllowedChoices: []string{},
		Autogenerated:  true,
		BSONFieldName:  "_id",
		ConvertedName:  "ID",
		Description:    `ID is the identifier of the object.`,
		Exposed:        true,
		Filterable:     true,
		Identifier:     true,
		Name:           "ID",
		Orderable:      true,
		ReadOnly:       true,
		Stored:         true,
		Type:           "string",
	},
	"alerts": {
		AllowedChoices: []string{},
		BSONFieldName:  "alerts",
		ConvertedName:  "Alerts",
		Description:    `List of alerts that got raised during the policy resolution.`,
		Exposed:        true,
		Name:           "alerts",
		Stored:         true,
		SubType:        "alertevent",
		Type:           "refList",
	},
	"annotations": {
		AllowedChoices: []string{},
		BSONFieldName:  "annotations",
		ConvertedName:  "Annotations",
		Description:    `Annotations attached to the log.`,
		Exposed:        true,
		Name:           "annotations",
		Stored:         true,
		SubType:        "map[string]string",
		Type:           "external",
	},
	"client": {
		AllowedChoices: []string{},
		BSONFieldName:  "client",
		ConvertedName:  "Client",
		Description:    `The client used to send the request.`,
		Exposed:        true,
		Name:           "client",
		Stored:         true,
		Type:           "string",
	},
	"clientversion": {
		AllowedChoices: []string{},
		BSONFieldName:  "clientversion",
		ConvertedName:  "ClientVersion",
		Description:    `The version of the client used to send the request.`,
		Exposed:        true,
		Name:           "clientVersion",
		Stored:         true,
		Type:           "string",
	},
	"decision": {
		AllowedChoices: []string{"Deny", "Allow", "Ask", "Bypassed", "ForbiddenUser", "Skipped"},
		BSONFieldName:  "decision",
		ConvertedName:  "Decision",
		Description:    `Tell what was the decision about the data.`,
		Exposed:        true,
		Name:           "decision",
		Stored:         true,
		Type:           "enum",
	},
	"destination": {
		AllowedChoices: []string{},
		BSONFieldName:  "destination",
		ConvertedName:  "Destination",
		Description:    `Captures all details of the destination of the request.`,
		Exposed:        true,
		Name:           "destination",
		Stored:         true,
		SubType:        "destination",
		Type:           "ref",
	},
	"encryptionegress": {
		AllowedChoices: []string{},
		BSONFieldName:  "encryptionegress",
		ConvertedName:  "EncryptionEgress",
		Description:    `The encryption details of the connection from the proxy to the origin server.`,
		Exposed:        true,
		Name:           "encryptionEgress",
		Stored:         true,
		SubType:        "tlsstate",
		Type:           "ref",
	},
	"encryptioningress": {
		AllowedChoices: []string{},
		BSONFieldName:  "encryptioningress",
		ConvertedName:  "EncryptionIngress",
		Description:    `The encryption details of the connection from the client to the proxy.`,
		Exposed:        true,
		Name:           "encryptionIngress",
		Stored:         true,
		SubType:        "tlsstate",
		Type:           "ref",
	},
	"extractions": {
		AllowedChoices: []string{},
		BSONFieldName:  "extractions",
		ConvertedName:  "Extractions",
		Description:    `The extractions to log.`,
		Exposed:        true,
		Name:           "extractions",
		Stored:         true,
		SubType:        "extraction",
		Type:           "refList",
	},
	"hash": {
		AllowedChoices: []string{},
		BSONFieldName:  "hash",
		ConvertedName:  "Hash",
		Description:    `The hash of the input.`,
		Exposed:        true,
		Name:           "hash",
		Stored:         true,
		Type:           "string",
	},
	"importhash": {
		AllowedChoices: []string{},
		Autogenerated:  true,
		BSONFieldName:  "importhash",
		ConvertedName:  "ImportHash",
		CreationOnly:   true,
		Description:    `The hash of the structure used to compare with new import version.`,
		Exposed:        true,
		Getter:         true,
		Name:           "importHash",
		Setter:         true,
		Stored:         true,
		Type:           "string",
	},
	"importlabel": {
		AllowedChoices: []string{},
		BSONFieldName:  "importlabel",
		ConvertedName:  "ImportLabel",
		CreationOnly:   true,
		Description: `The user-defined import label that allows the system to group resources from the
same import operation.`,
		Exposed: true,
		Getter:  true,
		Name:    "importLabel",
		Setter:  true,
		Stored:  true,
		Type:    "string",
	},
	"latency": {
		AllowedChoices: []string{},
		BSONFieldName:  "latency",
		ConvertedName:  "Latency",
		Description:    `Information about latency of various stage of request and response.`,
		Exposed:        true,
		Name:           "latency",
		Stored:         true,
		SubType:        "latency",
		Type:           "ref",
	},
	"mcpmessage": {
		AllowedChoices: []string{},
		BSONFieldName:  "mcpmessage",
		ConvertedName:  "McpMessage",
		Description:    `If this is an MCP message, then the MCP message details will be set here.`,
		Exposed:        true,
		Name:           "mcpMessage",
		Stored:         true,
		SubType:        "mcpmessage",
		Type:           "ref",
	},
	"model": {
		AllowedChoices: []string{},
		BSONFieldName:  "model",
		ConvertedName:  "Model",
		Description:    `The model used by the request.`,
		Exposed:        true,
		Name:           "model",
		Stored:         true,
		Type:           "string",
	},
	"namespace": {
		AllowedChoices: []string{},
		Autogenerated:  true,
		BSONFieldName:  "namespace",
		ConvertedName:  "Namespace",
		Description:    `The namespace of the object.`,
		Exposed:        true,
		Getter:         true,
		Name:           "namespace",
		Orderable:      true,
		ReadOnly:       true,
		Setter:         true,
		Stored:         true,
		Type:           "string",
	},
	"offband": {
		AllowedChoices: []string{},
		BSONFieldName:  "offband",
		ConvertedName:  "Offband",
		Description: `If true, the analysis ran offband. That means that we extracted the data
from the user request, assigned team and verified access permissions, but
then we forwarded the request as is to the provider untouched
immediately, while running the analysis and policies in the background,
reporting what we would have done.`,
		Exposed: true,
		Name:    "offband",
		Stored:  true,
		Type:    "boolean",
	},
	"permissive": {
		AllowedChoices: []string{},
		BSONFieldName:  "permissive",
		ConvertedName:  "Permissive",
		Description: `If true, the policy has been applied in permissive mode.  That means that
we extracted the data from the user request, assigned team, verified
access permissions, run analysis, apply content policies and reported what
we would have done, but ultimately let the request go to the provider
untouched.`,
		Exposed: true,
		Name:    "permissive",
		Stored:  true,
		Type:    "boolean",
	},
	"pipelinename": {
		AllowedChoices: []string{},
		BSONFieldName:  "pipelinename",
		ConvertedName:  "PipelineName",
		Description:    `The name of the particular pipeline that extracted the text.`,
		Exposed:        true,
		Name:           "pipelineName",
		Stored:         true,
		Type:           "string",
	},
	"policyrefs": {
		AllowedChoices: []string{},
		BSONFieldName:  "policyrefs",
		ConvertedName:  "PolicyRefs",
		Description:    `List of references to the policies used to make this roundtrip.`,
		Exposed:        true,
		Name:           "policyRefs",
		Stored:         true,
		SubType:        "policyref",
		Type:           "refList",
	},
	"principal": {
		AllowedChoices: []string{},
		BSONFieldName:  "principal",
		ConvertedName:  "Principal",
		Description:    `The principal of the object.`,
		Exposed:        true,
		Name:           "principal",
		Required:       true,
		Stored:         true,
		SubType:        "principal",
		Type:           "ref",
	},
	"provider": {
		AllowedChoices: []string{},
		BSONFieldName:  "provider",
		ConvertedName:  "Provider",
		Description:    `The provider to use.`,
		Exposed:        true,
		Name:           "provider",
		Stored:         true,
		Type:           "string",
	},
	"proxyfunction": {
		AllowedChoices: []string{"ForwardProxy", "ReverseProxy"},
		BSONFieldName:  "proxyfunction",
		ConvertedName:  "ProxyFunction",
		DefaultValue:   ProxyRoundtripProxyFunctionForwardProxy,
		Description: `Denotes the function of this proxy in the chain of servers. By default the apex
always sits on the egress side between a client or application and the origin
server in which case the apex acts as a forwarding proxy. However, in the case
of applications the proxy can also be located before the application as an
ingress provider in which case the apex acts as a reverse proxy.`,
		Exposed: true,
		Name:    "proxyFunction",
		Stored:  true,
		Type:    "enum",
	},
	"reasons": {
		AllowedChoices: []string{},
		BSONFieldName:  "reasons",
		ConvertedName:  "Reasons",
		Description:    `The various reasons returned by the policy engine.`,
		Exposed:        true,
		Name:           "reasons",
		Stored:         true,
		SubType:        "string",
		Type:           "list",
	},
	"summary": {
		AllowedChoices: []string{},
		BSONFieldName:  "summary",
		ConvertedName:  "Summary",
		Description:    `The summary of the extractions.`,
		Exposed:        true,
		Name:           "summary",
		Stored:         true,
		SubType:        "extractionsummary",
		Type:           "ref",
	},
	"time": {
		AllowedChoices: []string{},
		ConvertedName:  "Time",
		Description:    `Set the time of the message request.`,
		Exposed:        true,
		Name:           "time",
		Type:           "time",
	},
	"toolchoice": {
		AllowedChoices: []string{},
		BSONFieldName:  "toolchoice",
		ConvertedName:  "ToolChoice",
		Description:    `Tool choice instructions for the model of a request.`,
		Exposed:        true,
		Name:           "toolChoice",
		Stored:         true,
		SubType:        "toolchoice",
		Type:           "ref",
	},
	"tools": {
		AllowedChoices: []string{},
		BSONFieldName:  "tools",
		ConvertedName:  "Tools",
		Description:    `The various tools used by the request.`,
		Exposed:        true,
		Name:           "tools",
		Stored:         true,
		SubType:        "tool",
		Type:           "refMap",
	},
	"trace": {
		AllowedChoices: []string{},
		BSONFieldName:  "trace",
		ConvertedName:  "Trace",
		Description:    `References to the trace of the request.`,
		Exposed:        true,
		Name:           "trace",
		Stored:         true,
		SubType:        "traceref",
		Type:           "ref",
	},
	"type": {
		AllowedChoices: []string{"Input", "Output"},
		BSONFieldName:  "type",
		ConvertedName:  "Type",
		Description:    `The type of text.`,
		Exposed:        true,
		Name:           "type",
		Stored:         true,
		Type:           "enum",
	},
}

// SparseProxyRoundtripsList represents a list of SparseProxyRoundtrips
type SparseProxyRoundtripsList []*SparseProxyRoundtrip

// Identity returns the identity of the objects in the list.
func (o SparseProxyRoundtripsList) Identity() elemental.Identity {

	return ProxyRoundtripIdentity
}

// Copy returns a pointer to a copy the SparseProxyRoundtripsList.
func (o SparseProxyRoundtripsList) Copy() elemental.Identifiables {

	copy := slices.Clone(o)
	return &copy
}

// Append appends the objects to the a new copy of the SparseProxyRoundtripsList.
func (o SparseProxyRoundtripsList) Append(objects ...elemental.Identifiable) elemental.Identifiables {

	out := slices.Clone(o)
	for _, obj := range objects {
		out = append(out, obj.(*SparseProxyRoundtrip))
	}

	return out
}

// List converts the object to an elemental.IdentifiablesList.
func (o SparseProxyRoundtripsList) List() elemental.IdentifiablesList {

	out := make(elemental.IdentifiablesList, len(o))
	for i := range len(o) {
		out[i] = o[i]
	}

	return out
}

// DefaultOrder returns the default ordering fields of the content.
func (o SparseProxyRoundtripsList) DefaultOrder() []string {

	return []string{}
}

// ToPlain returns the SparseProxyRoundtripsList converted to ProxyRoundtripsList.
func (o SparseProxyRoundtripsList) ToPlain() elemental.IdentifiablesList {

	out := make(elemental.IdentifiablesList, len(o))
	for i := range len(o) {
		out[i] = o[i].ToPlain()
	}

	return out
}

// Version returns the version of the content.
func (o SparseProxyRoundtripsList) Version() int {

	return 1
}

// SparseProxyRoundtrip represents the sparse version of a proxyroundtrip.
type SparseProxyRoundtrip struct {
	// ID is the identifier of the object.
	ID *string `json:"ID,omitempty" msgpack:"ID,omitempty" bson:"-" mapstructure:"ID,omitempty"`

	// List of alerts that got raised during the policy resolution.
	Alerts *[]*AlertEvent `json:"alerts,omitempty" msgpack:"alerts,omitempty" bson:"alerts,omitempty" mapstructure:"alerts,omitempty"`

	// Annotations attached to the log.
	Annotations *map[string]string `json:"annotations,omitempty" msgpack:"annotations,omitempty" bson:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// The client used to send the request.
	Client *string `json:"client,omitempty" msgpack:"client,omitempty" bson:"client,omitempty" mapstructure:"client,omitempty"`

	// The version of the client used to send the request.
	ClientVersion *string `json:"clientVersion,omitempty" msgpack:"clientVersion,omitempty" bson:"clientversion,omitempty" mapstructure:"clientVersion,omitempty"`

	// Tell what was the decision about the data.
	Decision *ProxyRoundtripDecisionValue `json:"decision,omitempty" msgpack:"decision,omitempty" bson:"decision,omitempty" mapstructure:"decision,omitempty"`

	// Captures all details of the destination of the request.
	Destination *Destination `json:"destination,omitempty" msgpack:"destination,omitempty" bson:"destination,omitempty" mapstructure:"destination,omitempty"`

	// The encryption details of the connection from the proxy to the origin server.
	EncryptionEgress *TLSState `json:"encryptionEgress,omitempty" msgpack:"encryptionEgress,omitempty" bson:"encryptionegress,omitempty" mapstructure:"encryptionEgress,omitempty"`

	// The encryption details of the connection from the client to the proxy.
	EncryptionIngress *TLSState `json:"encryptionIngress,omitempty" msgpack:"encryptionIngress,omitempty" bson:"encryptioningress,omitempty" mapstructure:"encryptionIngress,omitempty"`

	// The extractions to log.
	Extractions *[]*Extraction `json:"extractions,omitempty" msgpack:"extractions,omitempty" bson:"extractions,omitempty" mapstructure:"extractions,omitempty"`

	// The hash of the input.
	Hash *string `json:"hash,omitempty" msgpack:"hash,omitempty" bson:"hash,omitempty" mapstructure:"hash,omitempty"`

	// The hash of the structure used to compare with new import version.
	ImportHash *string `json:"importHash,omitempty" msgpack:"importHash,omitempty" bson:"importhash,omitempty" mapstructure:"importHash,omitempty"`

	// The user-defined import label that allows the system to group resources from the
	// same import operation.
	ImportLabel *string `json:"importLabel,omitempty" msgpack:"importLabel,omitempty" bson:"importlabel,omitempty" mapstructure:"importLabel,omitempty"`

	// Information about latency of various stage of request and response.
	Latency *Latency `json:"latency,omitempty" msgpack:"latency,omitempty" bson:"latency,omitempty" mapstructure:"latency,omitempty"`

	// If this is an MCP message, then the MCP message details will be set here.
	McpMessage *MCPMessage `json:"mcpMessage,omitempty" msgpack:"mcpMessage,omitempty" bson:"mcpmessage,omitempty" mapstructure:"mcpMessage,omitempty"`

	// The model used by the request.
	Model *string `json:"model,omitempty" msgpack:"model,omitempty" bson:"model,omitempty" mapstructure:"model,omitempty"`

	// The namespace of the object.
	Namespace *string `json:"namespace,omitempty" msgpack:"namespace,omitempty" bson:"namespace,omitempty" mapstructure:"namespace,omitempty"`

	// If true, the analysis ran offband. That means that we extracted the data
	// from the user request, assigned team and verified access permissions, but
	// then we forwarded the request as is to the provider untouched
	// immediately, while running the analysis and policies in the background,
	// reporting what we would have done.
	Offband *bool `json:"offband,omitempty" msgpack:"offband,omitempty" bson:"offband,omitempty" mapstructure:"offband,omitempty"`

	// If true, the policy has been applied in permissive mode.  That means that
	// we extracted the data from the user request, assigned team, verified
	// access permissions, run analysis, apply content policies and reported what
	// we would have done, but ultimately let the request go to the provider
	// untouched.
	Permissive *bool `json:"permissive,omitempty" msgpack:"permissive,omitempty" bson:"permissive,omitempty" mapstructure:"permissive,omitempty"`

	// The name of the particular pipeline that extracted the text.
	PipelineName *string `json:"pipelineName,omitempty" msgpack:"pipelineName,omitempty" bson:"pipelinename,omitempty" mapstructure:"pipelineName,omitempty"`

	// List of references to the policies used to make this roundtrip.
	PolicyRefs *PolicyRefsList `json:"policyRefs,omitempty" msgpack:"policyRefs,omitempty" bson:"policyrefs,omitempty" mapstructure:"policyRefs,omitempty"`

	// The principal of the object.
	Principal *Principal `json:"principal,omitempty" msgpack:"principal,omitempty" bson:"principal,omitempty" mapstructure:"principal,omitempty"`

	// The provider to use.
	Provider *string `json:"provider,omitempty" msgpack:"provider,omitempty" bson:"provider,omitempty" mapstructure:"provider,omitempty"`

	// Denotes the function of this proxy in the chain of servers. By default the apex
	// always sits on the egress side between a client or application and the origin
	// server in which case the apex acts as a forwarding proxy. However, in the case
	// of applications the proxy can also be located before the application as an
	// ingress provider in which case the apex acts as a reverse proxy.
	ProxyFunction *ProxyRoundtripProxyFunctionValue `json:"proxyFunction,omitempty" msgpack:"proxyFunction,omitempty" bson:"proxyfunction,omitempty" mapstructure:"proxyFunction,omitempty"`

	// The various reasons returned by the policy engine.
	Reasons *[]string `json:"reasons,omitempty" msgpack:"reasons,omitempty" bson:"reasons,omitempty" mapstructure:"reasons,omitempty"`

	// The summary of the extractions.
	Summary *ExtractionSummary `json:"summary,omitempty" msgpack:"summary,omitempty" bson:"summary,omitempty" mapstructure:"summary,omitempty"`

	// Set the time of the message request.
	Time *time.Time `json:"time,omitempty" msgpack:"time,omitempty" bson:"-" mapstructure:"time,omitempty"`

	// Tool choice instructions for the model of a request.
	ToolChoice *ToolChoice `json:"toolChoice,omitempty" msgpack:"toolChoice,omitempty" bson:"toolchoice,omitempty" mapstructure:"toolChoice,omitempty"`

	// The various tools used by the request.
	Tools *map[string]*Tool `json:"tools,omitempty" msgpack:"tools,omitempty" bson:"tools,omitempty" mapstructure:"tools,omitempty"`

	// References to the trace of the request.
	Trace *TraceRef `json:"trace,omitempty" msgpack:"trace,omitempty" bson:"trace,omitempty" mapstructure:"trace,omitempty"`

	// The type of text.
	Type *ProxyRoundtripTypeValue `json:"type,omitempty" msgpack:"type,omitempty" bson:"type,omitempty" mapstructure:"type,omitempty"`

	ModelVersion int `json:"-" msgpack:"-" bson:"_modelversion"`
}

// NewSparseProxyRoundtrip returns a new  SparseProxyRoundtrip.
func NewSparseProxyRoundtrip() *SparseProxyRoundtrip {
	return &SparseProxyRoundtrip{}
}

// Identity returns the Identity of the sparse object.
func (o *SparseProxyRoundtrip) Identity() elemental.Identity {

	return ProxyRoundtripIdentity
}

// Identifier returns the value of the sparse object's unique identifier.
func (o *SparseProxyRoundtrip) Identifier() string {

	if o.ID == nil {
		return ""
	}
	return *o.ID
}

// SetIdentifier sets the value of the sparse object's unique identifier.
func (o *SparseProxyRoundtrip) SetIdentifier(id string) {

	if id != "" {
		o.ID = &id
	} else {
		o.ID = nil
	}
}

// GetBSON implements the bson marshaling interface.
// This is used to transparently convert ID to MongoDBID as ObectID.
func (o *SparseProxyRoundtrip) GetBSON() (any, error) {

	if o == nil {
		return nil, nil
	}

	s := &mongoAttributesSparseProxyRoundtrip{}

	if o.ID != nil {
		s.ID = bson.ObjectIdHex(*o.ID)
	}
	if o.Alerts != nil {
		s.Alerts = o.Alerts
	}
	if o.Annotations != nil {
		s.Annotations = o.Annotations
	}
	if o.Client != nil {
		s.Client = o.Client
	}
	if o.ClientVersion != nil {
		s.ClientVersion = o.ClientVersion
	}
	if o.Decision != nil {
		s.Decision = o.Decision
	}
	if o.Destination != nil {
		s.Destination = o.Destination
	}
	if o.EncryptionEgress != nil {
		s.EncryptionEgress = o.EncryptionEgress
	}
	if o.EncryptionIngress != nil {
		s.EncryptionIngress = o.EncryptionIngress
	}
	if o.Extractions != nil {
		s.Extractions = o.Extractions
	}
	if o.Hash != nil {
		s.Hash = o.Hash
	}
	if o.ImportHash != nil {
		s.ImportHash = o.ImportHash
	}
	if o.ImportLabel != nil {
		s.ImportLabel = o.ImportLabel
	}
	if o.Latency != nil {
		s.Latency = o.Latency
	}
	if o.McpMessage != nil {
		s.McpMessage = o.McpMessage
	}
	if o.Model != nil {
		s.Model = o.Model
	}
	if o.Namespace != nil {
		s.Namespace = o.Namespace
	}
	if o.Offband != nil {
		s.Offband = o.Offband
	}
	if o.Permissive != nil {
		s.Permissive = o.Permissive
	}
	if o.PipelineName != nil {
		s.PipelineName = o.PipelineName
	}
	if o.PolicyRefs != nil {
		s.PolicyRefs = o.PolicyRefs
	}
	if o.Principal != nil {
		s.Principal = o.Principal
	}
	if o.Provider != nil {
		s.Provider = o.Provider
	}
	if o.ProxyFunction != nil {
		s.ProxyFunction = o.ProxyFunction
	}
	if o.Reasons != nil {
		s.Reasons = o.Reasons
	}
	if o.Summary != nil {
		s.Summary = o.Summary
	}
	if o.ToolChoice != nil {
		s.ToolChoice = o.ToolChoice
	}
	if o.Tools != nil {
		s.Tools = o.Tools
	}
	if o.Trace != nil {
		s.Trace = o.Trace
	}
	if o.Type != nil {
		s.Type = o.Type
	}

	return s, nil
}

// SetBSON implements the bson marshaling interface.
// This is used to transparently convert ID to MongoDBID as ObectID.
func (o *SparseProxyRoundtrip) SetBSON(raw bson.Raw) error {

	if o == nil {
		return nil
	}

	s := &mongoAttributesSparseProxyRoundtrip{}
	if err := raw.Unmarshal(s); err != nil {
		return err
	}

	id := s.ID.Hex()
	o.ID = &id
	if s.Alerts != nil {
		o.Alerts = s.Alerts
	}
	if s.Annotations != nil {
		o.Annotations = s.Annotations
	}
	if s.Client != nil {
		o.Client = s.Client
	}
	if s.ClientVersion != nil {
		o.ClientVersion = s.ClientVersion
	}
	if s.Decision != nil {
		o.Decision = s.Decision
	}
	if s.Destination != nil {
		o.Destination = s.Destination
	}
	if s.EncryptionEgress != nil {
		o.EncryptionEgress = s.EncryptionEgress
	}
	if s.EncryptionIngress != nil {
		o.EncryptionIngress = s.EncryptionIngress
	}
	if s.Extractions != nil {
		o.Extractions = s.Extractions
	}
	if s.Hash != nil {
		o.Hash = s.Hash
	}
	if s.ImportHash != nil {
		o.ImportHash = s.ImportHash
	}
	if s.ImportLabel != nil {
		o.ImportLabel = s.ImportLabel
	}
	if s.Latency != nil {
		o.Latency = s.Latency
	}
	if s.McpMessage != nil {
		o.McpMessage = s.McpMessage
	}
	if s.Model != nil {
		o.Model = s.Model
	}
	if s.Namespace != nil {
		o.Namespace = s.Namespace
	}
	if s.Offband != nil {
		o.Offband = s.Offband
	}
	if s.Permissive != nil {
		o.Permissive = s.Permissive
	}
	if s.PipelineName != nil {
		o.PipelineName = s.PipelineName
	}
	if s.PolicyRefs != nil {
		o.PolicyRefs = s.PolicyRefs
	}
	if s.Principal != nil {
		o.Principal = s.Principal
	}
	if s.Provider != nil {
		o.Provider = s.Provider
	}
	if s.ProxyFunction != nil {
		o.ProxyFunction = s.ProxyFunction
	}
	if s.Reasons != nil {
		o.Reasons = s.Reasons
	}
	if s.Summary != nil {
		o.Summary = s.Summary
	}
	if s.ToolChoice != nil {
		o.ToolChoice = s.ToolChoice
	}
	if s.Tools != nil {
		o.Tools = s.Tools
	}
	if s.Trace != nil {
		o.Trace = s.Trace
	}
	if s.Type != nil {
		o.Type = s.Type
	}

	return nil
}

// Version returns the hardcoded version of the model.
func (o *SparseProxyRoundtrip) Version() int {

	return 1
}

// ToPlain returns the plain version of the sparse model.
func (o *SparseProxyRoundtrip) ToPlain() elemental.PlainIdentifiable {

	out := NewProxyRoundtrip()
	if o.ID != nil {
		out.ID = *o.ID
	}
	if o.Alerts != nil {
		out.Alerts = *o.Alerts
	}
	if o.Annotations != nil {
		out.Annotations = *o.Annotations
	}
	if o.Client != nil {
		out.Client = *o.Client
	}
	if o.ClientVersion != nil {
		out.ClientVersion = *o.ClientVersion
	}
	if o.Decision != nil {
		out.Decision = *o.Decision
	}
	if o.Destination != nil {
		out.Destination = o.Destination
	}
	if o.EncryptionEgress != nil {
		out.EncryptionEgress = o.EncryptionEgress
	}
	if o.EncryptionIngress != nil {
		out.EncryptionIngress = o.EncryptionIngress
	}
	if o.Extractions != nil {
		out.Extractions = *o.Extractions
	}
	if o.Hash != nil {
		out.Hash = *o.Hash
	}
	if o.ImportHash != nil {
		out.ImportHash = *o.ImportHash
	}
	if o.ImportLabel != nil {
		out.ImportLabel = *o.ImportLabel
	}
	if o.Latency != nil {
		out.Latency = o.Latency
	}
	if o.McpMessage != nil {
		out.McpMessage = o.McpMessage
	}
	if o.Model != nil {
		out.Model = *o.Model
	}
	if o.Namespace != nil {
		out.Namespace = *o.Namespace
	}
	if o.Offband != nil {
		out.Offband = *o.Offband
	}
	if o.Permissive != nil {
		out.Permissive = *o.Permissive
	}
	if o.PipelineName != nil {
		out.PipelineName = *o.PipelineName
	}
	if o.PolicyRefs != nil {
		out.PolicyRefs = *o.PolicyRefs
	}
	if o.Principal != nil {
		out.Principal = o.Principal
	}
	if o.Provider != nil {
		out.Provider = *o.Provider
	}
	if o.ProxyFunction != nil {
		out.ProxyFunction = *o.ProxyFunction
	}
	if o.Reasons != nil {
		out.Reasons = *o.Reasons
	}
	if o.Summary != nil {
		out.Summary = o.Summary
	}
	if o.Time != nil {
		out.Time = *o.Time
	}
	if o.ToolChoice != nil {
		out.ToolChoice = o.ToolChoice
	}
	if o.Tools != nil {
		out.Tools = *o.Tools
	}
	if o.Trace != nil {
		out.Trace = o.Trace
	}
	if o.Type != nil {
		out.Type = *o.Type
	}

	return out
}

// GetImportHash returns the ImportHash of the receiver.
func (o *SparseProxyRoundtrip) GetImportHash() (out string) {

	if o.ImportHash == nil {
		return
	}

	return *o.ImportHash
}

// SetImportHash sets the property ImportHash of the receiver using the address of the given value.
func (o *SparseProxyRoundtrip) SetImportHash(importHash string) {

	o.ImportHash = &importHash
}

// GetImportLabel returns the ImportLabel of the receiver.
func (o *SparseProxyRoundtrip) GetImportLabel() (out string) {

	if o.ImportLabel == nil {
		return
	}

	return *o.ImportLabel
}

// SetImportLabel sets the property ImportLabel of the receiver using the address of the given value.
func (o *SparseProxyRoundtrip) SetImportLabel(importLabel string) {

	o.ImportLabel = &importLabel
}

// GetNamespace returns the Namespace of the receiver.
func (o *SparseProxyRoundtrip) GetNamespace() (out string) {

	if o.Namespace == nil {
		return
	}

	return *o.Namespace
}

// SetNamespace sets the property Namespace of the receiver using the address of the given value.
func (o *SparseProxyRoundtrip) SetNamespace(namespace string) {

	o.Namespace = &namespace
}

// DeepCopy returns a deep copy if the SparseProxyRoundtrip.
func (o *SparseProxyRoundtrip) DeepCopy() *SparseProxyRoundtrip {

	if o == nil {
		return nil
	}

	out := &SparseProxyRoundtrip{}
	o.DeepCopyInto(out)

	return out
}

// DeepCopyInto copies the receiver into the given *SparseProxyRoundtrip.
func (o *SparseProxyRoundtrip) DeepCopyInto(out *SparseProxyRoundtrip) {

	target, err := copystructure.Copy(o)
	if err != nil {
		panic(fmt.Sprintf("Unable to deepcopy SparseProxyRoundtrip: %s", err))
	}

	*out = *target.(*SparseProxyRoundtrip)
}

type mongoAttributesProxyRoundtrip struct {
	ID                bson.ObjectId                    `bson:"_id,omitempty"`
	Alerts            []*AlertEvent                    `bson:"alerts,omitempty"`
	Annotations       map[string]string                `bson:"annotations,omitempty"`
	Client            string                           `bson:"client,omitempty"`
	ClientVersion     string                           `bson:"clientversion,omitempty"`
	Decision          ProxyRoundtripDecisionValue      `bson:"decision"`
	Destination       *Destination                     `bson:"destination,omitempty"`
	EncryptionEgress  *TLSState                        `bson:"encryptionegress,omitempty"`
	EncryptionIngress *TLSState                        `bson:"encryptioningress,omitempty"`
	Extractions       []*Extraction                    `bson:"extractions,omitempty"`
	Hash              string                           `bson:"hash"`
	ImportHash        string                           `bson:"importhash,omitempty"`
	ImportLabel       string                           `bson:"importlabel,omitempty"`
	Latency           *Latency                         `bson:"latency,omitempty"`
	McpMessage        *MCPMessage                      `bson:"mcpmessage,omitempty"`
	Model             string                           `bson:"model"`
	Namespace         string                           `bson:"namespace,omitempty"`
	Offband           bool                             `bson:"offband"`
	Permissive        bool                             `bson:"permissive"`
	PipelineName      string                           `bson:"pipelinename"`
	PolicyRefs        PolicyRefsList                   `bson:"policyrefs"`
	Principal         *Principal                       `bson:"principal"`
	Provider          string                           `bson:"provider"`
	ProxyFunction     ProxyRoundtripProxyFunctionValue `bson:"proxyfunction,omitempty"`
	Reasons           []string                         `bson:"reasons,omitempty"`
	Summary           *ExtractionSummary               `bson:"summary,omitempty"`
	ToolChoice        *ToolChoice                      `bson:"toolchoice,omitempty"`
	Tools             map[string]*Tool                 `bson:"tools,omitempty"`
	Trace             *TraceRef                        `bson:"trace,omitempty"`
	Type              ProxyRoundtripTypeValue          `bson:"type"`
}
type mongoAttributesSparseProxyRoundtrip struct {
	ID                bson.ObjectId                     `bson:"_id,omitempty"`
	Alerts            *[]*AlertEvent                    `bson:"alerts,omitempty"`
	Annotations       *map[string]string                `bson:"annotations,omitempty"`
	Client            *string                           `bson:"client,omitempty"`
	ClientVersion     *string                           `bson:"clientversion,omitempty"`
	Decision          *ProxyRoundtripDecisionValue      `bson:"decision,omitempty"`
	Destination       *Destination                      `bson:"destination,omitempty"`
	EncryptionEgress  *TLSState                         `bson:"encryptionegress,omitempty"`
	EncryptionIngress *TLSState                         `bson:"encryptioningress,omitempty"`
	Extractions       *[]*Extraction                    `bson:"extractions,omitempty"`
	Hash              *string                           `bson:"hash,omitempty"`
	ImportHash        *string                           `bson:"importhash,omitempty"`
	ImportLabel       *string                           `bson:"importlabel,omitempty"`
	Latency           *Latency                          `bson:"latency,omitempty"`
	McpMessage        *MCPMessage                       `bson:"mcpmessage,omitempty"`
	Model             *string                           `bson:"model,omitempty"`
	Namespace         *string                           `bson:"namespace,omitempty"`
	Offband           *bool                             `bson:"offband,omitempty"`
	Permissive        *bool                             `bson:"permissive,omitempty"`
	PipelineName      *string                           `bson:"pipelinename,omitempty"`
	PolicyRefs        *PolicyRefsList                   `bson:"policyrefs,omitempty"`
	Principal         *Principal                        `bson:"principal,omitempty"`
	Provider          *string                           `bson:"provider,omitempty"`
	ProxyFunction     *ProxyRoundtripProxyFunctionValue `bson:"proxyfunction,omitempty"`
	Reasons           *[]string                         `bson:"reasons,omitempty"`
	Summary           *ExtractionSummary                `bson:"summary,omitempty"`
	ToolChoice        *ToolChoice                       `bson:"toolchoice,omitempty"`
	Tools             *map[string]*Tool                 `bson:"tools,omitempty"`
	Trace             *TraceRef                         `bson:"trace,omitempty"`
	Type              *ProxyRoundtripTypeValue          `bson:"type,omitempty"`
}
