// Code generated by elegen. DO NOT EDIT.
// Source: go.acuvity.ai/elemental (templates/model.gotpl)

package api

import (
	"fmt"

	"github.com/globalsign/mgo/bson"
	"github.com/mitchellh/copystructure"
	"go.acuvity.ai/elemental"
)

// IngressProviderConfigListenTLSValue represents the possible values for attribute "listenTLS".
type IngressProviderConfigListenTLSValue string

const (
	// IngressProviderConfigListenTLSAuto represents the value Auto.
	IngressProviderConfigListenTLSAuto IngressProviderConfigListenTLSValue = "Auto"

	// IngressProviderConfigListenTLSDisabled represents the value Disabled.
	IngressProviderConfigListenTLSDisabled IngressProviderConfigListenTLSValue = "Disabled"

	// IngressProviderConfigListenTLSEnabled represents the value Enabled.
	IngressProviderConfigListenTLSEnabled IngressProviderConfigListenTLSValue = "Enabled"
)

// IngressProviderConfigModeValue represents the possible values for attribute "mode".
type IngressProviderConfigModeValue string

const (
	// IngressProviderConfigModeDisabled represents the value Disabled.
	IngressProviderConfigModeDisabled IngressProviderConfigModeValue = "Disabled"

	// IngressProviderConfigModeInline represents the value Inline.
	IngressProviderConfigModeInline IngressProviderConfigModeValue = "Inline"

	// IngressProviderConfigModeMirror represents the value Mirror.
	IngressProviderConfigModeMirror IngressProviderConfigModeValue = "Mirror"
)

// IngressProviderConfigIdentity represents the Identity of the object.
var IngressProviderConfigIdentity = elemental.Identity{
	Name:     "ingressproviderconfig",
	Category: "ingressproviderconfigs",
	Package:  "lain",
	Private:  false,
}

// IngressProviderConfigsList represents a list of IngressProviderConfigs
type IngressProviderConfigsList []*IngressProviderConfig

// Identity returns the identity of the objects in the list.
func (o IngressProviderConfigsList) Identity() elemental.Identity {

	return IngressProviderConfigIdentity
}

// Copy returns a pointer to a copy the IngressProviderConfigsList.
func (o IngressProviderConfigsList) Copy() elemental.Identifiables {

	out := append(IngressProviderConfigsList{}, o...)
	return &out
}

// Append appends the objects to the a new copy of the IngressProviderConfigsList.
func (o IngressProviderConfigsList) Append(objects ...elemental.Identifiable) elemental.Identifiables {

	out := append(IngressProviderConfigsList{}, o...)
	for _, obj := range objects {
		out = append(out, obj.(*IngressProviderConfig))
	}

	return out
}

// List converts the object to an elemental.IdentifiablesList.
func (o IngressProviderConfigsList) List() elemental.IdentifiablesList {

	out := make(elemental.IdentifiablesList, len(o))
	for i := 0; i < len(o); i++ {
		out[i] = o[i]
	}

	return out
}

// DefaultOrder returns the default ordering fields of the content.
func (o IngressProviderConfigsList) DefaultOrder() []string {

	return []string{}
}

// ToSparse returns the IngressProviderConfigsList converted to SparseIngressProviderConfigsList.
// Objects in the list will only contain the given fields. No field means entire field set.
func (o IngressProviderConfigsList) ToSparse(fields ...string) elemental.Identifiables {

	out := make(SparseIngressProviderConfigsList, len(o))
	for i := 0; i < len(o); i++ {
		out[i] = o[i].ToSparse(fields...).(*SparseIngressProviderConfig)
	}

	return out
}

// Version returns the version of the content.
func (o IngressProviderConfigsList) Version() int {

	return 1
}

// IngressProviderConfig represents the model of a ingressproviderconfig
type IngressProviderConfig struct {
	// The listening port. For appcomponent configurations this is the listening port
	// that traffic will be intercepted on or mirrored from.
	ListenPort int `json:"listenPort" msgpack:"listenPort" bson:"listenport" mapstructure:"listenPort,omitempty"`

	// Should be explicitly set to enabled if the listener expects TLS connections. And
	// vice versa it should be set to disabled if the listener expects connections in
	// plaintext. By default this setting is set to auto which means that TLS
	// connections will be accepted, and proxied as new TLS connections (HTTPS), and
	// plain TCP connections will be accepted and proxied as new HTTP connections. This
	// setting is ignored in mirror mode.
	ListenTLS IngressProviderConfigListenTLSValue `json:"listenTLS" msgpack:"listenTLS" bson:"listentls" mapstructure:"listenTLS,omitempty"`

	// Optional PEM encoded X509v3 certificate to use for the listener for this
	// provider. This setting will be ignored if listenMode is not TLS or Auto or mode
	// is not Inline. However, this setting is required if listenTLSKey is set.
	ListenTLSCert string `json:"listenTLSCert,omitempty" msgpack:"listenTLSCert,omitempty" bson:"listentlscert,omitempty" mapstructure:"listenTLSCert,omitempty"`

	// Optional PEM encoded key pair to use for the listener for this provider. This
	// setting will be ignored if listenMode is not TLS or Auto or mode is not Inline.
	// However, this setting is required if listenTLSCert is set.
	ListenTLSKey string `json:"listenTLSKey,omitempty" msgpack:"listenTLSKey,omitempty" bson:"listentlskey,omitempty" mapstructure:"listenTLSKey,omitempty"`

	// The ingress datapath mode to use for network traffic arriving for this ingress
	// provider for this application component. By default this is set to disabled.
	// However, this can be changed to mirror traffic where the Apex is only providing
	// visibility with no possibility of any access or content policies to take effect.
	// Or this can be set to inline in which case all traffic to providers will be
	// redirected to the Apex which acts as a transparent proxy in this case. In this
	// mode access and content policies will take effect.
	Mode IngressProviderConfigModeValue `json:"mode" msgpack:"mode" bson:"mode" mapstructure:"mode,omitempty"`

	// The provider name. This **MUST** match the name of a provider.
	Name string `json:"name" msgpack:"name" bson:"name" mapstructure:"name,omitempty"`

	// Optional X509v3 PEM encoded certificates appended by newlines. This setting only
	// has affect if upstream connections are being dialed using TLS. You should use
	// this if your upstream server is serving a certificate which is not signed by a
	// public CA.
	UpstreamCA string `json:"upstreamCA,omitempty" msgpack:"upstreamCA,omitempty" bson:"upstreamca,omitempty" mapstructure:"upstreamCA,omitempty"`

	ModelVersion int `json:"-" msgpack:"-" bson:"_modelversion"`
}

// NewIngressProviderConfig returns a new *IngressProviderConfig
func NewIngressProviderConfig() *IngressProviderConfig {

	return &IngressProviderConfig{
		ModelVersion: 1,
		ListenTLS:    IngressProviderConfigListenTLSAuto,
		Mode:         IngressProviderConfigModeDisabled,
		Name:         "ingress",
	}
}

// Identity returns the Identity of the object.
func (o *IngressProviderConfig) Identity() elemental.Identity {

	return IngressProviderConfigIdentity
}

// Identifier returns the value of the object's unique identifier.
func (o *IngressProviderConfig) Identifier() string {

	return ""
}

// SetIdentifier sets the value of the object's unique identifier.
func (o *IngressProviderConfig) SetIdentifier(id string) {

}

// GetBSON implements the bson marshaling interface.
// This is used to transparently convert ID to MongoDBID as ObectID.
func (o *IngressProviderConfig) GetBSON() (any, error) {

	if o == nil {
		return nil, nil
	}

	s := &mongoAttributesIngressProviderConfig{}

	s.ListenPort = o.ListenPort
	s.ListenTLS = o.ListenTLS
	s.ListenTLSCert = o.ListenTLSCert
	s.ListenTLSKey = o.ListenTLSKey
	s.Mode = o.Mode
	s.Name = o.Name
	s.UpstreamCA = o.UpstreamCA

	return s, nil
}

// SetBSON implements the bson marshaling interface.
// This is used to transparently convert ID to MongoDBID as ObectID.
func (o *IngressProviderConfig) SetBSON(raw bson.Raw) error {

	if o == nil {
		return nil
	}

	s := &mongoAttributesIngressProviderConfig{}
	if err := raw.Unmarshal(s); err != nil {
		return err
	}

	o.ListenPort = s.ListenPort
	o.ListenTLS = s.ListenTLS
	o.ListenTLSCert = s.ListenTLSCert
	o.ListenTLSKey = s.ListenTLSKey
	o.Mode = s.Mode
	o.Name = s.Name
	o.UpstreamCA = s.UpstreamCA

	return nil
}

// Version returns the hardcoded version of the model.
func (o *IngressProviderConfig) Version() int {

	return 1
}

// BleveType implements the bleve.Classifier Interface.
func (o *IngressProviderConfig) BleveType() string {

	return "ingressproviderconfig"
}

// DefaultOrder returns the list of default ordering fields.
func (o *IngressProviderConfig) DefaultOrder() []string {

	return []string{}
}

// Doc returns the documentation for the object
func (o *IngressProviderConfig) Doc() string {

	return `Represents the configuration if an apex is to act as an ingress for a provider.`
}

func (o *IngressProviderConfig) String() string {

	return fmt.Sprintf("<%s:%s>", o.Identity().Name, o.Identifier())
}

// ToSparse returns the sparse version of the model.
// The returned object will only contain the given fields. No field means entire field set.
func (o *IngressProviderConfig) ToSparse(fields ...string) elemental.SparseIdentifiable {

	if len(fields) == 0 {
		// nolint: goimports
		return &SparseIngressProviderConfig{
			ListenPort:    &o.ListenPort,
			ListenTLS:     &o.ListenTLS,
			ListenTLSCert: &o.ListenTLSCert,
			ListenTLSKey:  &o.ListenTLSKey,
			Mode:          &o.Mode,
			Name:          &o.Name,
			UpstreamCA:    &o.UpstreamCA,
		}
	}

	sp := &SparseIngressProviderConfig{}
	for _, f := range fields {
		switch f {
		case "listenPort":
			sp.ListenPort = &(o.ListenPort)
		case "listenTLS":
			sp.ListenTLS = &(o.ListenTLS)
		case "listenTLSCert":
			sp.ListenTLSCert = &(o.ListenTLSCert)
		case "listenTLSKey":
			sp.ListenTLSKey = &(o.ListenTLSKey)
		case "mode":
			sp.Mode = &(o.Mode)
		case "name":
			sp.Name = &(o.Name)
		case "upstreamCA":
			sp.UpstreamCA = &(o.UpstreamCA)
		}
	}

	return sp
}

// Patch apply the non nil value of a *SparseIngressProviderConfig to the object.
func (o *IngressProviderConfig) Patch(sparse elemental.SparseIdentifiable) {
	if !sparse.Identity().IsEqual(o.Identity()) {
		panic("cannot patch from a parse with different identity")
	}

	so := sparse.(*SparseIngressProviderConfig)
	if so.ListenPort != nil {
		o.ListenPort = *so.ListenPort
	}
	if so.ListenTLS != nil {
		o.ListenTLS = *so.ListenTLS
	}
	if so.ListenTLSCert != nil {
		o.ListenTLSCert = *so.ListenTLSCert
	}
	if so.ListenTLSKey != nil {
		o.ListenTLSKey = *so.ListenTLSKey
	}
	if so.Mode != nil {
		o.Mode = *so.Mode
	}
	if so.Name != nil {
		o.Name = *so.Name
	}
	if so.UpstreamCA != nil {
		o.UpstreamCA = *so.UpstreamCA
	}
}

// DeepCopy returns a deep copy if the IngressProviderConfig.
func (o *IngressProviderConfig) DeepCopy() *IngressProviderConfig {

	if o == nil {
		return nil
	}

	out := &IngressProviderConfig{}
	o.DeepCopyInto(out)

	return out
}

// DeepCopyInto copies the receiver into the given *IngressProviderConfig.
func (o *IngressProviderConfig) DeepCopyInto(out *IngressProviderConfig) {

	target, err := copystructure.Copy(o)
	if err != nil {
		panic(fmt.Sprintf("Unable to deepcopy IngressProviderConfig: %s", err))
	}

	*out = *target.(*IngressProviderConfig)
}

// Validate valides the current information stored into the structure.
func (o *IngressProviderConfig) Validate() error {

	errors := elemental.Errors{}
	requiredErrors := elemental.Errors{}

	if err := elemental.ValidateRequiredInt("listenPort", o.ListenPort); err != nil {
		requiredErrors = requiredErrors.Append(err)
	}

	if err := elemental.ValidateMaximumInt("listenPort", o.ListenPort, int(65535), false); err != nil {
		errors = errors.Append(err)
	}

	if err := elemental.ValidateMinimumInt("listenPort", o.ListenPort, int(1), false); err != nil {
		errors = errors.Append(err)
	}

	if err := elemental.ValidateStringInList("listenTLS", string(o.ListenTLS), []string{"Auto", "Enabled", "Disabled"}, false); err != nil {
		errors = errors.Append(err)
	}

	if err := ValidatePEM("listenTLSCert", o.ListenTLSCert); err != nil {
		errors = errors.Append(err)
	}

	if err := ValidatePEM("listenTLSKey", o.ListenTLSKey); err != nil {
		errors = errors.Append(err)
	}

	if err := elemental.ValidateStringInList("mode", string(o.Mode), []string{"Disabled", "Mirror", "Inline"}, false); err != nil {
		errors = errors.Append(err)
	}

	if err := elemental.ValidateRequiredString("name", o.Name); err != nil {
		requiredErrors = requiredErrors.Append(err)
	}

	if err := ValidatePEM("upstreamCA", o.UpstreamCA); err != nil {
		errors = errors.Append(err)
	}

	if len(requiredErrors) > 0 {
		return requiredErrors
	}

	if len(errors) > 0 {
		return errors
	}

	return nil
}

// SpecificationForAttribute returns the AttributeSpecification for the given attribute name key.
func (*IngressProviderConfig) SpecificationForAttribute(name string) elemental.AttributeSpecification {

	if v, ok := IngressProviderConfigAttributesMap[name]; ok {
		return v
	}

	// We could not find it, so let's check on the lower case indexed spec map
	return IngressProviderConfigLowerCaseAttributesMap[name]
}

// AttributeSpecifications returns the full attribute specifications map.
func (*IngressProviderConfig) AttributeSpecifications() map[string]elemental.AttributeSpecification {

	return IngressProviderConfigAttributesMap
}

// ValueForAttribute returns the value for the given attribute.
// This is a very advanced function that you should not need but in some
// very specific use cases.
func (o *IngressProviderConfig) ValueForAttribute(name string) any {

	switch name {
	case "listenPort":
		return o.ListenPort
	case "listenTLS":
		return o.ListenTLS
	case "listenTLSCert":
		return o.ListenTLSCert
	case "listenTLSKey":
		return o.ListenTLSKey
	case "mode":
		return o.Mode
	case "name":
		return o.Name
	case "upstreamCA":
		return o.UpstreamCA
	}

	return nil
}

// IngressProviderConfigAttributesMap represents the map of attribute for IngressProviderConfig.
var IngressProviderConfigAttributesMap = map[string]elemental.AttributeSpecification{
	"ListenPort": {
		AllowedChoices: []string{},
		BSONFieldName:  "listenport",
		ConvertedName:  "ListenPort",
		Description: `The listening port. For appcomponent configurations this is the listening port
that traffic will be intercepted on or mirrored from.`,
		Exposed:  true,
		MaxValue: 65535,
		MinValue: 1,
		Name:     "listenPort",
		Required: true,
		Stored:   true,
		Type:     "integer",
	},
	"ListenTLS": {
		AllowedChoices: []string{"Auto", "Enabled", "Disabled"},
		BSONFieldName:  "listentls",
		ConvertedName:  "ListenTLS",
		DefaultValue:   IngressProviderConfigListenTLSAuto,
		Description: `Should be explicitly set to enabled if the listener expects TLS connections. And
vice versa it should be set to disabled if the listener expects connections in
plaintext. By default this setting is set to auto which means that TLS
connections will be accepted, and proxied as new TLS connections (HTTPS), and
plain TCP connections will be accepted and proxied as new HTTP connections. This
setting is ignored in mirror mode.`,
		Exposed: true,
		Name:    "listenTLS",
		Stored:  true,
		Type:    "enum",
	},
	"ListenTLSCert": {
		AllowedChoices: []string{},
		BSONFieldName:  "listentlscert",
		ConvertedName:  "ListenTLSCert",
		Description: `Optional PEM encoded X509v3 certificate to use for the listener for this
provider. This setting will be ignored if listenMode is not TLS or Auto or mode
is not Inline. However, this setting is required if listenTLSKey is set.`,
		Exposed: true,
		Name:    "listenTLSCert",
		Stored:  true,
		Type:    "string",
	},
	"ListenTLSKey": {
		AllowedChoices: []string{},
		BSONFieldName:  "listentlskey",
		ConvertedName:  "ListenTLSKey",
		Description: `Optional PEM encoded key pair to use for the listener for this provider. This
setting will be ignored if listenMode is not TLS or Auto or mode is not Inline.
However, this setting is required if listenTLSCert is set.`,
		Exposed: true,
		Name:    "listenTLSKey",
		Stored:  true,
		Type:    "string",
	},
	"Mode": {
		AllowedChoices: []string{"Disabled", "Mirror", "Inline"},
		BSONFieldName:  "mode",
		ConvertedName:  "Mode",
		DefaultValue:   IngressProviderConfigModeDisabled,
		Description: `The ingress datapath mode to use for network traffic arriving for this ingress
provider for this application component. By default this is set to disabled.
However, this can be changed to mirror traffic where the Apex is only providing
visibility with no possibility of any access or content policies to take effect.
Or this can be set to inline in which case all traffic to providers will be
redirected to the Apex which acts as a transparent proxy in this case. In this
mode access and content policies will take effect.`,
		Exposed: true,
		Name:    "mode",
		Stored:  true,
		Type:    "enum",
	},
	"Name": {
		AllowedChoices: []string{},
		BSONFieldName:  "name",
		ConvertedName:  "Name",
		DefaultValue:   "ingress",
		Description:    `The provider name. This **MUST** match the name of a provider.`,
		Exposed:        true,
		Name:           "name",
		Required:       true,
		Stored:         true,
		Type:           "string",
	},
	"UpstreamCA": {
		AllowedChoices: []string{},
		BSONFieldName:  "upstreamca",
		ConvertedName:  "UpstreamCA",
		Description: `Optional X509v3 PEM encoded certificates appended by newlines. This setting only
has affect if upstream connections are being dialed using TLS. You should use
this if your upstream server is serving a certificate which is not signed by a
public CA.`,
		Exposed: true,
		Name:    "upstreamCA",
		Stored:  true,
		Type:    "string",
	},
}

// IngressProviderConfigLowerCaseAttributesMap represents the map of attribute for IngressProviderConfig.
var IngressProviderConfigLowerCaseAttributesMap = map[string]elemental.AttributeSpecification{
	"listenport": {
		AllowedChoices: []string{},
		BSONFieldName:  "listenport",
		ConvertedName:  "ListenPort",
		Description: `The listening port. For appcomponent configurations this is the listening port
that traffic will be intercepted on or mirrored from.`,
		Exposed:  true,
		MaxValue: 65535,
		MinValue: 1,
		Name:     "listenPort",
		Required: true,
		Stored:   true,
		Type:     "integer",
	},
	"listentls": {
		AllowedChoices: []string{"Auto", "Enabled", "Disabled"},
		BSONFieldName:  "listentls",
		ConvertedName:  "ListenTLS",
		DefaultValue:   IngressProviderConfigListenTLSAuto,
		Description: `Should be explicitly set to enabled if the listener expects TLS connections. And
vice versa it should be set to disabled if the listener expects connections in
plaintext. By default this setting is set to auto which means that TLS
connections will be accepted, and proxied as new TLS connections (HTTPS), and
plain TCP connections will be accepted and proxied as new HTTP connections. This
setting is ignored in mirror mode.`,
		Exposed: true,
		Name:    "listenTLS",
		Stored:  true,
		Type:    "enum",
	},
	"listentlscert": {
		AllowedChoices: []string{},
		BSONFieldName:  "listentlscert",
		ConvertedName:  "ListenTLSCert",
		Description: `Optional PEM encoded X509v3 certificate to use for the listener for this
provider. This setting will be ignored if listenMode is not TLS or Auto or mode
is not Inline. However, this setting is required if listenTLSKey is set.`,
		Exposed: true,
		Name:    "listenTLSCert",
		Stored:  true,
		Type:    "string",
	},
	"listentlskey": {
		AllowedChoices: []string{},
		BSONFieldName:  "listentlskey",
		ConvertedName:  "ListenTLSKey",
		Description: `Optional PEM encoded key pair to use for the listener for this provider. This
setting will be ignored if listenMode is not TLS or Auto or mode is not Inline.
However, this setting is required if listenTLSCert is set.`,
		Exposed: true,
		Name:    "listenTLSKey",
		Stored:  true,
		Type:    "string",
	},
	"mode": {
		AllowedChoices: []string{"Disabled", "Mirror", "Inline"},
		BSONFieldName:  "mode",
		ConvertedName:  "Mode",
		DefaultValue:   IngressProviderConfigModeDisabled,
		Description: `The ingress datapath mode to use for network traffic arriving for this ingress
provider for this application component. By default this is set to disabled.
However, this can be changed to mirror traffic where the Apex is only providing
visibility with no possibility of any access or content policies to take effect.
Or this can be set to inline in which case all traffic to providers will be
redirected to the Apex which acts as a transparent proxy in this case. In this
mode access and content policies will take effect.`,
		Exposed: true,
		Name:    "mode",
		Stored:  true,
		Type:    "enum",
	},
	"name": {
		AllowedChoices: []string{},
		BSONFieldName:  "name",
		ConvertedName:  "Name",
		DefaultValue:   "ingress",
		Description:    `The provider name. This **MUST** match the name of a provider.`,
		Exposed:        true,
		Name:           "name",
		Required:       true,
		Stored:         true,
		Type:           "string",
	},
	"upstreamca": {
		AllowedChoices: []string{},
		BSONFieldName:  "upstreamca",
		ConvertedName:  "UpstreamCA",
		Description: `Optional X509v3 PEM encoded certificates appended by newlines. This setting only
has affect if upstream connections are being dialed using TLS. You should use
this if your upstream server is serving a certificate which is not signed by a
public CA.`,
		Exposed: true,
		Name:    "upstreamCA",
		Stored:  true,
		Type:    "string",
	},
}

// SparseIngressProviderConfigsList represents a list of SparseIngressProviderConfigs
type SparseIngressProviderConfigsList []*SparseIngressProviderConfig

// Identity returns the identity of the objects in the list.
func (o SparseIngressProviderConfigsList) Identity() elemental.Identity {

	return IngressProviderConfigIdentity
}

// Copy returns a pointer to a copy the SparseIngressProviderConfigsList.
func (o SparseIngressProviderConfigsList) Copy() elemental.Identifiables {

	copy := append(SparseIngressProviderConfigsList{}, o...)
	return &copy
}

// Append appends the objects to the a new copy of the SparseIngressProviderConfigsList.
func (o SparseIngressProviderConfigsList) Append(objects ...elemental.Identifiable) elemental.Identifiables {

	out := append(SparseIngressProviderConfigsList{}, o...)
	for _, obj := range objects {
		out = append(out, obj.(*SparseIngressProviderConfig))
	}

	return out
}

// List converts the object to an elemental.IdentifiablesList.
func (o SparseIngressProviderConfigsList) List() elemental.IdentifiablesList {

	out := make(elemental.IdentifiablesList, len(o))
	for i := 0; i < len(o); i++ {
		out[i] = o[i]
	}

	return out
}

// DefaultOrder returns the default ordering fields of the content.
func (o SparseIngressProviderConfigsList) DefaultOrder() []string {

	return []string{}
}

// ToPlain returns the SparseIngressProviderConfigsList converted to IngressProviderConfigsList.
func (o SparseIngressProviderConfigsList) ToPlain() elemental.IdentifiablesList {

	out := make(elemental.IdentifiablesList, len(o))
	for i := 0; i < len(o); i++ {
		out[i] = o[i].ToPlain()
	}

	return out
}

// Version returns the version of the content.
func (o SparseIngressProviderConfigsList) Version() int {

	return 1
}

// SparseIngressProviderConfig represents the sparse version of a ingressproviderconfig.
type SparseIngressProviderConfig struct {
	// The listening port. For appcomponent configurations this is the listening port
	// that traffic will be intercepted on or mirrored from.
	ListenPort *int `json:"listenPort,omitempty" msgpack:"listenPort,omitempty" bson:"listenport,omitempty" mapstructure:"listenPort,omitempty"`

	// Should be explicitly set to enabled if the listener expects TLS connections. And
	// vice versa it should be set to disabled if the listener expects connections in
	// plaintext. By default this setting is set to auto which means that TLS
	// connections will be accepted, and proxied as new TLS connections (HTTPS), and
	// plain TCP connections will be accepted and proxied as new HTTP connections. This
	// setting is ignored in mirror mode.
	ListenTLS *IngressProviderConfigListenTLSValue `json:"listenTLS,omitempty" msgpack:"listenTLS,omitempty" bson:"listentls,omitempty" mapstructure:"listenTLS,omitempty"`

	// Optional PEM encoded X509v3 certificate to use for the listener for this
	// provider. This setting will be ignored if listenMode is not TLS or Auto or mode
	// is not Inline. However, this setting is required if listenTLSKey is set.
	ListenTLSCert *string `json:"listenTLSCert,omitempty" msgpack:"listenTLSCert,omitempty" bson:"listentlscert,omitempty" mapstructure:"listenTLSCert,omitempty"`

	// Optional PEM encoded key pair to use for the listener for this provider. This
	// setting will be ignored if listenMode is not TLS or Auto or mode is not Inline.
	// However, this setting is required if listenTLSCert is set.
	ListenTLSKey *string `json:"listenTLSKey,omitempty" msgpack:"listenTLSKey,omitempty" bson:"listentlskey,omitempty" mapstructure:"listenTLSKey,omitempty"`

	// The ingress datapath mode to use for network traffic arriving for this ingress
	// provider for this application component. By default this is set to disabled.
	// However, this can be changed to mirror traffic where the Apex is only providing
	// visibility with no possibility of any access or content policies to take effect.
	// Or this can be set to inline in which case all traffic to providers will be
	// redirected to the Apex which acts as a transparent proxy in this case. In this
	// mode access and content policies will take effect.
	Mode *IngressProviderConfigModeValue `json:"mode,omitempty" msgpack:"mode,omitempty" bson:"mode,omitempty" mapstructure:"mode,omitempty"`

	// The provider name. This **MUST** match the name of a provider.
	Name *string `json:"name,omitempty" msgpack:"name,omitempty" bson:"name,omitempty" mapstructure:"name,omitempty"`

	// Optional X509v3 PEM encoded certificates appended by newlines. This setting only
	// has affect if upstream connections are being dialed using TLS. You should use
	// this if your upstream server is serving a certificate which is not signed by a
	// public CA.
	UpstreamCA *string `json:"upstreamCA,omitempty" msgpack:"upstreamCA,omitempty" bson:"upstreamca,omitempty" mapstructure:"upstreamCA,omitempty"`

	ModelVersion int `json:"-" msgpack:"-" bson:"_modelversion"`
}

// NewSparseIngressProviderConfig returns a new  SparseIngressProviderConfig.
func NewSparseIngressProviderConfig() *SparseIngressProviderConfig {
	return &SparseIngressProviderConfig{}
}

// Identity returns the Identity of the sparse object.
func (o *SparseIngressProviderConfig) Identity() elemental.Identity {

	return IngressProviderConfigIdentity
}

// Identifier returns the value of the sparse object's unique identifier.
func (o *SparseIngressProviderConfig) Identifier() string {

	return ""
}

// SetIdentifier sets the value of the sparse object's unique identifier.
func (o *SparseIngressProviderConfig) SetIdentifier(id string) {

}

// GetBSON implements the bson marshaling interface.
// This is used to transparently convert ID to MongoDBID as ObectID.
func (o *SparseIngressProviderConfig) GetBSON() (any, error) {

	if o == nil {
		return nil, nil
	}

	s := &mongoAttributesSparseIngressProviderConfig{}

	if o.ListenPort != nil {
		s.ListenPort = o.ListenPort
	}
	if o.ListenTLS != nil {
		s.ListenTLS = o.ListenTLS
	}
	if o.ListenTLSCert != nil {
		s.ListenTLSCert = o.ListenTLSCert
	}
	if o.ListenTLSKey != nil {
		s.ListenTLSKey = o.ListenTLSKey
	}
	if o.Mode != nil {
		s.Mode = o.Mode
	}
	if o.Name != nil {
		s.Name = o.Name
	}
	if o.UpstreamCA != nil {
		s.UpstreamCA = o.UpstreamCA
	}

	return s, nil
}

// SetBSON implements the bson marshaling interface.
// This is used to transparently convert ID to MongoDBID as ObectID.
func (o *SparseIngressProviderConfig) SetBSON(raw bson.Raw) error {

	if o == nil {
		return nil
	}

	s := &mongoAttributesSparseIngressProviderConfig{}
	if err := raw.Unmarshal(s); err != nil {
		return err
	}

	if s.ListenPort != nil {
		o.ListenPort = s.ListenPort
	}
	if s.ListenTLS != nil {
		o.ListenTLS = s.ListenTLS
	}
	if s.ListenTLSCert != nil {
		o.ListenTLSCert = s.ListenTLSCert
	}
	if s.ListenTLSKey != nil {
		o.ListenTLSKey = s.ListenTLSKey
	}
	if s.Mode != nil {
		o.Mode = s.Mode
	}
	if s.Name != nil {
		o.Name = s.Name
	}
	if s.UpstreamCA != nil {
		o.UpstreamCA = s.UpstreamCA
	}

	return nil
}

// Version returns the hardcoded version of the model.
func (o *SparseIngressProviderConfig) Version() int {

	return 1
}

// ToPlain returns the plain version of the sparse model.
func (o *SparseIngressProviderConfig) ToPlain() elemental.PlainIdentifiable {

	out := NewIngressProviderConfig()
	if o.ListenPort != nil {
		out.ListenPort = *o.ListenPort
	}
	if o.ListenTLS != nil {
		out.ListenTLS = *o.ListenTLS
	}
	if o.ListenTLSCert != nil {
		out.ListenTLSCert = *o.ListenTLSCert
	}
	if o.ListenTLSKey != nil {
		out.ListenTLSKey = *o.ListenTLSKey
	}
	if o.Mode != nil {
		out.Mode = *o.Mode
	}
	if o.Name != nil {
		out.Name = *o.Name
	}
	if o.UpstreamCA != nil {
		out.UpstreamCA = *o.UpstreamCA
	}

	return out
}

// DeepCopy returns a deep copy if the SparseIngressProviderConfig.
func (o *SparseIngressProviderConfig) DeepCopy() *SparseIngressProviderConfig {

	if o == nil {
		return nil
	}

	out := &SparseIngressProviderConfig{}
	o.DeepCopyInto(out)

	return out
}

// DeepCopyInto copies the receiver into the given *SparseIngressProviderConfig.
func (o *SparseIngressProviderConfig) DeepCopyInto(out *SparseIngressProviderConfig) {

	target, err := copystructure.Copy(o)
	if err != nil {
		panic(fmt.Sprintf("Unable to deepcopy SparseIngressProviderConfig: %s", err))
	}

	*out = *target.(*SparseIngressProviderConfig)
}

type mongoAttributesIngressProviderConfig struct {
	ListenPort    int                                 `bson:"listenport"`
	ListenTLS     IngressProviderConfigListenTLSValue `bson:"listentls"`
	ListenTLSCert string                              `bson:"listentlscert,omitempty"`
	ListenTLSKey  string                              `bson:"listentlskey,omitempty"`
	Mode          IngressProviderConfigModeValue      `bson:"mode"`
	Name          string                              `bson:"name"`
	UpstreamCA    string                              `bson:"upstreamca,omitempty"`
}
type mongoAttributesSparseIngressProviderConfig struct {
	ListenPort    *int                                 `bson:"listenport,omitempty"`
	ListenTLS     *IngressProviderConfigListenTLSValue `bson:"listentls,omitempty"`
	ListenTLSCert *string                              `bson:"listentlscert,omitempty"`
	ListenTLSKey  *string                              `bson:"listentlskey,omitempty"`
	Mode          *IngressProviderConfigModeValue      `bson:"mode,omitempty"`
	Name          *string                              `bson:"name,omitempty"`
	UpstreamCA    *string                              `bson:"upstreamca,omitempty"`
}
