// Code generated by elegen. DO NOT EDIT.
// Source: go.acuvity.ai/elemental (templates/model.gotpl)

package api

import (
	"fmt"

	"github.com/globalsign/mgo/bson"
	"github.com/mitchellh/copystructure"
	"go.acuvity.ai/elemental"
)

// MapperMethodValue represents the possible values for attribute "method".
type MapperMethodValue string

const (
	// MapperMethodDelete represents the value Delete.
	MapperMethodDelete MapperMethodValue = "Delete"

	// MapperMethodGet represents the value Get.
	MapperMethodGet MapperMethodValue = "Get"

	// MapperMethodHead represents the value Head.
	MapperMethodHead MapperMethodValue = "Head"

	// MapperMethodOptions represents the value Options.
	MapperMethodOptions MapperMethodValue = "Options"

	// MapperMethodPatch represents the value Patch.
	MapperMethodPatch MapperMethodValue = "Patch"

	// MapperMethodPost represents the value Post.
	MapperMethodPost MapperMethodValue = "Post"

	// MapperMethodPut represents the value Put.
	MapperMethodPut MapperMethodValue = "Put"
)

// Mapper represents the model of a mapper
type Mapper struct {
	// Set how long the data should be cached.
	Expiration string `json:"expiration" msgpack:"expiration" bson:"expiration" mapstructure:"expiration,omitempty"`

	// Optional hosts to match. This is useful in case the provider has multiple hosts
	// to discriminate which logger to use.
	Hosts []string `json:"hosts,omitempty" msgpack:"hosts,omitempty" bson:"hosts,omitempty" mapstructure:"hosts,omitempty"`

	// A regular expression to match an URL to log.
	Match string `json:"match" msgpack:"match" bson:"match" mapstructure:"match,omitempty"`

	// The method to match.
	Method MapperMethodValue `json:"method" msgpack:"method" bson:"method" mapstructure:"method,omitempty"`

	// The name of the extractor. It will be used to identify which extractor was used
	// during an extraction.
	Name string `json:"name,omitempty" msgpack:"name,omitempty" bson:"name,omitempty" mapstructure:"name,omitempty"`

	// If not empty, use this lua code to run the extraction.
	Script string `json:"script,omitempty" msgpack:"script,omitempty" bson:"script,omitempty" mapstructure:"script,omitempty"`

	ModelVersion int `json:"-" msgpack:"-" bson:"_modelversion"`
}

// NewMapper returns a new *Mapper
func NewMapper() *Mapper {

	return &Mapper{
		ModelVersion: 1,
		Expiration:   "1h",
		Hosts:        []string{},
	}
}

// GetBSON implements the bson marshaling interface.
// This is used to transparently convert ID to MongoDBID as ObectID.
func (o *Mapper) GetBSON() (any, error) {

	if o == nil {
		return nil, nil
	}

	s := &mongoAttributesMapper{}

	s.Expiration = o.Expiration
	s.Hosts = o.Hosts
	s.Match = o.Match
	s.Method = o.Method
	s.Name = o.Name
	s.Script = o.Script

	return s, nil
}

// SetBSON implements the bson marshaling interface.
// This is used to transparently convert ID to MongoDBID as ObectID.
func (o *Mapper) SetBSON(raw bson.Raw) error {

	if o == nil {
		return nil
	}

	s := &mongoAttributesMapper{}
	if err := raw.Unmarshal(s); err != nil {
		return err
	}

	o.Expiration = s.Expiration
	o.Hosts = s.Hosts
	o.Match = s.Match
	o.Method = s.Method
	o.Name = s.Name
	o.Script = s.Script

	return nil
}

// BleveType implements the bleve.Classifier Interface.
func (o *Mapper) BleveType() string {

	return "mapper"
}

// GetMatch returns the Match of the receiver.
func (o *Mapper) GetMatch() string {

	return o.Match
}

// DeepCopy returns a deep copy if the Mapper.
func (o *Mapper) DeepCopy() *Mapper {

	if o == nil {
		return nil
	}

	out := &Mapper{}
	o.DeepCopyInto(out)

	return out
}

// DeepCopyInto copies the receiver into the given *Mapper.
func (o *Mapper) DeepCopyInto(out *Mapper) {

	target, err := copystructure.Copy(o)
	if err != nil {
		panic(fmt.Sprintf("Unable to deepcopy Mapper: %s", err))
	}

	*out = *target.(*Mapper)
}

// Validate valides the current information stored into the structure.
func (o *Mapper) Validate() error {

	errors := elemental.Errors{}
	requiredErrors := elemental.Errors{}

	if err := ValidateDuration("expiration", o.Expiration); err != nil {
		errors = errors.Append(err)
	}

	if err := elemental.ValidateRequiredString("match", o.Match); err != nil {
		requiredErrors = requiredErrors.Append(err)
	}

	if err := elemental.ValidateRequiredString("method", string(o.Method)); err != nil {
		requiredErrors = requiredErrors.Append(err)
	}

	if err := elemental.ValidateStringInList("method", string(o.Method), []string{"Post", "Put", "Patch", "Get", "Delete", "Options", "Head"}, false); err != nil {
		errors = errors.Append(err)
	}

	if err := ValidateLua("script", o.Script); err != nil {
		errors = errors.Append(err)
	}

	if len(requiredErrors) > 0 {
		return requiredErrors
	}

	if len(errors) > 0 {
		return errors
	}

	return nil
}

// SpecificationForAttribute returns the AttributeSpecification for the given attribute name key.
func (*Mapper) SpecificationForAttribute(name string) elemental.AttributeSpecification {

	if v, ok := MapperAttributesMap[name]; ok {
		return v
	}

	// We could not find it, so let's check on the lower case indexed spec map
	return MapperLowerCaseAttributesMap[name]
}

// AttributeSpecifications returns the full attribute specifications map.
func (*Mapper) AttributeSpecifications() map[string]elemental.AttributeSpecification {

	return MapperAttributesMap
}

// ValueForAttribute returns the value for the given attribute.
// This is a very advanced function that you should not need but in some
// very specific use cases.
func (o *Mapper) ValueForAttribute(name string) any {

	switch name {
	case "expiration":
		return o.Expiration
	case "hosts":
		return o.Hosts
	case "match":
		return o.Match
	case "method":
		return o.Method
	case "name":
		return o.Name
	case "script":
		return o.Script
	}

	return nil
}

// MapperAttributesMap represents the map of attribute for Mapper.
var MapperAttributesMap = map[string]elemental.AttributeSpecification{
	"Expiration": {
		AllowedChoices: []string{},
		BSONFieldName:  "expiration",
		ConvertedName:  "Expiration",
		DefaultValue:   "1h",
		Description:    `Set how long the data should be cached.`,
		Exposed:        true,
		Name:           "expiration",
		Stored:         true,
		Type:           "string",
	},
	"Hosts": {
		AllowedChoices: []string{},
		BSONFieldName:  "hosts",
		ConvertedName:  "Hosts",
		Description: `Optional hosts to match. This is useful in case the provider has multiple hosts
to discriminate which logger to use.`,
		Exposed: true,
		Name:    "hosts",
		Stored:  true,
		SubType: "string",
		Type:    "list",
	},
	"Match": {
		AllowedChoices: []string{},
		BSONFieldName:  "match",
		ConvertedName:  "Match",
		Description:    `A regular expression to match an URL to log.`,
		Exposed:        true,
		Getter:         true,
		Name:           "match",
		Required:       true,
		Stored:         true,
		Type:           "string",
	},
	"Method": {
		AllowedChoices: []string{"Post", "Put", "Patch", "Get", "Delete", "Options", "Head"},
		BSONFieldName:  "method",
		ConvertedName:  "Method",
		Description:    `The method to match.`,
		Exposed:        true,
		Name:           "method",
		Required:       true,
		Stored:         true,
		SubType:        "string",
		Type:           "enum",
	},
	"Name": {
		AllowedChoices: []string{},
		BSONFieldName:  "name",
		ConvertedName:  "Name",
		Description: `The name of the extractor. It will be used to identify which extractor was used
during an extraction.`,
		Exposed: true,
		Name:    "name",
		Stored:  true,
		Type:    "string",
	},
	"Script": {
		AllowedChoices: []string{},
		BSONFieldName:  "script",
		ConvertedName:  "Script",
		Description:    `If not empty, use this lua code to run the extraction.`,
		Exposed:        true,
		Name:           "script",
		Stored:         true,
		Type:           "string",
	},
}

// MapperLowerCaseAttributesMap represents the map of attribute for Mapper.
var MapperLowerCaseAttributesMap = map[string]elemental.AttributeSpecification{
	"expiration": {
		AllowedChoices: []string{},
		BSONFieldName:  "expiration",
		ConvertedName:  "Expiration",
		DefaultValue:   "1h",
		Description:    `Set how long the data should be cached.`,
		Exposed:        true,
		Name:           "expiration",
		Stored:         true,
		Type:           "string",
	},
	"hosts": {
		AllowedChoices: []string{},
		BSONFieldName:  "hosts",
		ConvertedName:  "Hosts",
		Description: `Optional hosts to match. This is useful in case the provider has multiple hosts
to discriminate which logger to use.`,
		Exposed: true,
		Name:    "hosts",
		Stored:  true,
		SubType: "string",
		Type:    "list",
	},
	"match": {
		AllowedChoices: []string{},
		BSONFieldName:  "match",
		ConvertedName:  "Match",
		Description:    `A regular expression to match an URL to log.`,
		Exposed:        true,
		Getter:         true,
		Name:           "match",
		Required:       true,
		Stored:         true,
		Type:           "string",
	},
	"method": {
		AllowedChoices: []string{"Post", "Put", "Patch", "Get", "Delete", "Options", "Head"},
		BSONFieldName:  "method",
		ConvertedName:  "Method",
		Description:    `The method to match.`,
		Exposed:        true,
		Name:           "method",
		Required:       true,
		Stored:         true,
		SubType:        "string",
		Type:           "enum",
	},
	"name": {
		AllowedChoices: []string{},
		BSONFieldName:  "name",
		ConvertedName:  "Name",
		Description: `The name of the extractor. It will be used to identify which extractor was used
during an extraction.`,
		Exposed: true,
		Name:    "name",
		Stored:  true,
		Type:    "string",
	},
	"script": {
		AllowedChoices: []string{},
		BSONFieldName:  "script",
		ConvertedName:  "Script",
		Description:    `If not empty, use this lua code to run the extraction.`,
		Exposed:        true,
		Name:           "script",
		Stored:         true,
		Type:           "string",
	},
}

type mongoAttributesMapper struct {
	Expiration string            `bson:"expiration"`
	Hosts      []string          `bson:"hosts,omitempty"`
	Match      string            `bson:"match"`
	Method     MapperMethodValue `bson:"method"`
	Name       string            `bson:"name,omitempty"`
	Script     string            `bson:"script,omitempty"`
}
