{
  "components": {
    "schemas": {
      "accesspolicy": {
        "description": "Define which teams or individuals can access a provider.",
        "properties": {
          "ID": {
            "description": "ID is the identifier of the object.",
            "readOnly": true,
            "type": "string"
          },
          "accessDeniedMessage": {
            "description": "The message that is sent if the access is denied.",
            "example": "You must use the company workspace",
            "type": "string"
          },
          "action": {
            "default": "Allow",
            "description": "Define if the provider is allowed or denied for the match expression.",
            "enum": [
              "Allow",
              "Deny"
            ]
          },
          "alertDefinition": {
            "description": "The definition to use for alerting when action is deny.",
            "type": "string"
          },
          "contentPolicies": {
            "description": "The list of content policies to apply when the user has access to the provider.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "createTime": {
            "description": "Creation date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          },
          "description": {
            "description": "Description of the access policy.",
            "type": "string"
          },
          "disabled": {
            "description": "If true, the policy is disabled.",
            "type": "boolean"
          },
          "importHash": {
            "description": "The hash of the structure used to compare with new import version.",
            "type": "string"
          },
          "importLabel": {
            "description": "The user-defined import label that allows the system to group resources from the\nsame import operation.",
            "type": "string"
          },
          "match": {
            "description": "The match criteria used to take a decision on the access.",
            "example": "[\n  {\n    \"key\": \"Team\"\n    \"operator\": \"Any\"\n    \"values\": [\"engineers\"]\n  }\n]",
            "items": {
              "$ref": "#/components/schemas/predicate"
            },
            "type": "array"
          },
          "minimalLogging": {
            "description": "If true, the system will not log the messages that are not considered as\nviolations.",
            "type": "boolean"
          },
          "name": {
            "description": "The name of the access policy.",
            "example": "my access policy",
            "type": "string"
          },
          "namespace": {
            "description": "The namespace of the object.",
            "readOnly": true,
            "type": "string"
          },
          "offbandAnalysis": {
            "description": "If true, the system will run analysis in parallel of the user request. When this\nis active, no further policing will be done, and no content policy will run.\nThis can be used to observe the transmitted data and have analysis report,\nwithout adding latency to the end user request, at the price of not being able\nto do any form of content moderation.",
            "type": "boolean"
          },
          "permissive": {
            "description": "If set, just log the decision, but don't enforce it.",
            "type": "boolean"
          },
          "updateTime": {
            "description": "Last update date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          }
        },
        "required": [
          "name"
        ],
        "type": "object"
      },
      "adminmagiclink": {
        "description": "Administrative API to create magic links.",
        "properties": {
          "ID": {
            "description": "ID is the identifier of the object.",
            "readOnly": true,
            "type": "string"
          },
          "namespace": {
            "description": "The namespace of the object.",
            "readOnly": true,
            "type": "string"
          },
          "passcode": {
            "$ref": "#/components/schemas/passcode"
          }
        },
        "type": "object"
      },
      "adminorg": {
        "description": "Administrative API to create new organizations.",
        "properties": {
          "ID": {
            "description": "ID is the identifier of the object.",
            "readOnly": true,
            "type": "string"
          },
          "forceReimportTemplate": {
            "description": "This property if true will force reimport the template data. Setting it false is\na noop.",
            "type": "boolean"
          },
          "githubSigninEnabled": {
            "description": "Enables the global Sign In With Github for the organization.",
            "type": "boolean"
          },
          "gitlabSigninEnabled": {
            "description": "Enables the global Sign In With Gitlab for the organization.",
            "type": "boolean"
          },
          "googleSigninEnabled": {
            "description": "Enables the global Sign In With Google for the organization.",
            "type": "boolean"
          },
          "huggingfaceSigninEnabled": {
            "description": "Enables the global Sign In With Huggingface for the organization.",
            "type": "boolean"
          },
          "mode": {
            "default": "Normal",
            "description": "The mode of the organization.",
            "enum": [
              "Trial",
              "TrialEmployees",
              "TrialApps",
              "Pilot",
              "Normal",
              "NormalEmployees",
              "NormalApps",
              "Blocked",
              "Dead"
            ]
          },
          "name": {
            "description": "The name of the organization.",
            "example": "acme.com",
            "type": "string"
          },
          "namespace": {
            "description": "The namespace of the object.",
            "readOnly": true,
            "type": "string"
          },
          "reimportTemplate": {
            "description": "This is an internal property used to decide if the org template needs to be\nreimported.",
            "readOnly": true,
            "type": "boolean"
          },
          "subject": {
            "description": "A tag expression that identifies the authorized user(s). If set it will\nconfigure the complete subject of the admin api authorization, ignoring anything\npassed in claims.",
            "items": {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "type": "array"
          },
          "type": {
            "default": "Full",
            "description": "The type of organization. Either Full or Single. Full represents an organization\nthat will need to onboard additional users, while Single represents a single\nuser account.",
            "enum": [
              "Full",
              "Single"
            ]
          }
        },
        "required": [
          "name"
        ],
        "type": "object"
      },
      "agent": {
        "description": "Stores information about a known agent.",
        "properties": {
          "ID": {
            "description": "ID is the identifier of the object.",
            "readOnly": true,
            "type": "string"
          },
          "agentConfig": {
            "$ref": "#/components/schemas/agentconfig"
          },
          "currentVersion": {
            "description": "The current version of the agent.",
            "example": "0.1.0",
            "type": "string"
          },
          "hostname": {
            "description": "The name of the host where the agent is runnning.",
            "example": "this-hostname",
            "type": "string"
          },
          "importHash": {
            "description": "The hash of the structure used to compare with new import version.",
            "type": "string"
          },
          "importLabel": {
            "description": "The user-defined import label that allows the system to group resources from the\nsame import operation.",
            "type": "string"
          },
          "isAPEXReachable": {
            "description": "True if the apex is reachable.",
            "type": "boolean"
          },
          "isAPEXTrusted": {
            "description": "True if the apex is trusted.",
            "type": "boolean"
          },
          "managedCAState": {
            "description": "The state of the managed CA.",
            "type": "boolean"
          },
          "managedInterfaces": {
            "description": "The list of managed interfaces.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "namespace": {
            "description": "The namespace of the object.",
            "readOnly": true,
            "type": "string"
          },
          "ping": {
            "description": "The last ping recorded for the agent.",
            "example": "2024-06-21T00:36:15.021Z",
            "format": "date-time",
            "type": "string"
          },
          "principal": {
            "$ref": "#/components/schemas/principal"
          },
          "start": {
            "description": "The start time for the agent.",
            "example": "2024-06-21T00:36:15.021Z",
            "format": "date-time",
            "type": "string"
          },
          "status": {
            "description": "The status of the agent.",
            "enum": [
              "Alive",
              "Stopped"
            ],
            "example": "Alive"
          },
          "systemProxyManagementState": {
            "description": "The state of the system proxy management.",
            "type": "boolean"
          }
        },
        "required": [
          "currentVersion",
          "hostname",
          "ping",
          "principal",
          "start",
          "status"
        ],
        "type": "object"
      },
      "agentconfig": {
        "description": "AgentConfig stores the configuration information for the acushield agent.",
        "properties": {
          "ID": {
            "description": "ID is the identifier of the object.",
            "readOnly": true,
            "type": "string"
          },
          "allowedPauseInterval": {
            "default": "0s",
            "description": "An administrator can set this for users to pause enforcement for this interval.\nA value of 0s means that users are not allowed to pause the enforcement.",
            "example": "60m",
            "type": "string"
          },
          "createTime": {
            "description": "Creation date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          },
          "description": {
            "description": "Description of the agent configuration.",
            "type": "string"
          },
          "disableManagedCA": {
            "description": "If disabled, the agent will rely on the CA already installed and trusted on the\nsystem.",
            "type": "boolean"
          },
          "disableSystemProxyManagement": {
            "description": "If disabled, the system proxy needs to be configured manually.",
            "type": "boolean"
          },
          "disableURLDiscovery": {
            "description": "If disabled, the agent will stop reporting the visited domains.",
            "type": "boolean"
          },
          "enablePause": {
            "description": "If enabled, the agent will have the ability to pause enforcement.",
            "type": "boolean"
          },
          "importHash": {
            "description": "The hash of the structure used to compare with new import version.",
            "type": "string"
          },
          "importLabel": {
            "description": "The user-defined import label that allows the system to group resources from the\nsame import operation.",
            "type": "string"
          },
          "listeningPort": {
            "default": "8081",
            "description": "The port use by the agent to proxy the traffic.",
            "type": "string"
          },
          "name": {
            "description": "The name of the agent configuration.",
            "example": "default",
            "type": "string"
          },
          "namespace": {
            "description": "The namespace of the object.",
            "readOnly": true,
            "type": "string"
          },
          "pacName": {
            "description": "The name of the PAC configuration to use.",
            "example": "default",
            "type": "string"
          },
          "pingInterval": {
            "default": "10m",
            "description": "The ping interval at which acushield should check in with the backend.",
            "example": "30m",
            "type": "string"
          },
          "updateTime": {
            "description": "Last update date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          },
          "useDynamicPort": {
            "description": "If system proxy management is enabled and this flag is enabled, the system\ncan take another port, different that the listeningPort.",
            "type": "boolean"
          }
        },
        "required": [
          "listeningPort",
          "name"
        ],
        "type": "object"
      },
      "aidomain": {
        "description": "AI domain provides an AI risk score given a domain url.",
        "properties": {
          "ID": {
            "description": "ID is the identifier of the object.",
            "readOnly": true,
            "type": "string"
          },
          "compliances": {
            "description": "The list of compliance provided by the domain.",
            "example": [
              "SOC2",
              "GDPR",
              "HIPAA"
            ],
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "createTime": {
            "description": "Creation date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          },
          "dataResidency": {
            "description": "The user data storage location.",
            "example": [
              "US",
              "EU",
              "China"
            ],
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "dataSharing": {
            "description": "Does the provider share user data with 3rd party or services.",
            "type": "boolean"
          },
          "dataSharingConsent": {
            "description": "Does the provider share user data with consent with 3rd party or services.",
            "type": "boolean"
          },
          "description": {
            "description": "A brief description about the AI domain and what services it provides.",
            "example": "A description text",
            "type": "string"
          },
          "domain": {
            "description": "The domain of the AI provider.",
            "example": "openai.com",
            "type": "string"
          },
          "importHash": {
            "description": "The hash of the structure used to compare with new import version.",
            "type": "string"
          },
          "importLabel": {
            "description": "The user-defined import label that allows the system to group resources from the\nsame import operation.",
            "type": "string"
          },
          "isAIDomain": {
            "description": "Flag to say if the domain is a AI domain or not.",
            "type": "boolean"
          },
          "models": {
            "description": "List of AI models used by the domain.",
            "example": [
              "gpt-4o",
              "gpt-4"
            ],
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "namespace": {
            "description": "The namespace of the object.",
            "readOnly": true,
            "type": "string"
          },
          "propagate": {
            "default": true,
            "description": "Propagates the object to all child namespaces. This is always true.",
            "type": "boolean"
          },
          "providerName": {
            "description": "The name of the main provider.",
            "example": "chatgpt",
            "type": "string"
          },
          "providerRetentionPolicies": {
            "description": "The data retention policies by the domain for each type of users.",
            "items": {
              "$ref": "#/components/schemas/providerretentionpolicy"
            },
            "type": "array"
          },
          "providerTrainingPolicies": {
            "description": "Does the provider use user data for training its model.",
            "example": [
              {
                "description": "provider uses user data for training the models on Free plan ",
                "subscriptiontype": "Free",
                "useData": true
              }
            ],
            "items": {
              "$ref": "#/components/schemas/providertrainingpolicy"
            },
            "type": "array"
          },
          "riskExplanation": {
            "description": "A Markdown formatted string explaining the risk score.",
            "example": "A markdown string",
            "type": "string"
          },
          "riskScore": {
            "description": "The risk score for the domain.",
            "example": 0.5,
            "type": "number"
          },
          "thirdPartyModelUsage": {
            "description": "Does provider use third party model.",
            "type": "boolean"
          },
          "updateTime": {
            "description": "Last update date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          }
        },
        "required": [
          "domain",
          "riskScore"
        ],
        "type": "object"
      },
      "alert": {
        "description": "Represents an alert.",
        "properties": {
          "ID": {
            "description": "ID is the identifier of the object.",
            "readOnly": true,
            "type": "string"
          },
          "alertDefinition": {
            "$ref": "#/components/schemas/alertdefinition"
          },
          "alertDefinitionName": {
            "description": "The name identifier of the alert definition that triggered the alert.",
            "example": "warning-notification",
            "type": "string"
          },
          "alertEvents": {
            "description": "The events related to the alert.",
            "items": {
              "$ref": "#/components/schemas/alertevent"
            },
            "readOnly": true,
            "type": "array"
          },
          "counter": {
            "default": 1,
            "description": "The number of times the alert was raised.",
            "type": "integer"
          },
          "createTime": {
            "description": "Creation date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          },
          "end": {
            "description": "When the alert was last raised.",
            "example": "2024-06-21T00:36:15.021Z",
            "format": "date-time",
            "type": "string"
          },
          "namespace": {
            "description": "The namespace of the object.",
            "readOnly": true,
            "type": "string"
          },
          "start": {
            "description": "When the alert was first raised.",
            "example": "2024-06-21T00:06:14.047Z",
            "format": "date-time",
            "type": "string"
          },
          "updateTime": {
            "description": "Last update date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          }
        },
        "required": [
          "alertDefinitionName",
          "counter",
          "end",
          "start"
        ],
        "type": "object"
      },
      "alertdefinition": {
        "description": "Represents a definition of an alert.",
        "properties": {
          "ID": {
            "description": "ID is the identifier of the object.",
            "readOnly": true,
            "type": "string"
          },
          "cooldown": {
            "default": "5m",
            "description": "If set, how long until a subsequent alert notification can be raised.",
            "type": "string"
          },
          "createTime": {
            "description": "Creation date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          },
          "description": {
            "description": "The description of the alert definition.",
            "type": "string"
          },
          "friendlyName": {
            "description": "Friendly name of the object.",
            "example": "Simple name",
            "type": "string"
          },
          "importHash": {
            "description": "The hash of the structure used to compare with new import version.",
            "type": "string"
          },
          "importLabel": {
            "description": "The user-defined import label that allows the system to group resources from the\nsame import operation.",
            "type": "string"
          },
          "message": {
            "description": "The message sent when notifying.",
            "type": "string"
          },
          "name": {
            "description": "The internal reference name of the object. It is a sanitized version of Friendly\nName if empty.",
            "example": "my-simple-policy",
            "type": "string"
          },
          "namespace": {
            "description": "The namespace of the object.",
            "readOnly": true,
            "type": "string"
          },
          "propagate": {
            "default": true,
            "description": "Propagates the object to all child namespaces. This is always true.",
            "type": "boolean"
          },
          "severity": {
            "default": "Warning",
            "description": "The severity of the alert event.",
            "enum": [
              "Critical",
              "Warning",
              "Info"
            ]
          },
          "sinks": {
            "description": "The sinks used to notify.",
            "example": [
              "Email Notification",
              "Slack Notification"
            ],
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "trigger": {
            "$ref": "#/components/schemas/alerttrigger"
          },
          "updateTime": {
            "description": "Last update date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          }
        },
        "required": [
          "friendlyName",
          "severity"
        ],
        "type": "object"
      },
      "alertevent": {
        "description": "Represents an alert event raised by a policy.",
        "properties": {
          "alertDefinition": {
            "description": "The name of the alert definition that triggered the alert event.",
            "example": "warning-notification",
            "type": "string"
          },
          "alertDefinitionNamespace": {
            "description": "The namespace of the alert definition.",
            "type": "string"
          },
          "principal": {
            "$ref": "#/components/schemas/principal"
          },
          "provider": {
            "description": "The provider used that the alert came from.",
            "type": "string"
          },
          "timestamp": {
            "description": "When the alert event was raised.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          }
        },
        "required": [
          "alertDefinition",
          "principal"
        ],
        "type": "object"
      },
      "alerttrigger": {
        "description": "Represents the criteria to trigger an alert notification.",
        "properties": {
          "interval": {
            "default": "24h",
            "description": "What time window to look for an alert event.",
            "type": "string"
          },
          "occurrences": {
            "default": 1,
            "description": "The number of times an alert event is seen to cause a trigger.",
            "type": "integer"
          }
        },
        "required": [
          "interval",
          "occurrences"
        ],
        "type": "object"
      },
      "analysis": {
        "description": "Represent a ml pipeline graph analysis.",
        "properties": {
          "analyses": {
            "description": "The list of analysis chained to this analyzer analysis.",
            "items": {
              "$ref": "#/components/schemas/analysis"
            },
            "type": "array"
          },
          "analyzerID": {
            "description": "The ID of the analyzer.",
            "type": "string"
          },
          "detections": {
            "description": "The list of detections the analyzer returned.",
            "items": {
              "$ref": "#/components/schemas/detection"
            },
            "type": "array"
          },
          "duration": {
            "description": "The time taken by the analyzer.",
            "type": "number"
          },
          "matchingDetections": {
            "description": "A list of detections that matches the detection matchers criteria set on\nanalyzers,\ntriggering their execution.",
            "example": [
              {
                "confidence": "Medium",
                "description": "Txt Text",
                "group": "Text",
                "label": "txt",
                "name": "txt",
                "raw_score": 0.2,
                "score": 0.5
              }
            ],
            "items": {
              "$ref": "#/components/schemas/detection"
            },
            "type": "array"
          },
          "skippedReason": {
            "description": "The reason the analyzer was skipped.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "analyzer": {
        "description": "Represents an analyzer.",
        "properties": {
          "ID": {
            "description": "ID is the identifier of the object.",
            "readOnly": true,
            "type": "string"
          },
          "description": {
            "description": "The description of the analyzer.",
            "type": "string"
          },
          "detectionMatchers": {
            "description": "A list of detection matcher that will trigger the analyzer.",
            "example": [
              [
                {
                  "confidence": "Medium",
                  "group": "Text",
                  "name": "txt",
                  "operator": "min"
                }
              ]
            ],
            "items": {
              "items": {
                "type": "object"
              },
              "type": "array"
            },
            "type": "array"
          },
          "detectors": {
            "description": "The detectors the analyzer can use.",
            "items": {
              "$ref": "#/components/schemas/detector"
            },
            "type": "array"
          },
          "enabled": {
            "description": "Tell if the analyzer is enabled by default.",
            "type": "boolean"
          },
          "group": {
            "description": "The group the analyzer belongs to.",
            "type": "string"
          },
          "models": {
            "description": "The models used by the analyzer.",
            "items": {
              "$ref": "#/components/schemas/analyzermodel"
            },
            "type": "array"
          },
          "name": {
            "description": "The name of the analyzer.",
            "type": "string"
          },
          "namespace": {
            "description": "The namespace of the object.",
            "readOnly": true,
            "type": "string"
          }
        },
        "type": "object"
      },
      "analyzermodel": {
        "description": "Represent an analyzer model.",
        "properties": {
          "name": {
            "description": "The name of the model.",
            "type": "string"
          },
          "revision": {
            "description": "The revision of the model.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "apiauthorization": {
        "description": "Define API Authorizations to define who can access the Acuvity console.",
        "properties": {
          "ID": {
            "description": "ID is the identifier of the object.",
            "readOnly": true,
            "type": "string"
          },
          "createTime": {
            "description": "Creation date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          },
          "description": {
            "description": "Description of the authorization rule.",
            "type": "string"
          },
          "disabled": {
            "description": "When disabled, an API Authorization has no effect.",
            "type": "boolean"
          },
          "importHash": {
            "description": "The hash of the structure used to compare with new import version.",
            "type": "string"
          },
          "importLabel": {
            "description": "The user-defined import label that allows the system to group resources from the\nsame import operation.",
            "type": "string"
          },
          "name": {
            "description": "The name of the authorization rule.",
            "example": "my api authorization.",
            "type": "string"
          },
          "namespace": {
            "description": "The namespace of the object.",
            "readOnly": true,
            "type": "string"
          },
          "permissions": {
            "description": "The individual permissions. Only works if role is Custom.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "role": {
            "default": "Employee",
            "description": "The role for the subjects.",
            "enum": [
              "Administrator",
              "Application",
              "Custom",
              "Employee",
              "Owner",
              "Proxy",
              "Trial",
              "Viewer"
            ]
          },
          "subject": {
            "description": "A tag expression that identifies the authorized user(s).",
            "items": {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "type": "array"
          },
          "targetNamespaces": {
            "description": "Defines the namespace or namespaces in which the permission for subject should\napply. If empty, the object's namespace will be used.",
            "example": "/my/namespace",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "updateTime": {
            "description": "Last update date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          }
        },
        "required": [
          "name"
        ],
        "type": "object"
      },
      "app": {
        "description": "App allow to define a generic application.",
        "properties": {
          "ID": {
            "description": "ID is the identifier of the object.",
            "readOnly": true,
            "type": "string"
          },
          "components": {
            "description": "List of components for the application.",
            "example": {
              "refMode": "pointer"
            },
            "items": {
              "$ref": "#/components/schemas/appcomponent"
            },
            "type": "array"
          },
          "createTime": {
            "description": "Creation date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          },
          "description": {
            "description": "The description of the App.",
            "example": "My Wordpress Instance",
            "type": "string"
          },
          "importHash": {
            "description": "The hash of the structure used to compare with new import version.",
            "type": "string"
          },
          "importLabel": {
            "description": "The user-defined import label that allows the system to group resources from the\nsame import operation.",
            "type": "string"
          },
          "name": {
            "description": "The name of the App.",
            "example": "wordpress",
            "type": "string"
          },
          "namespace": {
            "description": "The namespace of the object.",
            "readOnly": true,
            "type": "string"
          },
          "selector": {
            "description": "A tag expression that identify an application based on downstream labels.",
            "example": [
              [
                "k8s-namespace=wordpress",
                "zone=us-west"
              ]
            ],
            "items": {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "type": "array"
          },
          "subject": {
            "description": "Only bearers with claims matching the subject will be allowed to access the\nappcomponent tokens.",
            "items": {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "type": "array"
          },
          "updateTime": {
            "description": "Last update date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          }
        },
        "required": [
          "name"
        ],
        "type": "object"
      },
      "appcomponent": {
        "description": "Represents a particular component of the application.",
        "properties": {
          "CAInjectionEnabled": {
            "description": "EXPERIMENTAL. If egress mode is inline, the Apex will act as a transparent\nproxy. The certificates that will be served by the proxy are generated by the\nApex itself which are issued by a dynamic TLS CA. If you enable this feature,\nthe matching app component instances will get the CA certificate dynamically\ninjected into the system trust store.",
            "type": "boolean"
          },
          "description": {
            "description": "The description of the component.",
            "example": "The email agent with reading capabilities.",
            "type": "string"
          },
          "egressMode": {
            "default": "Disabled",
            "description": "The egress datapath mode to use for network traffic going out to providers for\nthis application component. By default this is set to disabled. However, this\ncan be changed to mirror traffic where the Apex is only providing visibility\nwith no possibility of any access or content policies to take effect. Or this\ncan be set to inline in which case all traffic to providers will be redirected\nto the Apex which acts as a transparent proxy in this case. In this mode access\nand content policies will take effect.",
            "enum": [
              "Disabled",
              "Mirror",
              "Inline"
            ],
            "example": "Inline"
          },
          "ingressProviderConfigs": {
            "description": "The ingress provider configurations to serve for this application. If this app\ncomponent serves multiple ingress providers, you must define an ingress provider\nconfig for every single one of them. If you need access to the same ingress\nprovider over different port configurations (for example one serving https while\nanother port serves plain http), then you must define two ingress provider\nconfigurations and reuse the same provider name within the configuration.",
            "items": {
              "$ref": "#/components/schemas/ingressproviderconfig"
            },
            "type": "array"
          },
          "name": {
            "description": "The component name.",
            "example": "mailerd",
            "type": "string"
          },
          "providerName": {
            "description": "If given, this is the provider name that this component represents. This\n**MUST** match the name of a provider.",
            "example": "my-app-provider",
            "type": "string"
          },
          "selector": {
            "description": "A tag expression that identify an application component based on downstream\nlabels.",
            "example": [
              [
                "component=frontend"
              ]
            ],
            "items": {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "type": "array"
          },
          "token": {
            "description": "The token for the current component. Only populated by the backend when the\ncaller's\nclaim match the parents app.subject.",
            "readOnly": true,
            "type": "string"
          }
        },
        "required": [
          "name"
        ],
        "type": "object"
      },
      "apptoken": {
        "description": "App Token are revocable long lived tokens.",
        "properties": {
          "ID": {
            "description": "ID is the identifier of the object.",
            "readOnly": true,
            "type": "string"
          },
          "claims": {
            "description": "The list of claims delivered in the token.",
            "items": {
              "type": "string"
            },
            "readOnly": true,
            "type": "array"
          },
          "createTime": {
            "description": "Creation date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          },
          "email": {
            "description": "The email of the user who requested the token.",
            "readOnly": true,
            "type": "string"
          },
          "expirationDate": {
            "description": "Tells when the token will expire.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          },
          "machineID": {
            "description": "The optional machine ID of the token. This is used to easily retrieve the tokens\nissued for a particular machine.",
            "type": "string"
          },
          "name": {
            "description": "Name of the token is specified while creating the token.",
            "example": "my personal access token",
            "type": "string"
          },
          "namespace": {
            "description": "The namespace of the object.",
            "readOnly": true,
            "type": "string"
          },
          "sourceIP": {
            "description": "The source IP of the request that initiated the creation of the token.",
            "readOnly": true,
            "type": "string"
          },
          "token": {
            "description": "The generated token. It won't be stored.",
            "type": "string"
          },
          "tokenID": {
            "description": "The ID of the associated token.",
            "readOnly": true,
            "type": "string"
          },
          "transient": {
            "description": "If true, the token will not be stored and will only be revocable if you keep\ntrack of the token ID yourself. Also, the validity will be capped and the token\nwon't be long lived.",
            "type": "boolean"
          },
          "updateTime": {
            "description": "Last update date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          },
          "validity": {
            "default": "8760h",
            "description": "Configures the validity of the token.",
            "type": "string"
          }
        },
        "required": [
          "name"
        ],
        "type": "object"
      },
      "authsettings": {
        "description": "Returns the authentication source names available for this organization.",
        "properties": {
          "sourceName": {
            "default": "default",
            "description": "The name of the source.",
            "type": "string"
          },
          "sourceType": {
            "description": "The type of source.",
            "enum": [
              "SAML",
              "OIDC",
              "OAuth2"
            ]
          }
        },
        "type": "object"
      },
      "contentpolicy": {
        "description": "The policy that decides how to handle the request content.",
        "properties": {
          "ID": {
            "description": "ID is the identifier of the object.",
            "readOnly": true,
            "type": "string"
          },
          "createTime": {
            "description": "Creation date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          },
          "description": {
            "description": "Description of the content policy.",
            "type": "string"
          },
          "friendlyName": {
            "description": "Friendly name of the object.",
            "example": "Simple name",
            "type": "string"
          },
          "importHash": {
            "description": "The hash of the structure used to compare with new import version.",
            "type": "string"
          },
          "importLabel": {
            "description": "The user-defined import label that allows the system to group resources from the\nsame import operation.",
            "type": "string"
          },
          "moderations": {
            "description": "The list of moderations to take when the user has access to the provider.",
            "example": "You must use the company workspace",
            "items": {
              "$ref": "#/components/schemas/moderation"
            },
            "type": "array"
          },
          "name": {
            "description": "The internal reference name of the object. It is a sanitized version of Friendly\nName if empty.",
            "example": "my-simple-policy",
            "type": "string"
          },
          "namespace": {
            "description": "The namespace of the object.",
            "readOnly": true,
            "type": "string"
          },
          "propagate": {
            "default": true,
            "description": "Propagates the object to all child namespaces. This is always true.",
            "type": "boolean"
          },
          "updateTime": {
            "description": "Last update date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          }
        },
        "required": [
          "friendlyName"
        ],
        "type": "object"
      },
      "customdataset": {
        "description": "Allows to create a custom data set.",
        "properties": {
          "ID": {
            "description": "ID is the identifier of the object.",
            "readOnly": true,
            "type": "string"
          },
          "createTime": {
            "description": "Creation date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          },
          "dataTypes": {
            "description": "A list of all the data types which are associated to this data set.",
            "example": [
              "ssn",
              "person",
              "location"
            ],
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "description": {
            "description": "Description of the custom data set.",
            "type": "string"
          },
          "friendlyName": {
            "description": "Friendly name of the object.",
            "example": "Simple name",
            "type": "string"
          },
          "importHash": {
            "description": "The hash of the structure used to compare with new import version.",
            "type": "string"
          },
          "importLabel": {
            "description": "The user-defined import label that allows the system to group resources from the\nsame import operation.",
            "type": "string"
          },
          "name": {
            "description": "The internal reference name of the object. It is a sanitized version of Friendly\nName if empty.",
            "example": "my-simple-policy",
            "type": "string"
          },
          "namespace": {
            "description": "The namespace of the object.",
            "readOnly": true,
            "type": "string"
          },
          "propagate": {
            "default": true,
            "description": "Propagates the object to all child namespaces. This is always true.",
            "type": "boolean"
          },
          "updateTime": {
            "description": "Last update date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          }
        },
        "required": [
          "friendlyName"
        ],
        "type": "object"
      },
      "customdatatype": {
        "description": "Allows to create custom data detectors.",
        "properties": {
          "ID": {
            "description": "ID is the identifier of the object.",
            "readOnly": true,
            "type": "string"
          },
          "createTime": {
            "description": "Creation date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          },
          "description": {
            "description": "Description of the custom data type.",
            "type": "string"
          },
          "friendlyName": {
            "description": "Friendly name of the object.",
            "example": "Simple name",
            "type": "string"
          },
          "importHash": {
            "description": "The hash of the structure used to compare with new import version.",
            "type": "string"
          },
          "importLabel": {
            "description": "The user-defined import label that allows the system to group resources from the\nsame import operation.",
            "type": "string"
          },
          "matches": {
            "description": "A list of RE2 regular expressions used for data detection. Each expression can\ninclude zero or one capturing group. If no capturing group is present, detection\npositions will be determined based on the entire captured portion of the data.\nIf a single capturing group is included, the detection positions will correspond\nto the part defined by that group. However, if more than one capturing group is\nfound, the system will return a validation error. Additionally, extra\nvalidations are performed to ensure that the regular expressions are not overly\ncomplex, preventing any negative impact on detection engine performance.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "name": {
            "description": "The internal reference name of the object. It is a sanitized version of Friendly\nName if empty.",
            "example": "my-simple-policy",
            "type": "string"
          },
          "namespace": {
            "description": "The namespace of the object.",
            "readOnly": true,
            "type": "string"
          },
          "propagate": {
            "default": true,
            "description": "Propagates the object to all child namespaces. This is always true.",
            "type": "boolean"
          },
          "updateTime": {
            "description": "Last update date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          }
        },
        "required": [
          "friendlyName"
        ],
        "type": "object"
      },
      "destination": {
        "description": "Represents the destination that this request was made to.",
        "properties": {
          "app": {
            "description": "The name of the application that the domain belongs to.",
            "example": "MyApp",
            "type": "string"
          },
          "component": {
            "description": "The component of the application that the domain belongs to.",
            "example": "frontend",
            "type": "string"
          },
          "host": {
            "description": "The host name of the request.",
            "example": "api.openai.com",
            "type": "string"
          },
          "ip": {
            "description": "The destination IP address of the request.",
            "example": "192.0.2.42",
            "type": "string"
          },
          "labels": {
            "description": "The list of labels attached to the application request destination.",
            "example": [
              "country=us",
              "another-label"
            ],
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "required": [
          "host"
        ],
        "type": "object"
      },
      "detection": {
        "description": "Represent a detection.",
        "properties": {
          "confidence": {
            "description": "The confidence level of the detection.",
            "enum": [
              "Unlikely",
              "Low",
              "Medium",
              "High"
            ]
          },
          "description": {
            "description": "The description of the detection.",
            "type": "string"
          },
          "end": {
            "description": "The end position of the poisitional detection.",
            "type": "integer"
          },
          "group": {
            "description": "The group the detection belongs to.",
            "type": "string"
          },
          "label": {
            "description": "The label returned by the model.",
            "type": "string"
          },
          "name": {
            "description": "The name of the detection.",
            "type": "string"
          },
          "positional": {
            "description": "Tell if the detection is positional.",
            "type": "boolean"
          },
          "raw_score": {
            "description": "The raw score of the detection retuned by the model.",
            "type": "number"
          },
          "score": {
            "description": "The normalized score of the detection against its confidence level thresholds.\nBetween 0 and 1 as low \u003c0.33, 0.33\u003c=Medium\u003c0.66, high \u003e=0.66.",
            "type": "number"
          },
          "start": {
            "description": "The start position of the poisitional detection.",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "detectionmatcher": {
        "description": "Represent a detection matcher.\nA Detection Matcher serves as a filtering mechanism for analyzers, determining\nwhich detections should trigger an analysis. It allows for flexible pattern\nmatching on detection attributes such as name, label, and group using glob-style\nwildcards. Additionally, it enables confidence-based filtering by defining\nthresholds and comparison operators. Detection Matchers provide a structured way\nto control when and how analyzers engage with incoming detections.",
        "properties": {
          "confidence": {
            "default": "Low",
            "description": "The detection confidence level to operate on.",
            "enum": [
              "Unlikely",
              "Low",
              "Medium",
              "High"
            ]
          },
          "description": {
            "description": "The description of the detection matcher.",
            "type": "string"
          },
          "group": {
            "default": "*",
            "description": "The group pattern used to match detection group. Supports glob-style wildcards\n(e.g. 'Text*' matches 'Text', 'Text_'). Default value is '*' meaning matching\nany\ndetection group.",
            "example": "Text",
            "type": "string"
          },
          "label": {
            "default": "*",
            "description": "The label pattern used to match detection label. Supports glob-style wildcards\n(e.g. 'txt*' matches 'txt', 'txtuf8'). Default value is '*' meaning matching any\ndetection label.",
            "example": "txt",
            "type": "string"
          },
          "name": {
            "default": "*",
            "description": "The name pattern used to match detection name. Supports glob-style wildcards\n(e.g. 'txt*' matches 'txt', 'txtuf8'). Default value is '*' meaning matching any\ndetection name.",
            "example": "txt",
            "type": "string"
          },
          "operator": {
            "default": "Min",
            "description": "Specifies how to compare the detection's confidence value against the matcher's\nthreshold:\n- 'Is': All Detections confidence must exactly match the threshold\n- 'Min': At least one detection confidence must be greater than or equal to the\nthreshold\n- 'Max': At least one detection confidence must be less than the threshold\nThe default value is 'Min'.",
            "enum": [
              "Is",
              "Min",
              "Max"
            ]
          }
        },
        "type": "object"
      },
      "detector": {
        "description": "Represent a detector an analyzer can use.",
        "properties": {
          "description": {
            "description": "The description of the detection.",
            "type": "string"
          },
          "group": {
            "description": "The group the detection belongs to.",
            "type": "string"
          },
          "label": {
            "description": "The label returned by the model.",
            "type": "string"
          },
          "name": {
            "description": "The name of the detection.",
            "type": "string"
          },
          "positional": {
            "description": "Tell if the detection is positional.",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "domainhits": {
        "description": "This is a domain hit.",
        "properties": {
          "app": {
            "description": "The name of the application that the domain belongs to.",
            "example": "MyApp",
            "type": "string"
          },
          "component": {
            "description": "The component of the application that the domain belongs to.",
            "example": "frontend",
            "type": "string"
          },
          "domain": {
            "description": "Domain that has been visited.",
            "example": "google.com",
            "type": "string"
          },
          "hits": {
            "description": "The number of hits for this report.",
            "example": 12,
            "type": "integer"
          },
          "suspicious": {
            "description": "Suspicious is true if the service might be a Shadow AI.",
            "type": "boolean"
          }
        },
        "required": [
          "domain",
          "hits"
        ],
        "type": "object"
      },
      "errortransformer": {
        "description": "Used to transform errors before sending them back to the client.",
        "properties": {
          "contentType": {
            "default": "application/json",
            "description": "The Content-Type to use when returning a formatted error.",
            "type": "string"
          },
          "statusCode": {
            "description": "HTTP status code to return, instead of the classical one.",
            "type": "integer"
          },
          "template": {
            "description": "Go template to process and transform the error. The delimiters\nare \u003c\u003c and \u003e\u003e to prevent collision with acuctl templating.\nThe template will be passed the following informations:\n\n- `.Messages`: a list of string containing the messages to return.\n- `.Code`: The original status code.\n- `.TransformedCode`: The transformed status code.\n- `.Action`: The policy decision action (ask or deny).\n\nAll the sprig text function are available.",
            "example": "{\"error\": \"\u003c\u003c .Messages | join \", \" \u003e\u003e\" }",
            "type": "string"
          }
        },
        "type": "object"
      },
      "extraction": {
        "description": "Represents the extracted information to log.",
        "properties": {
          "PIIs": {
            "description": "The PIIs found during classification.\n\nThe current list can be obtained through the analyzers API by searching for\ndetector groups 'PIIs' accross all analyzers.\n\nExample of PIIs detected: aba_routing_number, address, bank_account,\nbitcoin_wallet, credit_card, driver_license, email_address, itin_number,\nlocation, medical_license, money_amount, passport_number, person, phone_number,\nssn.\n\nIf a key is not present in the map that implies that entity was not detected. If\nan entity is detected then the value is a score. Here's how to interpret the\nscores:\n  - confidence: 'low', 0 \u003c score \u003c0.33\n  - confidence: 'medium', 0.33 \u003c= score \u003c 0.66\n  - confidence: 'high', 0.66 \u003c= score \u003c= 1.",
            "example": {
              "ssn": 0.8
            },
            "items": {
              "format": "float",
              "type": "number"
            },
            "type": "object"
          },
          "annotations": {
            "description": "Annotations attached to the extraction.",
            "items": {
              "type": "string"
            },
            "type": "object"
          },
          "categories": {
            "description": "The categories are remapping of the modalities in a more human friendly way.",
            "items": {
              "$ref": "#/components/schemas/modality"
            },
            "type": "array"
          },
          "confidentiality": {
            "description": "The level of general confidentiality of the input.",
            "example": 0.9,
            "type": "number"
          },
          "customDataSets": {
            "description": "The custom data sets found during classification.",
            "example": {
              "cds": {
                "ct1": 1,
                "ct2": 2
              }
            },
            "items": {
              "items": {
                "type": "float"
              },
              "type": "object"
            },
            "type": "object"
          },
          "customDataTypes": {
            "description": "The custom data types found during classification.\n\nIf a key is not present in the map that implies that entity was not detected. If\nan entity is detected then the value is a score. Here's how to interpret the\nscores:\n  - confidence: 'low', 0 \u003c score \u003c0.33\n  - confidence: 'medium', 0.33 \u003c= score \u003c 0.66\n  - confidence: 'high', 0.66 \u003c= score \u003c= 1.",
            "example": {
              "my_cdt": 1
            },
            "items": {
              "format": "float",
              "type": "number"
            },
            "type": "object"
          },
          "data": {
            "description": "The data extracted.",
            "type": "string"
          },
          "detections": {
            "description": "The textual detections found while applying policies.",
            "items": {
              "$ref": "#/components/schemas/textualdetection"
            },
            "type": "array"
          },
          "exploits": {
            "description": "The various exploits attempts.\n\nThe current list can be obtained through the analyzers API by searching for\ndetector groups 'Exploits' accross all analyzers.\n\nExample of exploits detected: jailbreak, prompt_injection, malicious_url.\n\nIf a key is not present in the map that implies that entity was not detected. If\nan entity is detected then the value is a score. Here's how to interpret the\nscores:\n  - confidence: 'low', 0 \u003c score \u003c0.33\n  - confidence: 'medium', 0.33 \u003c= score \u003c 0.66\n  - confidence: 'high', 0.66 \u003c= score \u003c= 1.",
            "example": {
              "prompt_injection": 0.8
            },
            "items": {
              "format": "float",
              "type": "number"
            },
            "type": "object"
          },
          "hash": {
            "description": "The hash of the extraction.",
            "type": "string"
          },
          "intent": {
            "description": "The estimated intent embodied into the text.\n\nThe current list can be obtained through the analyzers API by searching for\ndetector groups 'Intent' accross all analyzers.\n\nExample of intent detected: explain, outline, summarize, write.\n\nIf a key is not present in the map that implies that entity was not detected. If\nan entity is detected then the value is a score. Here's how to interpret the\nscores:\n  - confidence: 'low', 0 \u003c score \u003c0.33\n  - confidence: 'medium', 0.33 \u003c= score \u003c 0.66\n  - confidence: 'high', 0.66 \u003c= score \u003c= 1.",
            "example": {
              "write": 0.8
            },
            "items": {
              "format": "float",
              "type": "number"
            },
            "type": "object"
          },
          "internal": {
            "description": "If true, this extraction is for internal use only. This can be used by agentic\nsystems to mark an extraction as internal only as opposed to user facing.",
            "type": "boolean"
          },
          "isFile": {
            "description": "If true, the data of the extraction is a file.",
            "type": "boolean"
          },
          "isStored": {
            "description": "If true, indicates that the file has been stored.",
            "type": "boolean"
          },
          "keywords": {
            "description": "The keywords found during classification.\n\nIf a key is not present in the map that implies that entity was not detected. If\nan entity is detected then the value is a score. Here's how to interpret the\nscores:\n  - confidence: 'low', 0 \u003c score \u003c0.33\n  - confidence: 'medium', 0.33 \u003c= score \u003c 0.66\n  - confidence: 'high', 0.66 \u003c= score \u003c= 1.",
            "example": {
              "my_keywork": 0.8
            },
            "items": {
              "format": "float",
              "type": "number"
            },
            "type": "object"
          },
          "label": {
            "description": "A means of distinguishing what was extracted, such as prompt, input file or\ncode.",
            "type": "string"
          },
          "languages": {
            "description": "The language of the classification.\n\nThe current list can be obtained through the analyzers API by searching for\ndetector groups 'Languages' accross all analyzers.\n\nExample of languages: chinese, english, french, german, gibberish, japanese,\nrussian, spanish.\n\nIf a key is not present in the map that implies that entity was not detected. If\nan entity is detected then the value is a score. Here's how to interpret the\nscores:\n  - confidence: 'low', 0 \u003c score \u003c0.33\n  - confidence: 'medium', 0.33 \u003c= score \u003c 0.66\n  - confidence: 'high', 0.66 \u003c= score \u003c= 1.",
            "example": {
              "english": 0.8
            },
            "items": {
              "format": "float",
              "type": "number"
            },
            "type": "object"
          },
          "luaID": {
            "description": "An internal field for lua code. it is ignored by the API.",
            "type": "string"
          },
          "malcontents": {
            "description": "The various malcontents attempts.\n\nThe current list can be obtained through the analyzers API by searching for\ndetector groups 'Malcontents' accross all analyzers.\n\nExample of malcontents: biased, harmful, toxic.\n\nIf a key is not present in the map that implies that entity was not detected. If\nan entity is detected then the value is a score. Here's how to interpret the\nscores:\n  - confidence: 'low', 0 \u003c score \u003c0.33\n  - confidence: 'medium', 0.33 \u003c= score \u003c 0.66\n  - confidence: 'high', 0.66 \u003c= score \u003c= 1.",
            "example": {
              "toxic": 0.8
            },
            "items": {
              "format": "float",
              "type": "number"
            },
            "type": "object"
          },
          "modalities": {
            "description": "The modalities of data detected in the data.",
            "items": {
              "$ref": "#/components/schemas/modality"
            },
            "type": "array"
          },
          "relevance": {
            "description": "The level of general organization relevance of the input.\n\nIf a key is not present in the map that implies that entity was not detected. If\nan entity is detected then the value is a score. Here's how to interpret the\nscores:\n  - confidence: 'low', 0 \u003c score \u003c0.33\n  - confidence: 'medium', 0.33 \u003c= score \u003c 0.66\n  - confidence: 'high', 0.66 \u003c= score \u003c= 1.",
            "example": 0.9,
            "type": "number"
          },
          "secrets": {
            "description": "The secrets found during classification.\n\nThe current list can be obtained through the analyzers API by searching for\ndetector groups 'Secrets' accross all analyzers.\n\nExample of secrets: adafruit, alibaba, anthropic, apideck, apify, atlassian,\naws_secret_key, buildkite, checkout, clickuppersonal, contentfulpersonalaccess,\ncredentials, database_url_with_credentials, databricks, denodeploy, dfuse,\ndigitalocean, discord_webhook, docker_hub, doppler, dropbox, endorlabs,\nfleetbase, flutterwave, frameio, freshdesk, fullstory, github, gitlab,\ngocardless, google_api, grafana, groq, huggingface, intra42, jwt, klaviyo,\nlaunchdarkly, linearapi, locationiq, mailchimp, mailgun, mapbox, maxmind,\nmicrosoft_teams_webhook, nightfall, notion, npm, openai, otp_auth_url, pagarme,\npaystack, planetscale, planetscaledb, portainer, posthog, postman, prefect,\nprivate_key, pubnub_publish, pubnub_subscribe, pulumi, ramp, razorpay, readme,\nrechargepayments, replicate, rubygems, salesforce, sendgrid, sendinblue,\nshopify, slack_access, slack_bot, slack_refresh, slack_user, slack_webhook,\nslack_workflow_webhook, sourcegraph, sourcegraphcody, squareapp, squareup,\nstripe, supabase, tailscale, tines_webhook, trufflehog, twilio, ubidots,\nvoiceflow, web_url_with_credentials, zapierwebhook.\n\nIf a key is not present in the map that implies that entity was not detected. If\nan entity is detected then the value is a score. Here's how to interpret the\nscores:\n  - confidence: 'low', 0 \u003c score \u003c0.33\n  - confidence: 'medium', 0.33 \u003c= score \u003c 0.66\n  - confidence: 'high', 0.66 \u003c= score \u003c= 1.",
            "example": {
              "credentials": 0.7
            },
            "items": {
              "format": "float",
              "type": "number"
            },
            "type": "object"
          },
          "topics": {
            "description": "The topic of the classification.\n\nThe current list can be obtained through the analyzers API, with the following\nconditions:\n  1. Includes all analyzers EXCEPT those in the 'Modality' group\n  2. Includes all analyzer detectors EXCEPT those in these groups:\n    - 'Secrets'\n    - 'Exploits'\n    - 'Intent'\n    - 'PIIs'\n    - 'Malcontents'\n\nExample of topics: category/enterprise, category/healthcare, category/medical,\ncategory/personal, contains/blank_image, contains/certificate_signing_request,\ncontains/database_url, contains/handwritten_text, contains/printed_text,\ncontains/public_key, contains/ssh_public_key, contains/web_url,\ndecoded/base32_data, decoded/base58_data, decoded/base64_data,\ndecoded/base64_url_data, decoded/base85_data, decoded/hexadecimal_data,\ndecoded/puny_code_data, decoded/quoted_printable_data,\ndecoded/url_encoding_data, department/compliance, department/cybersecurity,\ndepartment/finance, department/human_resources,\ndepartment/information_technology, department/legal, department/logistics,\ndepartment/marketing, department/performance_evaluation,\ndepartment/product_management, department/project_management, department/sales,\ndepartment/strategy, department/support, depict/check, depict/code,\ndepict/document, depict/unclassified, depict/whiteboard, domain/commercial,\ndomain/development, domain/financial, domain/general, domain/regulatory,\ndomain/workforce, extracted/csv_cell_content, extracted/document_text_content,\nextracted/handwritten_text_content, extracted/pdf_text_content,\nextracted/pptx_text_content, extracted/spreadsheet_text_content,\nextracted/typed_text_content, timeframe/current_year, timeframe/future,\ntimeframe/last_year, timeframe/next_year, timeframe/past,\ntranscribed/audio_text_content.\n\nIf a key is not present in the map that implies that entity was not detected. If\nan entity is detected then the value is a score. Here's how to interpret the\nscores:\n  - confidence: 'low', 0 \u003c score \u003c0.33\n  - confidence: 'medium', 0.33 \u003c= score \u003c 0.66\n  - confidence: 'high', 0.66 \u003c= score \u003c= 1.",
            "example": {
              "category/enterprise": 0.7,
              "department/logistics": 0.8,
              "depict/document": 0.8,
              "extracted/typed_text_content": 1,
              "timeframe/current_year": 0.6
            },
            "items": {
              "format": "float",
              "type": "number"
            },
            "type": "object"
          }
        },
        "type": "object"
      },
      "extractioninformation": {
        "description": "Represents extracted information.",
        "properties": {
          "n": {
            "description": "The number of times it has been seen.",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "extractionsummary": {
        "description": "Represents the summary of the extractions.",
        "properties": {
          "PIIs": {
            "additionalProperties": true,
            "description": "The PIIs found during classification.",
            "type": "object"
          },
          "categories": {
            "additionalProperties": true,
            "description": "The categories are remapping of the modalities in a more human friendly way.",
            "type": "object"
          },
          "customDataSets": {
            "additionalProperties": true,
            "description": "The data sets.",
            "type": "object"
          },
          "customDataTypes": {
            "additionalProperties": true,
            "description": "The data types.",
            "type": "object"
          },
          "exploits": {
            "additionalProperties": true,
            "description": "The various exploits attempts.",
            "type": "object"
          },
          "intent": {
            "additionalProperties": true,
            "description": "The estimated intent embodied into the text.",
            "type": "object"
          },
          "keywords": {
            "additionalProperties": true,
            "description": "The keywords found during classification.",
            "type": "object"
          },
          "languages": {
            "additionalProperties": true,
            "description": "The language of the classification.",
            "type": "object"
          },
          "malcontents": {
            "additionalProperties": true,
            "description": "The various malcontents attempts.",
            "type": "object"
          },
          "modalities": {
            "additionalProperties": true,
            "description": "The modalities of data detected in the data.",
            "type": "object"
          },
          "secrets": {
            "additionalProperties": true,
            "description": "The secrets found during classification.",
            "type": "object"
          },
          "topics": {
            "additionalProperties": true,
            "description": "The topic of the classification.",
            "type": "object"
          }
        },
        "type": "object"
      },
      "extractor": {
        "description": "An extractor allows to create a reusable extractor for providers.",
        "properties": {
          "ID": {
            "description": "ID is the identifier of the object.",
            "readOnly": true,
            "type": "string"
          },
          "SSEManagement": {
            "default": "Collect",
            "description": "This property defines how you want the extractor to work with\nserver-side events. With Collect all the events buffer until the server\ncloses the connection and sends the entire data to the lua code\nwhile Stream will collect line by line and will send events line by line.",
            "enum": [
              "Collect",
              "Stream"
            ]
          },
          "analyzers": {
            "description": "The analyzers parameter allows for customizing which analyzers should be used,\noverriding the default selection. Each analyzer entry can optionally include a\nprefix to modify its behavior:\n\n  - No prefix: Runs only the specified analyzers and any dependencies required\nfor deeper analyzis (slower but more acurate).\n  - '+' (enable): Activates an analyzer that is disabled by default.\n  - '-' (disable): Disables an analyzer that is enabled by default.\n  - '@' (direct execution): Runs the analyzer immediately, bypassing the deeper\nanalyzis (faster but less acurate).\n\nAn analyzers entry can be specified using:\n  - The analyzer name (e.g., 'Toxicity detector')\n  - The analyzer ID (e.g., 'en-text-toxicity-detector')\n  - The analyzer group (e.g., 'Detectors')\n  - A detector name (e.g., 'toxic')\n  - A detector label (e.g., 'insult')\n  - A detector group (e.g., 'Malcontents')\n\nIf left empty, all default analyzers will be executed.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "anonymization": {
            "default": "FixedSize",
            "description": "How to anonymize the data. If deanonymize is true, then VariablSize is required.",
            "enum": [
              "FixedSize",
              "VariableSize"
            ]
          },
          "behavior": {
            "default": "Popup",
            "description": "Defines how to handle error in the case of a webpage. If set to Popup, the error\nwill be shown in a popup. If throw, a javascript error will be returned.",
            "enum": [
              "Popup",
              "Throw",
              "Ignore"
            ]
          },
          "block": {
            "default": "Allow",
            "description": "Block the request to the provider if not Allow. If Before, the data will be\nblocked before running any extraction or analyzis. If After block the request\nafter analysizis.",
            "enum": [
              "Allow",
              "Before",
              "After"
            ]
          },
          "cancelBehavior": {
            "default": "Block",
            "description": "The behavior to take when cancel is chosen from the popup.",
            "enum": [
              "Block",
              "SendRedacted"
            ]
          },
          "createTime": {
            "description": "Creation date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          },
          "deanonymize": {
            "description": "If true, deanonymize the redacted data. This has no effects on streaming output.",
            "type": "boolean"
          },
          "description": {
            "description": "The description of the provider.",
            "type": "string"
          },
          "honorPriorDecision": {
            "description": "If true, it will wait on a prior popup and honor its decision. It only has\neffect if there is an existing popup being shown.",
            "type": "boolean"
          },
          "ignore": {
            "description": "If true, the analysis will run, but nothing will be logged.",
            "type": "boolean"
          },
          "importHash": {
            "description": "The hash of the structure used to compare with new import version.",
            "type": "string"
          },
          "importLabel": {
            "description": "The user-defined import label that allows the system to group resources from the\nsame import operation.",
            "type": "string"
          },
          "method": {
            "description": "The method to match.",
            "enum": [
              "Post",
              "Put",
              "Patch",
              "Get",
              "Delete",
              "Options",
              "Head"
            ],
            "example": [
              "Post"
            ]
          },
          "name": {
            "description": "The internal reference name of the object.",
            "example": "my-extractor",
            "type": "string"
          },
          "namespace": {
            "description": "The namespace of the object.",
            "readOnly": true,
            "type": "string"
          },
          "path": {
            "description": "A regular expression to match a URL path to log.",
            "example": [
              "/api/v1",
              "/v1/*/hello/*"
            ],
            "type": "string"
          },
          "propagate": {
            "default": true,
            "description": "Propagates the object to all child namespaces. This is always true.",
            "type": "boolean"
          },
          "script": {
            "description": "If not empty, use this lua code to run the extraction.",
            "type": "string"
          },
          "type": {
            "description": "The type of extractor.",
            "enum": [
              "Input",
              "Output"
            ],
            "example": "Input"
          },
          "updateTime": {
            "description": "Last update date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          }
        },
        "required": [
          "method",
          "name",
          "path",
          "type"
        ],
        "type": "object"
      },
      "extractorref": {
        "description": "This object allows to either define an extractor for the provider, or to\nreference an existing extractor from database.",
        "properties": {
          "def": {
            "$ref": "#/components/schemas/extractor"
          },
          "hosts": {
            "description": "Optional hosts to match. This is useful in case the provider has multiple hosts\nto discriminate which logger to use.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "ref": {
            "description": "References a preexisting extractor definition.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "feedback": {
        "description": "Feedbacks from user regarding analysis decisions.",
        "properties": {
          "ID": {
            "description": "ID is the identifier of the object.",
            "readOnly": true,
            "type": "string"
          },
          "comment": {
            "description": "General comments on the feedback.",
            "type": "string"
          },
          "createTime": {
            "description": "Creation date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          },
          "key": {
            "description": "The key of the feedback.",
            "example": "pii:emailid",
            "type": "string"
          },
          "logHash": {
            "description": "The hash of the log.",
            "example": 4449147649844796362,
            "type": "string"
          },
          "logUnixNano": {
            "description": "The timestamp of the log.",
            "example": 1741797027131412000,
            "type": "string"
          },
          "namespace": {
            "description": "The namespace of the object.",
            "readOnly": true,
            "type": "string"
          },
          "principal": {
            "$ref": "#/components/schemas/principal"
          },
          "provider": {
            "description": "The provider of the feedback.",
            "example": "openai",
            "type": "string"
          },
          "score": {
            "description": "The feedback score (+1 for upvote, -1 for downvote).",
            "type": "integer"
          },
          "status": {
            "default": "New",
            "description": "The status of the feedback.",
            "enum": [
              "New",
              "Investigating",
              "Confirmed",
              "Rejected"
            ]
          },
          "updateTime": {
            "description": "Last update date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          },
          "value": {
            "description": "The value of the feedback.",
            "example": "tester@acuvity.ai",
            "type": "string"
          }
        },
        "required": [
          "key",
          "logHash",
          "logUnixNano",
          "principal",
          "provider",
          "status",
          "value"
        ],
        "type": "object"
      },
      "gitbooktoken": {
        "description": "Allows to exchange an Acuvity token for a token signed for our documentation.",
        "properties": {
          "token": {
            "description": "The token to access gitbook. This is not a valid acuvity token.",
            "readOnly": true,
            "type": "string"
          }
        },
        "type": "object"
      },
      "host": {
        "description": "This is node definition.",
        "properties": {
          "disableFingerprintingResistance": {
            "description": "Disable Apex routines to try to mimic client's tls handshake signature. You\nprobably want this on.",
            "type": "boolean"
          },
          "name": {
            "description": "The hostname.",
            "example": "chat.openai.com",
            "type": "string"
          },
          "prefix": {
            "description": "URL prefix for additional matching.",
            "type": "string"
          },
          "proxyLabel": {
            "description": "The proxy label to use to exit to this host.",
            "example": "default",
            "type": "string"
          }
        },
        "required": [
          "name"
        ],
        "type": "object"
      },
      "ignoreddomain": {
        "description": "Defines an ignored domain to be excluded from investigation.",
        "properties": {
          "ID": {
            "description": "ID is the identifier of the object.",
            "readOnly": true,
            "type": "string"
          },
          "createTime": {
            "description": "Creation date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          },
          "domain": {
            "description": "The domain to ignore.",
            "example": "linkedin.com",
            "type": "string"
          },
          "importHash": {
            "description": "The hash of the structure used to compare with new import version.",
            "type": "string"
          },
          "importLabel": {
            "description": "The user-defined import label that allows the system to group resources from the\nsame import operation.",
            "type": "string"
          },
          "namespace": {
            "description": "The namespace of the object.",
            "readOnly": true,
            "type": "string"
          },
          "propagate": {
            "default": true,
            "description": "Propagates the object to all child namespaces. This is always true.",
            "type": "boolean"
          },
          "updateTime": {
            "description": "Last update date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          }
        },
        "required": [
          "domain"
        ],
        "type": "object"
      },
      "import": {
        "description": "Import multiple resource at once.",
        "properties": {
          "AIDomains": {
            "description": "AI domains to import.",
            "items": {
              "$ref": "#/components/schemas/aidomain"
            },
            "type": "array"
          },
          "APIAuthorizations": {
            "description": "APIAuthorizations to import.",
            "items": {
              "$ref": "#/components/schemas/apiauthorization"
            },
            "type": "array"
          },
          "PACConfigs": {
            "description": "PACConfigs to import.",
            "items": {
              "$ref": "#/components/schemas/pacconfig"
            },
            "type": "array"
          },
          "accessPolicies": {
            "description": "Access policies to import.",
            "items": {
              "$ref": "#/components/schemas/accesspolicy"
            },
            "type": "array"
          },
          "agentConfigs": {
            "description": "Agent configurations to import.",
            "items": {
              "$ref": "#/components/schemas/agentconfig"
            },
            "type": "array"
          },
          "alertDefinitions": {
            "description": "Alert definitions to import.",
            "items": {
              "$ref": "#/components/schemas/alertdefinition"
            },
            "type": "array"
          },
          "apps": {
            "description": "Apps to import.",
            "items": {
              "$ref": "#/components/schemas/app"
            },
            "type": "array"
          },
          "contentPolicies": {
            "description": "Content policies to import.",
            "items": {
              "$ref": "#/components/schemas/contentpolicy"
            },
            "type": "array"
          },
          "customDataSets": {
            "description": "Custom Data Sets to import.",
            "items": {
              "$ref": "#/components/schemas/customdataset"
            },
            "type": "array"
          },
          "customDataTypes": {
            "description": "Custom Data Types to import.",
            "items": {
              "$ref": "#/components/schemas/customdatatype"
            },
            "type": "array"
          },
          "extractors": {
            "description": "Extractors to import.",
            "items": {
              "$ref": "#/components/schemas/extractor"
            },
            "type": "array"
          },
          "ignoredDomains": {
            "description": "Ignored domains to import.",
            "items": {
              "$ref": "#/components/schemas/ignoreddomain"
            },
            "type": "array"
          },
          "label": {
            "description": "Import label that will be used to identify all the resources imported by this\nresource.",
            "example": "my-super-import",
            "type": "string"
          },
          "orgSettings": {
            "description": "OrgSettings to import.",
            "items": {
              "$ref": "#/components/schemas/orgsettings"
            },
            "type": "array"
          },
          "providerTeams": {
            "description": "Provider teams to import.",
            "items": {
              "$ref": "#/components/schemas/providerteam"
            },
            "type": "array"
          },
          "providerTokens": {
            "description": "ProviderTokens to import.",
            "items": {
              "$ref": "#/components/schemas/providertoken"
            },
            "type": "array"
          },
          "providers": {
            "description": "Providers to import.",
            "items": {
              "$ref": "#/components/schemas/provider"
            },
            "type": "array"
          },
          "proxyroundtrips": {
            "description": "Proxy roundtrip to import. This will populate dummy data.",
            "items": {
              "$ref": "#/components/schemas/proxyroundtrip"
            },
            "type": "array"
          },
          "sinks": {
            "description": "Sinks to import.",
            "items": {
              "$ref": "#/components/schemas/sink"
            },
            "type": "array"
          },
          "teams": {
            "description": "Teams to import.",
            "items": {
              "$ref": "#/components/schemas/team"
            },
            "type": "array"
          },
          "visitedurls": {
            "description": "Visited URLs to import.",
            "items": {
              "$ref": "#/components/schemas/visitedurl"
            },
            "type": "array"
          },
          "webExtensionConfigs": {
            "description": "Web Extension configurations to import.",
            "items": {
              "$ref": "#/components/schemas/webextensionconfig"
            },
            "type": "array"
          }
        },
        "required": [
          "label"
        ],
        "type": "object"
      },
      "ingressproviderconfig": {
        "description": "Represents the configuration if an apex is to act as an ingress for a provider.",
        "properties": {
          "dialTLS": {
            "default": "Preserve",
            "description": "This option controls the dialing behaviour of the apex to the origin server.\nShould be explicitly set to enabled if the origin expects TLS connections. And\nvice versa it should be set to disabled if the origin expects connections in\nplaintext. By default this setting is set to preserve which means that the apex\nis going to dial using whatever mode it terminated its own connection with: if\nthe apex received a TLS connection, it will dial TLS, if it received a plaintext\nconnection, then it will dial plaintext. The apex receiving behaviour can be\ncontrolled with the listenTLS option. As a last resort this setting can be set\nto auto which means that the apex is going to probe the origin server to\ndetermine if it needs to dial using TLS or not. Note that this is potentially\nsending a TLS Client Hello to a plaintext HTTP server which is not expecting\nthat. Therefore, this option is not recommended if it can be avoided. This\nsetting is ignored in mirror mode.",
            "enum": [
              "Preserve",
              "Auto",
              "Enabled",
              "Disabled"
            ],
            "example": "Enabled"
          },
          "listenPort": {
            "description": "The listening port. For appcomponent configurations this is the listening port\nthat traffic will be intercepted on or mirrored from.",
            "example": 8443,
            "type": "integer"
          },
          "listenTLS": {
            "default": "Auto",
            "description": "This option controls the receiving behaviour of connection to the apex before\nthey are going to be proxied to the origin server. To control the dialing\nbehaviour of the apex towards the origin server use the dialTLS option. Should\nbe explicitly set to enabled if the listener expects TLS connections. And vice\nversa it should be set to disabled if the listener expects connections in\nplaintext. By default this setting is set to auto which means that the listener\nwill automatically determine if incoming connections are TLS or not: TLS\nconnections will be accepted, as well as  plain TCP connections will be\naccepted, both on the configured listenPort. This setting is ignored in mirror\nmode.",
            "enum": [
              "Auto",
              "Enabled",
              "Disabled"
            ],
            "example": "Enabled"
          },
          "listenTLSCert": {
            "description": "Optional PEM encoded X509v3 certificate to use for the listener for this\nprovider. This setting will be ignored if listenMode is not TLS or Auto or mode\nis not Inline. However, this setting is required if listenTLSKey is set.",
            "example": "-----BEGIN CERTIFICATE-----\nMIIF...\n...\n-----END CERTIFICATE-----",
            "type": "string"
          },
          "listenTLSKey": {
            "description": "Optional PEM encoded key pair to use for the listener for this provider. This\nsetting will be ignored if listenMode is not TLS or Auto or mode is not Inline.\nHowever, this setting is required if listenTLSCert is set.",
            "example": "-----BEGIN EC PRIVATE KEY-----\nMHcCA...\n...\n-----END EC PRIVATE KEY-----",
            "type": "string"
          },
          "mode": {
            "default": "Disabled",
            "description": "The ingress datapath mode to use for network traffic arriving for this ingress\nprovider for this application component. By default this is set to disabled.\nHowever, this can be changed to mirror traffic where the Apex is only providing\nvisibility with no possibility of any access or content policies to take effect.\nOr this can be set to inline in which case all traffic to providers will be\nredirected to the Apex which acts as a transparent proxy in this case. In this\nmode access and content policies will take effect.",
            "enum": [
              "Disabled",
              "Mirror",
              "Inline"
            ],
            "example": "Inline"
          }
        },
        "required": [
          "listenPort"
        ],
        "type": "object"
      },
      "injector": {
        "description": "TODO.",
        "properties": {
          "delayXHRPatching": {
            "description": "Since JS world is the mess we all know, there are some cases when we must delay\nthe monkey patching of the XHR request.",
            "type": "boolean"
          },
          "hosts": {
            "description": "Optional hosts to match. This is useful in case the provider has multiple hosts\nto discriminate which logger to use.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "method": {
            "description": "The method to match.",
            "enum": [
              "Post",
              "Put",
              "Patch",
              "Get",
              "Delete",
              "Options",
              "Head"
            ],
            "example": [
              "Post"
            ]
          },
          "path": {
            "description": "A regular expression to match a URL path to log.",
            "example": [
              "/api/v1",
              "/v1/*/hello/*"
            ],
            "type": "string"
          }
        },
        "required": [
          "method",
          "path"
        ],
        "type": "object"
      },
      "labelvalue": {
        "description": "Get all values for a given label.",
        "properties": {
          "ID": {
            "description": "ID is the identifier of the object.",
            "readOnly": true,
            "type": "string"
          },
          "end": {
            "description": "The end of the time window in any format supported by\nhttps://github.com/araddon/dateparse.",
            "example": "May 8, 2009 5:57:51 PM",
            "type": "string"
          },
          "endRelative": {
            "description": "The relative end of the time window as time.Duration.",
            "example": "10h",
            "type": "string"
          },
          "label": {
            "description": "The label to retrieve all available the values for.",
            "example": [
              "decision"
            ],
            "type": "string"
          },
          "namespace": {
            "description": "The namespace of the object.",
            "readOnly": true,
            "type": "string"
          },
          "query": {
            "description": "A set of log stream selector that selects the streams to match and return label\nvalues for.",
            "example": "{\"app\": \"myapp\", \"environment\": \"dev\"}",
            "type": "string"
          },
          "result": {
            "description": "The result of the request.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "start": {
            "description": "The start of the time window in any format supported by\nhttps://github.com/araddon/dateparse.",
            "example": 1700083708672317036,
            "type": "string"
          },
          "startRelative": {
            "description": "The relative start of the time window as time.Duration.",
            "example": "10h",
            "type": "string"
          }
        },
        "required": [
          "label"
        ],
        "type": "object"
      },
      "landing": {
        "description": "Potential Landing namespaces based on permissions.",
        "properties": {
          "ID": {
            "description": "The identifier of the landing.",
            "type": "string"
          },
          "permissions": {
            "additionalProperties": {
              "additionalProperties": {
                "type": "boolean"
              },
              "type": "object"
            },
            "description": "The permissions for the landing type.",
            "type": "object"
          },
          "type": {
            "description": "Type of access.",
            "enum": [
              "Apps",
              "Employees",
              "All"
            ]
          }
        },
        "type": "object"
      },
      "latency": {
        "description": "Holds information about latencies introduced by Apex.",
        "properties": {
          "accessPolicy": {
            "description": "How much time it took to run the access policy in nanoseconds.",
            "type": "integer"
          },
          "analysis": {
            "description": "How much time it took to run content analysis in nanoseconds.",
            "type": "integer"
          },
          "assignPolicy": {
            "description": "How much time it took to run the assign policy in nanoseconds.",
            "type": "integer"
          },
          "contentPolicy": {
            "description": "How much time it took to run content policy in nanoseconds.",
            "type": "integer"
          },
          "extraction": {
            "description": "How much time it took to run input or output extraction in nanoseconds.",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "mapper": {
        "description": "TODO.",
        "properties": {
          "expiration": {
            "default": "1h",
            "description": "Set how long the data should be cached.",
            "type": "string"
          },
          "hosts": {
            "description": "Optional hosts to match. This is useful in case the provider has multiple hosts\nto discriminate which logger to use.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "method": {
            "description": "The method to match.",
            "enum": [
              "Post",
              "Put",
              "Patch",
              "Get",
              "Delete",
              "Options",
              "Head"
            ],
            "example": [
              "Post"
            ]
          },
          "name": {
            "description": "The name of the extractor. It will be used to identify which extractor was used\nduring an extraction.",
            "type": "string"
          },
          "path": {
            "description": "A regular expression to match a URL path to log.",
            "example": [
              "/api/v1",
              "/v1/*/hello/*"
            ],
            "type": "string"
          },
          "script": {
            "description": "If not empty, use this lua code to run the extraction.",
            "type": "string"
          }
        },
        "required": [
          "method",
          "path"
        ],
        "type": "object"
      },
      "metric": {
        "description": "This is a metric stored in Mimir.",
        "properties": {
          "ID": {
            "description": "ID is the identifier of the object.",
            "readOnly": true,
            "type": "string"
          },
          "namespace": {
            "description": "The namespace of the object.",
            "readOnly": true,
            "type": "string"
          },
          "query": {
            "description": "The query in Prometheus query format.",
            "example": [
              "sample_metric{environment=\"production\"}"
            ],
            "type": "string"
          },
          "result": {
            "description": "The result of the request.",
            "items": {
              "type": "object"
            },
            "type": "array"
          },
          "resultType": {
            "description": "The type of the result.",
            "type": "string"
          },
          "time": {
            "description": "The time for the query in any format supported by\nhttps://github.com/araddon/dateparse.",
            "example": 1700083708672317036,
            "type": "string"
          },
          "timeRelative": {
            "description": "The relative time of the time window as time.Duration.",
            "example": "10h",
            "type": "string"
          }
        },
        "required": [
          "query"
        ],
        "type": "object"
      },
      "metriclabelvalue": {
        "description": "Get all metric values for a given label.",
        "properties": {
          "ID": {
            "description": "ID is the identifier of the object.",
            "readOnly": true,
            "type": "string"
          },
          "end": {
            "description": "The end of the time window in any format supported by\nhttps://github.com/araddon/dateparse.",
            "example": "May 8, 2009 5:57:51 PM",
            "type": "string"
          },
          "endRelative": {
            "description": "The relative end of the time window as time.Duration.",
            "example": "10h",
            "type": "string"
          },
          "label": {
            "description": "The label to retrieve all available values for.",
            "example": [
              "decision"
            ],
            "type": "string"
          },
          "limit": {
            "default": 100,
            "description": "The max number of results to return.",
            "type": "integer"
          },
          "namespace": {
            "description": "The namespace of the object.",
            "readOnly": true,
            "type": "string"
          },
          "query": {
            "description": "A set of metric stream selectors that selects the streams to match and return\nlabel values for.",
            "example": "{\"app\": \"myapp\", \"environment\": \"dev\"}",
            "type": "string"
          },
          "result": {
            "description": "The result of the request.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "start": {
            "description": "The start of the time window in any format supported by\nhttps://github.com/araddon/dateparse.",
            "example": 1700083708672317036,
            "type": "string"
          },
          "startRelative": {
            "description": "The relative start of the time window as time.Duration.",
            "example": "10h",
            "type": "string"
          }
        },
        "required": [
          "label"
        ],
        "type": "object"
      },
      "metricrange": {
        "description": "This is a metric range stored in Mimir.",
        "properties": {
          "ID": {
            "description": "ID is the identifier of the object.",
            "readOnly": true,
            "type": "string"
          },
          "end": {
            "description": "The end of the time window in any format supported by\nhttps://github.com/araddon/dateparse.",
            "example": "May 8, 2009 5:57:51 PM",
            "type": "string"
          },
          "endRelative": {
            "description": "The relative end of the time window as time.Duration.",
            "example": "10h",
            "type": "string"
          },
          "namespace": {
            "description": "The namespace of the object.",
            "readOnly": true,
            "type": "string"
          },
          "query": {
            "description": "The query in Prometheus query format.",
            "example": [
              "sample_metric{environment=\"production\"}"
            ],
            "type": "string"
          },
          "result": {
            "description": "The result of the request.",
            "items": {
              "type": "object"
            },
            "type": "array"
          },
          "resultType": {
            "description": "The type of the result.",
            "type": "string"
          },
          "start": {
            "description": "The start of the time window in any format supported by\nhttps://github.com/araddon/dateparse.",
            "example": 1700083708672317036,
            "type": "string"
          },
          "startRelative": {
            "description": "The relative start of the time window as time.Duration.",
            "example": "10h",
            "type": "string"
          },
          "step": {
            "default": "15s",
            "description": "The query resolution step width as time.Duration.",
            "type": "string"
          }
        },
        "required": [
          "query"
        ],
        "type": "object"
      },
      "metricserie": {
        "description": "This is a metric serie.",
        "properties": {
          "ID": {
            "description": "ID is the identifier of the object.",
            "readOnly": true,
            "type": "string"
          },
          "end": {
            "description": "The end of the time window in any format supported by\nhttps://github.com/araddon/dateparse.",
            "example": "May 8, 2009 5:57:51 PM",
            "type": "string"
          },
          "endRelative": {
            "description": "The relative end of the time window as time.Duration.",
            "example": "10h",
            "type": "string"
          },
          "limit": {
            "default": 100,
            "description": "The max number of results to return.",
            "type": "integer"
          },
          "namespace": {
            "description": "The namespace of the object.",
            "readOnly": true,
            "type": "string"
          },
          "query": {
            "description": "The query in Prometheus format.",
            "example": [
              "sample_metric{environment=\"production\"}"
            ],
            "type": "string"
          },
          "result": {
            "description": "The result of the request.",
            "items": {
              "type": "object"
            },
            "type": "array"
          },
          "start": {
            "description": "The start of the time window in any format supported by\nhttps://github.com/araddon/dateparse.",
            "example": 1700083708672317036,
            "type": "string"
          },
          "startRelative": {
            "description": "The relative start of the time window as time.Duration.",
            "example": "10h",
            "type": "string"
          }
        },
        "required": [
          "query"
        ],
        "type": "object"
      },
      "modality": {
        "description": "Represents the modality of a some data.",
        "properties": {
          "group": {
            "description": "The group of data.\n\nThe current list can be obtained through the analyzers API by searching for\ndetector groups in the 'Modality' analyzer group.\n\nExample of group: application, archive, audio, code, document, executable, font,\nimage, text, unknown, video.",
            "example": "image",
            "type": "string"
          },
          "type": {
            "description": "The type of data.\n\nThe current list can be obtained through the analyzers API by searching for\ndetector names in the 'Modality' analyzer group.\n\nExample of type: 3dsm, 3gp, 3mf, ace, ada, ai, apk, applebplist, appleplist, ar,\narc, arj, asc, asf, asm, asp, au, autohotkey, autoit, avi, avif, awk, ax, batch,\nbazel, bcad, bib, bmp, bpg, brainfuck, brf, bzip, bzip3, c, cab, cat, cdf, chm,\nclojure, cmake, cobol, coff, coffeescript, com, cpl, cpp, crt, crx, cs, csproj,\ncss, csv, dart, deb, dex, dey, dicom, diff, django, dll, dm, dmg, dmigd,\ndmscript, doc, dockerfile, docx, dotx, dwg, dxf, dylib, elf, elixir, emf, eml,\nepub, erb, erlang, exe, flac, flv, fortran, fpx, gemfile, gemspec, gif,\ngitattributes, gitmodules, gleam, go, gradle, groovy, gzip, h, h5, handlebars,\nhaskell, hcl, heif, hlp, hpp, hta, htaccess, html, hwp, icns, ico, ics,\nignorefile, ini, internetshortcut, ipynb, iso, jar, java, javabytecode,\njavascript, jinja, jng, jnlp, jp2, jpeg, json, jsonl, jsx, julia, jxl, ko,\nkotlin, latex, lha, license, lisp, lnk, lock, lua, lz, lz4, m3u, m4, macho,\nmakefile, markdown, matlab, mht, midi, mkv, mp3, mp4, mpegts, mscompress, msi,\nmsix, mui, mum, npy, npz, objectivec, ocaml, ocx, odex, odin, odp, ods, odt,\nogg, one, onnx, otf, outlook, pascal, pcap, pdb, pdf, pebin, pem, perl, php,\npickle, png, po, postscript, powershell, ppt, pptx, prolog, proteindb, proto,\npsd, python, pythonbytecode, pytorch, qoi, qt, r, randomascii, rar, rdf, rlib,\nrll, rpm, rst, rtf, ruby, rust, scala, scheme, scr, scss, sevenzip, sgml, shell,\nsmali, snap, so, solidity, sql, sqlite, squashfs, srt, stlbinary, stltext, sum,\nsvg, swf, swift, symlinktext, sys, tar, tcl, textproto, tga, thumbsdb, tiff,\ntoml, torrent, tsv, tsx, ttf, twig, txt, txtascii, txtutf16, txtutf8,\ntypescript, vba, vbe, vcxproj, verilog, vhdl, visio, vtt, vue, wad, wasm, wav,\nwebm, webp, webtemplate, winregistry, wma, wmf, wmv, woff, woff2, xar, xcf, xls,\nxlsb, xlsx, xml, xpi, xz, yaml, yara, zig, zip, zlibstream, zst.",
            "example": "png",
            "type": "string"
          }
        },
        "required": [
          "group",
          "type"
        ],
        "type": "object"
      },
      "moderation": {
        "description": "Represents a moderation to take in the content policy.",
        "properties": {
          "action": {
            "description": "The actual action to take when triggered.",
            "enum": [
              "Warn",
              "Block",
              "None"
            ],
            "example": "Warn"
          },
          "alertDefinition": {
            "description": "The definition to use for alerting.",
            "type": "string"
          },
          "link": {
            "description": "Sets an optional link to reference a document with more explanation on the\nmoderation.",
            "example": "https://acme.com/policy/aiusage",
            "type": "string"
          },
          "message": {
            "description": "The message if the moderation action is warn or block.",
            "example": "This is not safe for work place (NSFW)",
            "type": "string"
          },
          "predicates": {
            "description": "The predicate expression for the moderation to be triggered.",
            "items": {
              "$ref": "#/components/schemas/predicate"
            },
            "type": "array"
          },
          "redact": {
            "description": "If true, redacts the keywords, PIIs, and/or secrets defined in the predicates.",
            "type": "boolean"
          }
        },
        "required": [
          "action"
        ],
        "type": "object"
      },
      "orgsettings": {
        "description": "Manage the default settings for the entire organization.",
        "properties": {
          "CA": {
            "description": "The Certificate authority to use to validate user certificates in PEM format.",
            "example": "-----BEGIN CERTIFICATE-----\nMIIBZTCCAQugAwIBAgIRANYvXLTa16Ykvc9hQ4BBLJEwCgYIKoZIzj0EAwIwEjEQ\nMA4GA1UEAxMHQUNNRSBDQTAeFw0yMTExMDEyMzAwMTlaFw0zMTA5MTAyMzAwMTla\nMBIxEDAOBgNVBAMTB0FDTUUgQ0EwWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAASa\n7wknroxwB1znupZ67NzTG9Kuc+tNRlbI22eTDNMKYpIexzWDOyiQ95N3GQIdmAz5\nwVu9l2V3VuKUpD9mNgkRo0IwQDAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUw\nAwEB/zAdBgNVHQ4EFgQURIT2kL76vMj9A3r9AUnaiHnHf4EwCgYIKoZIzj0EAwID\nSAAwRQIgS4SGaJ/B1Ul88Jal11Q5BwiY9bY2y9w+4xPNBxSyAIcCIQCSWVq+00xS\nbOmROq+EsxO4L/GzJx7MBbeJ6x142VKSBQ==\n-----END CERTIFICATE-----",
            "type": "string"
          },
          "CACommonNames": {
            "description": "The currently used Certificate authorities's Common Name.",
            "items": {
              "type": "string"
            },
            "readOnly": true,
            "type": "array"
          },
          "ID": {
            "description": "ID is the identifier of the object.",
            "readOnly": true,
            "type": "string"
          },
          "accessPolicy": {
            "description": "The rego policy that decides if the incoming request can access the\nprovider. If this empty, the dynamic policy transpiled from\nAccessPolicies API objects will be used by Apexes. If set however,\neverything computed by API objects are ignored and this becomes the final\npolicy.",
            "type": "string"
          },
          "allowSupportAccess": {
            "description": "When enabled, an API authorization will be created in your\norganization to allow the Support Team to access your organization in\nread-only fashion to help you with any issue you might have.\nDisable it again to remove the permissions.",
            "type": "boolean"
          },
          "askConsent": {
            "description": "Ask the user of web applications for consent before accessing a monitored\nprovider, using an html splash screen the first time they connect. If\nthis is not set, the users of the providers can still figure out the\nprovider is monitored. This is a courtesy and not a security feature.",
            "type": "boolean"
          },
          "assignPolicy": {
            "description": "The rego policy that decides in which team an user should be in. The team\nwill be passed to the accessPolicy. If this empty, the dynamic policy\ntranspiled from AssignPolicies API objects will be used by Apexes. If set\nhowever, everything computed by API objects are ignored and this becomes\nthe final policy.",
            "type": "string"
          },
          "contentPolicy": {
            "description": "The policy that decides how to handle the request content, once access\nhas been granted by accessPolicy and the content analysis was performed.\nIf this empty, the dynamic policy transpiled from AccessPolicies API\nobjects will be used by Apexes. If set however, everything computed by\nAPI objects are ignored and this becomes the final policy.",
            "type": "string"
          },
          "createTime": {
            "description": "Creation date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          },
          "disableURLDiscovery": {
            "description": "If true, it disables discovering of the visited URLs.",
            "type": "boolean"
          },
          "fingerprints": {
            "description": "the fingerprint of the cas in the chain.",
            "items": {
              "type": "string"
            },
            "readOnly": true,
            "type": "array"
          },
          "importHash": {
            "description": "The hash of the structure used to compare with new import version.",
            "type": "string"
          },
          "importLabel": {
            "description": "The user-defined import label that allows the system to group resources from the\nsame import operation.",
            "type": "string"
          },
          "namespace": {
            "description": "The namespace of the object.",
            "readOnly": true,
            "type": "string"
          },
          "profile": {
            "description": "A few sentences about the organization. The description must be short\nand detailed. It will be used by the inference engine to decide if the content\nsent by the users are relevant to your company.",
            "example": "Acme Corp is a publicly traded company specialized in car manufacturing.",
            "type": "string"
          },
          "propagate": {
            "default": true,
            "description": "Propagates the object to all child namespaces. This is always true.",
            "type": "boolean"
          },
          "storeInputFiles": {
            "description": "If set, files uploaded by the users will be stored.",
            "type": "boolean"
          },
          "storeOutputFiles": {
            "description": "If set, files sent to the users will be stored.",
            "type": "boolean"
          },
          "subjectKeyIDs": {
            "description": "the IDs of the subject keys of the cas in the chain.",
            "items": {
              "type": "string"
            },
            "readOnly": true,
            "type": "array"
          },
          "updateTime": {
            "description": "Last update date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          },
          "useRegoCodeOnly": {
            "description": "If true, it uses Rego code to define team assignment, provider access and\ncontent policies.",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "orgstorage": {
        "description": "OrgStorage stores some adhoc information for the organization.",
        "properties": {
          "ID": {
            "description": "ID is the identifier of the object.",
            "readOnly": true,
            "type": "string"
          },
          "createTime": {
            "description": "Creation date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          },
          "importHash": {
            "description": "The hash of the structure used to compare with new import version.",
            "type": "string"
          },
          "importLabel": {
            "description": "The user-defined import label that allows the system to group resources from the\nsame import operation.",
            "type": "string"
          },
          "key": {
            "description": "Key of the storage.",
            "example": "onboarding.",
            "type": "string"
          },
          "namespace": {
            "description": "The namespace of the object.",
            "readOnly": true,
            "type": "string"
          },
          "updateTime": {
            "description": "Last update date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          },
          "value": {
            "description": "Value of the storage.",
            "example": "completed.",
            "type": "string"
          }
        },
        "required": [
          "key",
          "value"
        ],
        "type": "object"
      },
      "pacconfig": {
        "description": "PAC Config allows to create a custom PAC, with a selection of services enabled.",
        "properties": {
          "ID": {
            "description": "ID is the identifier of the object.",
            "readOnly": true,
            "type": "string"
          },
          "createTime": {
            "description": "Creation date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          },
          "importHash": {
            "description": "The hash of the structure used to compare with new import version.",
            "type": "string"
          },
          "importLabel": {
            "description": "The user-defined import label that allows the system to group resources from the\nsame import operation.",
            "type": "string"
          },
          "name": {
            "description": "Name of the PAC config. A special name is 'default'. The default pac will be the\none that APEX returns if nothing else is configured.",
            "example": "production",
            "type": "string"
          },
          "namespace": {
            "description": "The namespace of the object.",
            "readOnly": true,
            "type": "string"
          },
          "providers": {
            "description": "The list of providers to activate for that PAC config.",
            "example": [
              "chatgpt",
              "microsoft-copilot"
            ],
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "updateTime": {
            "description": "Last update date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          }
        },
        "required": [
          "name",
          "providers"
        ],
        "type": "object"
      },
      "pagedataview": {
        "description": "Represents a page data view.",
        "properties": {
          "ID": {
            "description": "ID is the identifier of the object.",
            "readOnly": true,
            "type": "string"
          },
          "createTime": {
            "description": "Creation date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          },
          "name": {
            "description": "The name of the page data view.",
            "example": "all-chatgpt-conversations",
            "type": "string"
          },
          "namespace": {
            "description": "The namespace of the object.",
            "readOnly": true,
            "type": "string"
          },
          "pageID": {
            "description": "The name of the page.",
            "example": "conversations",
            "type": "string"
          },
          "predicates": {
            "description": "The match criteria used to make a query.",
            "example": "[\n  {\n    \"key\": \"provider\"\n    \"operator\": \"Equals\"\n    \"values\": [\"chatgpt\"]\n  }\n]",
            "items": {
              "$ref": "#/components/schemas/pagedataviewpredicate"
            },
            "type": "array"
          },
          "updateTime": {
            "description": "Last update date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          }
        },
        "required": [
          "name",
          "pageID"
        ],
        "type": "object"
      },
      "pagedataviewpredicate": {
        "description": "Represents a page data view predicate.",
        "properties": {
          "key": {
            "description": "The key of the page data view predicate.",
            "example": "name",
            "type": "string"
          },
          "operator": {
            "description": "The operator of the page data view predicate.",
            "enum": [
              "All",
              "Any",
              "Empty",
              "Equals",
              "EqualsOrGreaterThan",
              "EqualsOrLesserThan",
              "NotAny",
              "NotEmpty",
              "NotEquals"
            ],
            "example": "Equals"
          },
          "values": {
            "description": "The values of the predicate.",
            "example": [
              "chatgpt"
            ],
            "items": {
              "type": "any"
            },
            "type": "array"
          }
        },
        "required": [
          "key",
          "operator"
        ],
        "type": "object"
      },
      "policyupdate": {
        "description": "Object used to notify Apexes for policy changes.",
        "properties": {
          "ID": {
            "description": "ID is the identifier of the object.",
            "readOnly": true,
            "type": "string"
          },
          "namespace": {
            "description": "The namespace of the object.",
            "readOnly": true,
            "type": "string"
          }
        },
        "type": "object"
      },
      "predicate": {
        "description": "Represents a Predicate.",
        "properties": {
          "key": {
            "description": "The key of the predicate.",
            "enum": [
              "Categories",
              "Confidentiality",
              "CustomDataTypes",
              "DstApp",
              "DstComponent",
              "DstIPRange",
              "Exploits",
              "IsIngress",
              "Keywords",
              "Languages",
              "Malcontents",
              "Modality",
              "Model",
              "PIIs",
              "Plugin",
              "Provider",
              "Relevance",
              "RiskScore",
              "Secrets",
              "Size",
              "SrcApp",
              "SrcComponent",
              "SrcIPRange",
              "Status",
              "Team",
              "Tools",
              "Topics",
              "Workspace"
            ],
            "example": "Provider"
          },
          "operator": {
            "description": "The operator of the predicate.",
            "enum": [
              "All",
              "Any",
              "Empty",
              "Equals",
              "EqualsOrGreaterThan",
              "EqualsOrLesserThan",
              "NotAny",
              "NotEmpty",
              "NotEquals"
            ],
            "example": "Equals"
          },
          "values": {
            "description": "The values of the predicate.",
            "example": "xxx-xxx-xxx-xxx",
            "items": {
              "type": "any"
            },
            "type": "array"
          }
        },
        "required": [
          "key",
          "operator"
        ],
        "type": "object"
      },
      "principal": {
        "description": "Describe the principal.",
        "properties": {
          "IP": {
            "description": "The source IP address of the request.",
            "example": "192.0.2.42",
            "type": "string"
          },
          "app": {
            "$ref": "#/components/schemas/principalapp"
          },
          "authType": {
            "description": "The type of authentication.",
            "enum": [
              "Certificate",
              "UserToken",
              "AppToken",
              "Hostname",
              "Token",
              "ComponentToken",
              "External"
            ]
          },
          "claims": {
            "description": "List of claims extracted from the user query.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "team": {
            "description": "The team that was used to authorize the request.",
            "example": "admins",
            "type": "string"
          },
          "tokenName": {
            "description": "The name of the token, if any.",
            "example": "my-user-token",
            "type": "string"
          },
          "type": {
            "description": "The type of principal.",
            "enum": [
              "User",
              "App",
              "External"
            ],
            "example": [
              "User"
            ]
          },
          "user": {
            "$ref": "#/components/schemas/principaluser"
          }
        },
        "required": [
          "type"
        ],
        "type": "object"
      },
      "principalapp": {
        "description": "Describes the principal information of an application.",
        "properties": {
          "component": {
            "description": "The component of the application request.",
            "example": "frontend",
            "type": "string"
          },
          "labels": {
            "description": "The list of labels attached to an application request.",
            "example": [
              "country=us",
              "another-label"
            ],
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "name": {
            "description": "The name of the application.",
            "example": "MyApp",
            "type": "string"
          }
        },
        "type": "object"
      },
      "principaluser": {
        "description": "Describes the principal information of a user.",
        "properties": {
          "name": {
            "description": "Identification bit that will be used to identify the origin of the request.",
            "example": "user@company.com",
            "type": "string"
          }
        },
        "type": "object"
      },
      "project": {
        "description": "Project is a container for a set of policies and authorization.",
        "properties": {
          "ID": {
            "description": "ID is the identifier of the object.",
            "readOnly": true,
            "type": "string"
          },
          "createTime": {
            "description": "Creation date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          },
          "description": {
            "description": "Description of the project.",
            "type": "string"
          },
          "importHash": {
            "description": "The hash of the structure used to compare with new import version.",
            "type": "string"
          },
          "importLabel": {
            "description": "The user-defined import label that allows the system to group resources from the\nsame import operation.",
            "type": "string"
          },
          "name": {
            "description": "The name of the project.",
            "example": "demo",
            "type": "string"
          },
          "namespace": {
            "description": "The namespace of the object.",
            "readOnly": true,
            "type": "string"
          },
          "updateTime": {
            "description": "Last update date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          }
        },
        "required": [
          "name"
        ],
        "type": "object"
      },
      "provider": {
        "description": "Providers are services that can be accessed using the APEX. These can\nboth be external services as well as internal services built/deployed within the\norganization.",
        "properties": {
          "ID": {
            "description": "ID is the identifier of the object.",
            "readOnly": true,
            "type": "string"
          },
          "analyzeOutput": {
            "description": "If enabled, run the analysis pipelines on the provider output. No policy will be\napplied, but the response will be analyzed and classified.",
            "type": "boolean"
          },
          "category": {
            "description": "The category of the provider.",
            "enum": [
              "User",
              "App"
            ],
            "example": "User"
          },
          "createTime": {
            "description": "Creation date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          },
          "description": {
            "description": "The description of the provider.",
            "type": "string"
          },
          "errorTransformer": {
            "$ref": "#/components/schemas/errortransformer"
          },
          "experimental": {
            "description": "If true, consider this provider as experimental. It will require to use a custom\nPAC Config to make it usable from the proxy.pac.",
            "type": "boolean"
          },
          "extractors": {
            "description": "List of extractors for the provider.",
            "items": {
              "$ref": "#/components/schemas/extractorref"
            },
            "type": "array"
          },
          "friendlyName": {
            "description": "Friendly Name of the provider.",
            "example": "OpenAI",
            "type": "string"
          },
          "hosts": {
            "description": "Hosts supported by the providers.",
            "items": {
              "$ref": "#/components/schemas/host"
            },
            "type": "array"
          },
          "icon": {
            "description": "The icon of the provider, base64 encoded.",
            "type": "string"
          },
          "importHash": {
            "description": "The hash of the structure used to compare with new import version.",
            "type": "string"
          },
          "importLabel": {
            "description": "The user-defined import label that allows the system to group resources from the\nsame import operation.",
            "type": "string"
          },
          "injectors": {
            "description": "Defines injection point for javascript snippet.",
            "items": {
              "$ref": "#/components/schemas/injector"
            },
            "type": "array"
          },
          "mappers": {
            "description": "List of user mappers.",
            "items": {
              "$ref": "#/components/schemas/mapper"
            },
            "type": "array"
          },
          "name": {
            "description": "Name of the provider.",
            "example": "openai",
            "type": "string"
          },
          "namespace": {
            "description": "The namespace of the object.",
            "readOnly": true,
            "type": "string"
          },
          "propagate": {
            "default": true,
            "description": "Propagates the object to all child namespaces. This is always true.",
            "type": "boolean"
          },
          "riskScore": {
            "description": "The latest risk score of the provider.",
            "type": "number"
          },
          "status": {
            "default": "Stable",
            "description": "The support status of the provider.",
            "enum": [
              "Stable",
              "Unstable"
            ]
          },
          "tokenSwap": {
            "description": "If true, consider the incoming calls to use an acuvity token and swap them using\nregistered providertokens.",
            "type": "boolean"
          },
          "trustedCA": {
            "description": "If set, additionally trust the Certificate Authorities from the PEM data. This\nis useful when working on a custom provider using a self signed CA chain.",
            "type": "string"
          },
          "updateTime": {
            "description": "Last update date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          },
          "upstreamUnsecure": {
            "description": "If enabled, force the ustream scheme to be HTTP instead of https. Mostly use for\ndev purposes.",
            "type": "boolean"
          }
        },
        "required": [
          "category",
          "friendlyName",
          "name",
          "status"
        ],
        "type": "object"
      },
      "providerdetail": {
        "description": "List all information about the provider and its AI domain.",
        "properties": {
          "ID": {
            "description": "ID is the identifier of the object.",
            "readOnly": true,
            "type": "string"
          },
          "compliances": {
            "description": "The list of compliance provided by the domain.",
            "example": [
              "SOC2",
              "GDPR",
              "HIPAA"
            ],
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "dataResidency": {
            "description": "The user data storage location.",
            "example": [
              "US",
              "EU",
              "China"
            ],
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "dataSharing": {
            "description": "Does the provider share user data with 3rd party or services.",
            "example": "A description text",
            "type": "boolean"
          },
          "dataSharingConsent": {
            "description": "Does the provider share user data with consent with 3rd party or services.",
            "example": "A flag to indicate data sharing with consent",
            "type": "boolean"
          },
          "description": {
            "description": "The description of the provider detail.",
            "type": "string"
          },
          "domain": {
            "description": "Domain of the provider detail.",
            "type": "string"
          },
          "friendlyName": {
            "description": "Friendly Name of the provider detail.",
            "example": "OpenAI",
            "type": "string"
          },
          "icon": {
            "description": "The icon of the providerdetail, base64 encoded.",
            "type": "string"
          },
          "models": {
            "description": "List of AI models used by the domain.",
            "example": [
              "gpt-4o",
              "gpt-4"
            ],
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "name": {
            "description": "Name of the provider detail.",
            "example": "openai",
            "type": "string"
          },
          "namespace": {
            "description": "The namespace of the object.",
            "readOnly": true,
            "type": "string"
          },
          "providerRetentionPolicies": {
            "description": "The data retention policies by the domain for each type of users.",
            "items": {
              "$ref": "#/components/schemas/providerretentionpolicy"
            },
            "type": "array"
          },
          "providerTrainingPolicies": {
            "description": "Does the provider use user data for training its model.",
            "example": [
              {
                "description": "provider uses user data for training the models on Free plan ",
                "subscriptiontype": "Free",
                "useData": true
              }
            ],
            "items": {
              "$ref": "#/components/schemas/providertrainingpolicy"
            },
            "type": "array"
          },
          "riskScore": {
            "description": "The risk score for the domain.",
            "example": 0.5,
            "type": "number"
          },
          "thirdPartyModelUsage": {
            "description": "Does provider use third party model.",
            "type": "boolean"
          }
        },
        "required": [
          "friendlyName",
          "name",
          "riskScore"
        ],
        "type": "object"
      },
      "providerretentionpolicy": {
        "description": "Represents data retention policy for a given subscription type.",
        "properties": {
          "description": {
            "description": "Description of the data retention policy for the subscription type.",
            "type": "string"
          },
          "duration": {
            "description": "The duration of time the data retention policy applies to the subscription type.",
            "type": "string"
          },
          "subscriptionType": {
            "default": "Free",
            "description": "The type of subscription for which the data retention policy needs to be\ndefined.",
            "enum": [
              "Enterprise",
              "Paid",
              "Free"
            ],
            "example": "Free"
          }
        },
        "type": "object"
      },
      "providerteam": {
        "description": "Provider Teams can be created to create groups of people, identified by their\njwt claims\nthat can be used when writing Access Policies.",
        "properties": {
          "ID": {
            "description": "ID is the identifier of the object.",
            "readOnly": true,
            "type": "string"
          },
          "createTime": {
            "description": "Creation date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          },
          "description": {
            "description": "Description of the provider team.",
            "type": "string"
          },
          "disabled": {
            "description": "Set the provider team to be disabled.",
            "type": "boolean"
          },
          "excludedSubject": {
            "description": "A tag expression that identifies user(s) to not include in the team, even if\ntheir claims match the subject.",
            "items": {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "type": "array"
          },
          "importHash": {
            "description": "The hash of the structure used to compare with new import version.",
            "type": "string"
          },
          "importLabel": {
            "description": "The user-defined import label that allows the system to group resources from the\nsame import operation.",
            "type": "string"
          },
          "name": {
            "description": "The name of the provider team.",
            "example": "engineers",
            "type": "string"
          },
          "namespace": {
            "description": "The namespace of the object.",
            "readOnly": true,
            "type": "string"
          },
          "subject": {
            "description": "A tag expression that identifies user(s).",
            "items": {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "type": "array"
          },
          "updateTime": {
            "description": "Last update date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          }
        },
        "required": [
          "name"
        ],
        "type": "object"
      },
      "providertoken": {
        "description": "ProviderToken are upstream tokens for the 'Provider' configured on our system to\nbe used by the acuvity proxy.",
        "properties": {
          "ID": {
            "description": "ID is the identifier of the object.",
            "readOnly": true,
            "type": "string"
          },
          "createTime": {
            "description": "Creation date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          },
          "importHash": {
            "description": "The hash of the structure used to compare with new import version.",
            "type": "string"
          },
          "importLabel": {
            "description": "The user-defined import label that allows the system to group resources from the\nsame import operation.",
            "type": "string"
          },
          "name": {
            "description": "Name of the token. As token contents are hidden after creation, name allows a\nway to delete it.",
            "example": "openai-token-1",
            "type": "string"
          },
          "namespace": {
            "description": "The namespace of the object.",
            "readOnly": true,
            "type": "string"
          },
          "provider": {
            "description": "Name of the provider this token is used with.",
            "example": "openai",
            "type": "string"
          },
          "token": {
            "description": "token to authenticate with the provider.",
            "example": "token1",
            "type": "string"
          },
          "updateTime": {
            "description": "Last update date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          }
        },
        "required": [
          "name",
          "provider",
          "token"
        ],
        "type": "object"
      },
      "providertrainingpolicy": {
        "description": "Represents provider data usage policy for a given subscription type.",
        "properties": {
          "description": {
            "description": "Description of the data usage policy for a subscription type.",
            "type": "string"
          },
          "subscriptionType": {
            "default": "Free",
            "description": "The type of subscription for which the data retention policy needs to be\ndefined.",
            "enum": [
              "Enterprise",
              "Paid",
              "Free"
            ],
            "example": "Free"
          },
          "useData": {
            "description": "User Data usage to train or improve the models based on the subscription type.",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "proxyconf": {
        "description": "ProxyConf is an API for proxy.",
        "properties": {
          "ID": {
            "description": "ID is the identifier of the object.",
            "readOnly": true,
            "type": "string"
          },
          "PACConfigs": {
            "description": "The PAC configurations of the organizations.",
            "items": {
              "$ref": "#/components/schemas/pacconfig"
            },
            "type": "array"
          },
          "accessPolicy": {
            "description": "The computed access policy.",
            "type": "string"
          },
          "agentConfig": {
            "$ref": "#/components/schemas/agentconfig"
          },
          "assignPolicy": {
            "description": "The computed assign policy.",
            "type": "string"
          },
          "contentPolicy": {
            "description": "The computed content policy.",
            "type": "string"
          },
          "customDataSets": {
            "description": "List of custom data sets.",
            "items": {
              "$ref": "#/components/schemas/customdataset"
            },
            "type": "array"
          },
          "customDataTypes": {
            "description": "List of custom data types.",
            "items": {
              "$ref": "#/components/schemas/customdatatype"
            },
            "type": "array"
          },
          "extractors": {
            "description": "The extractors of the organization.",
            "items": {
              "$ref": "#/components/schemas/extractor"
            },
            "type": "array"
          },
          "namespace": {
            "description": "The namespace of the object.",
            "readOnly": true,
            "type": "string"
          },
          "orgSettings": {
            "$ref": "#/components/schemas/orgsettings"
          },
          "providers": {
            "description": "The list of available provider.",
            "items": {
              "$ref": "#/components/schemas/provider"
            },
            "type": "array"
          },
          "tokens": {
            "description": "Tokens pool to authenticate with the provider.",
            "example": {
              "providera": "token-a",
              "providerb": "token-b"
            },
            "items": {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "type": "object"
          },
          "webExtensionConfig": {
            "$ref": "#/components/schemas/webextensionconfig"
          }
        },
        "type": "object"
      },
      "proxyroundtrip": {
        "description": "This is a Proxy roundtrip.",
        "properties": {
          "ID": {
            "description": "ID is the identifier of the object.",
            "readOnly": true,
            "type": "string"
          },
          "alerts": {
            "description": "List of alerts that got raised during the policy resolution.",
            "items": {
              "$ref": "#/components/schemas/alertevent"
            },
            "type": "array"
          },
          "annotations": {
            "description": "Annotations attached to the log.",
            "items": {
              "type": "string"
            },
            "type": "object"
          },
          "client": {
            "description": "The client used to send the request.",
            "example": "curl",
            "type": "string"
          },
          "clientVersion": {
            "description": "The version of the client used to send the request.",
            "example": "7.64.1",
            "type": "string"
          },
          "decision": {
            "description": "Tell what was the decision about the data.",
            "enum": [
              "Deny",
              "Allow",
              "Ask",
              "Bypassed",
              "ForbiddenUser",
              "Skipped"
            ]
          },
          "destination": {
            "$ref": "#/components/schemas/destination"
          },
          "extractions": {
            "description": "The extractions to log.",
            "items": {
              "$ref": "#/components/schemas/extraction"
            },
            "type": "array"
          },
          "hash": {
            "description": "The hash of the input.",
            "type": "string"
          },
          "importHash": {
            "description": "The hash of the structure used to compare with new import version.",
            "type": "string"
          },
          "importLabel": {
            "description": "The user-defined import label that allows the system to group resources from the\nsame import operation.",
            "type": "string"
          },
          "latency": {
            "$ref": "#/components/schemas/latency"
          },
          "namespace": {
            "description": "The namespace of the object.",
            "readOnly": true,
            "type": "string"
          },
          "pipelineName": {
            "description": "The name of the particular pipeline that extracted the text.",
            "type": "string"
          },
          "principal": {
            "$ref": "#/components/schemas/principal"
          },
          "provider": {
            "description": "the provider to use.",
            "example": "openai",
            "type": "string"
          },
          "reasons": {
            "description": "The various reasons returned by the policy engine.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "summary": {
            "$ref": "#/components/schemas/extractionsummary"
          },
          "time": {
            "description": "Set the time of the message request.",
            "format": "date-time",
            "type": "string"
          },
          "trace": {
            "$ref": "#/components/schemas/traceref"
          },
          "type": {
            "description": "The type of text.",
            "enum": [
              "Input",
              "Output"
            ]
          }
        },
        "required": [
          "principal"
        ],
        "type": "object"
      },
      "query": {
        "description": "This is a Log.",
        "properties": {
          "ID": {
            "description": "ID is the identifier of the object.",
            "readOnly": true,
            "type": "string"
          },
          "direction": {
            "default": "Backward",
            "description": "Determines the sort order of logs.",
            "enum": [
              "Forward",
              "Backward"
            ]
          },
          "namespace": {
            "description": "The namespace of the object.",
            "readOnly": true,
            "type": "string"
          },
          "query": {
            "description": "The query in LogQL format.",
            "example": [
              "{type=log}"
            ],
            "type": "string"
          },
          "result": {
            "description": "The result of the request.",
            "items": {
              "type": "object"
            },
            "type": "array"
          },
          "resultType": {
            "description": "The type of the result.",
            "type": "string"
          },
          "time": {
            "description": "The time for the query in any format supported by\nhttps://github.com/araddon/dateparse.",
            "example": 1700083708672317036,
            "type": "string"
          },
          "timeRelative": {
            "description": "The relative time of the time window as time.Duration.",
            "example": "10h",
            "type": "string"
          }
        },
        "required": [
          "query"
        ],
        "type": "object"
      },
      "queryrange": {
        "description": "This is a Log.",
        "properties": {
          "ID": {
            "description": "ID is the identifier of the object.",
            "readOnly": true,
            "type": "string"
          },
          "direction": {
            "default": "Backward",
            "description": "Determines the sort order of logs.",
            "enum": [
              "Forward",
              "Backward"
            ]
          },
          "end": {
            "description": "The end of the time window in any format supported by\nhttps://github.com/araddon/dateparse.",
            "example": "May 8, 2009 5:57:51 PM",
            "type": "string"
          },
          "endRelative": {
            "description": "The relative end of the time window as time.Duration.",
            "example": "10h",
            "type": "string"
          },
          "limit": {
            "default": 100,
            "description": "the number of results to return.",
            "type": "integer"
          },
          "namespace": {
            "description": "The namespace of the object.",
            "readOnly": true,
            "type": "string"
          },
          "query": {
            "description": "The query in LogQL format.",
            "example": [
              "{type=log}"
            ],
            "type": "string"
          },
          "result": {
            "description": "The result of the request.",
            "items": {
              "type": "object"
            },
            "type": "array"
          },
          "resultType": {
            "description": "The type of the result.",
            "type": "string"
          },
          "start": {
            "description": "The start of the time window in any format supported by\nhttps://github.com/araddon/dateparse.",
            "example": 1700083708672317036,
            "type": "string"
          },
          "startRelative": {
            "description": "The relative start of the time window as time.Duration.",
            "example": "10h",
            "type": "string"
          }
        },
        "required": [
          "query"
        ],
        "type": "object"
      },
      "role": {
        "description": "Role for API Authorizations.",
        "properties": {
          "ID": {
            "description": "ID is the identifier of the object.",
            "readOnly": true,
            "type": "string"
          },
          "description": {
            "description": "The description of the role.",
            "example": "This is the boss.",
            "type": "string"
          },
          "friendlyName": {
            "description": "The friendly name of the role.",
            "example": "Administrator",
            "type": "string"
          },
          "name": {
            "description": "The name of the role.",
            "example": "Administrator",
            "type": "string"
          },
          "namespace": {
            "description": "The namespace of the object.",
            "readOnly": true,
            "type": "string"
          },
          "permissions": {
            "description": "Permissions for the role.",
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "schemaversion": {
        "description": "This holds the schema version of a service.",
        "type": "object"
      },
      "serie": {
        "description": "This is a Log serie.",
        "properties": {
          "ID": {
            "description": "ID is the identifier of the object.",
            "readOnly": true,
            "type": "string"
          },
          "end": {
            "description": "The end of the time window in any format supported by\nhttps://github.com/araddon/dateparse.",
            "example": "May 8, 2009 5:57:51 PM",
            "type": "string"
          },
          "endRelative": {
            "description": "The relative end of the time window as time.Duration.",
            "example": "10h",
            "type": "string"
          },
          "namespace": {
            "description": "The namespace of the object.",
            "readOnly": true,
            "type": "string"
          },
          "query": {
            "description": "The query in LogQL format.",
            "example": [
              "{type=log}"
            ],
            "type": "string"
          },
          "result": {
            "description": "The result of the request.",
            "items": {
              "type": "object"
            },
            "type": "array"
          },
          "start": {
            "description": "The start of the time window in any format supported by\nhttps://github.com/araddon/dateparse.",
            "example": 1700083708672317036,
            "type": "string"
          },
          "startRelative": {
            "description": "The relative start of the time window as time.Duration.",
            "example": "10h",
            "type": "string"
          }
        },
        "required": [
          "query"
        ],
        "type": "object"
      },
      "signup": {
        "description": "Represents a sign up request.",
        "properties": {
          "ID": {
            "description": "ID is the identifier of the object.",
            "readOnly": true,
            "type": "string"
          },
          "createTime": {
            "description": "Creation date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          },
          "email": {
            "description": "The email requesting the signup. This email can be considered valid and\nverified, as for the signup request to succeed, it must have been verified by\nsigning up with one of the oauth2 source we support.",
            "readOnly": true,
            "type": "string"
          },
          "namespace": {
            "description": "The namespace of the object.",
            "readOnly": true,
            "type": "string"
          },
          "type": {
            "description": "The type of signup requested.",
            "enum": [
              "Employees",
              "Apps"
            ],
            "example": "Employees"
          },
          "updateTime": {
            "description": "Last update date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          },
          "verifiedBy": {
            "description": "The source of verification.",
            "readOnly": true,
            "type": "string"
          }
        },
        "required": [
          "type"
        ],
        "type": "object"
      },
      "sink": {
        "description": "Represents the sink used to send a notification.",
        "properties": {
          "ID": {
            "description": "ID is the identifier of the object.",
            "readOnly": true,
            "type": "string"
          },
          "createTime": {
            "description": "Creation date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          },
          "description": {
            "description": "The description of the sink.",
            "type": "string"
          },
          "email": {
            "$ref": "#/components/schemas/sinkemail"
          },
          "friendlyName": {
            "description": "Friendly name of the object.",
            "example": "Simple name",
            "type": "string"
          },
          "importHash": {
            "description": "The hash of the structure used to compare with new import version.",
            "type": "string"
          },
          "importLabel": {
            "description": "The user-defined import label that allows the system to group resources from the\nsame import operation.",
            "type": "string"
          },
          "name": {
            "description": "The internal reference name of the object. It is a sanitized version of Friendly\nName if empty.",
            "example": "my-simple-policy",
            "type": "string"
          },
          "namespace": {
            "description": "The namespace of the object.",
            "readOnly": true,
            "type": "string"
          },
          "pagerDuty": {
            "$ref": "#/components/schemas/sinkpagerduty"
          },
          "propagate": {
            "default": true,
            "description": "Propagates the object to all child namespaces. This is always true.",
            "type": "boolean"
          },
          "slack": {
            "$ref": "#/components/schemas/sinkslack"
          },
          "splunk": {
            "$ref": "#/components/schemas/sinksplunk"
          },
          "type": {
            "default": "Email",
            "description": "The type of sink.",
            "enum": [
              "Email",
              "PagerDuty",
              "Slack",
              "Splunk"
            ]
          },
          "updateTime": {
            "description": "Last update date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          }
        },
        "required": [
          "friendlyName",
          "type"
        ],
        "type": "object"
      },
      "sinkemail": {
        "description": "Additional configuration for sending an email.",
        "properties": {
          "recipients": {
            "description": "The list of email recipients the notification will be sent to.",
            "example": [
              "info@acuvity.ai",
              "me@email.com"
            ],
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "required": [
          "recipients"
        ],
        "type": "object"
      },
      "sinkpagerduty": {
        "description": "Additional configuration for sending a PagerDuty event.",
        "properties": {
          "token": {
            "description": "The token for PagerDuty events.",
            "example": "0a11421bcb4c45aseve7d822fake333a",
            "type": "string"
          }
        },
        "required": [
          "token"
        ],
        "type": "object"
      },
      "sinkslack": {
        "description": "Additional configuration for sending a Slack message.",
        "properties": {
          "webhookURL": {
            "description": "The webhook URL to send the Slack messages to.",
            "example": "https://hooks.slack.com/services/T00000000/B00000000/XXXXXXXXXXXXXXXXXXXXXXXX",
            "type": "string"
          }
        },
        "required": [
          "webhookURL"
        ],
        "type": "object"
      },
      "sinksplunk": {
        "description": "Additional configuration for sending an alert to Splunk.",
        "properties": {
          "HECURL": {
            "description": "The HTTP event collector (HEC) URL to send the alert to.",
            "example": "https://mysplunkserver.example.com:8088/services/collector",
            "type": "string"
          },
          "certificateAuthority": {
            "description": "If set, will use this as the CA for TLS communication.",
            "type": "string"
          },
          "insecureSkipVerify": {
            "description": "If true, will attempt to skip TLS verification when communicating.",
            "type": "boolean"
          },
          "token": {
            "description": "The token to communicate with the HTTP event collector.",
            "example": "CF179AE4-3C99-45F5-A7CC-3284AA91CF67",
            "type": "string"
          }
        },
        "required": [
          "HECURL",
          "token"
        ],
        "type": "object"
      },
      "team": {
        "description": "Teams can be created to create groups of people, identified by their jwt claims\nthat can be used when writing authorizations.",
        "properties": {
          "ID": {
            "description": "ID is the identifier of the object.",
            "readOnly": true,
            "type": "string"
          },
          "createTime": {
            "description": "Creation date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          },
          "description": {
            "description": "Description of the team.",
            "type": "string"
          },
          "disabled": {
            "description": "Set the team to be disabled.",
            "type": "boolean"
          },
          "importHash": {
            "description": "The hash of the structure used to compare with new import version.",
            "type": "string"
          },
          "importLabel": {
            "description": "The user-defined import label that allows the system to group resources from the\nsame import operation.",
            "type": "string"
          },
          "name": {
            "description": "The name of the team.",
            "example": "engineers",
            "type": "string"
          },
          "namespace": {
            "description": "The namespace of the object.",
            "readOnly": true,
            "type": "string"
          },
          "subject": {
            "description": "A tag expression that identifies user(s).",
            "items": {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "type": "array"
          },
          "updateTime": {
            "description": "Last update date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          },
          "weight": {
            "description": "Weight of the team. It is used if multiple teams match for a user. In that case\nthe team with the higher weight will be used.",
            "type": "integer"
          }
        },
        "required": [
          "name"
        ],
        "type": "object"
      },
      "textualdetection": {
        "description": "Represents a textual detection done by policy.",
        "properties": {
          "end": {
            "description": "The end position of the detection in the original data.",
            "type": "integer"
          },
          "key": {
            "description": "The key that is used in the name's place, If empty, a sequence of X's are used.",
            "type": "string"
          },
          "name": {
            "description": "The name of the detection.",
            "type": "string"
          },
          "redacted": {
            "description": "If true this detection has been redacted.",
            "type": "boolean"
          },
          "redactedEnd": {
            "description": "The end position of the detection in the redacted data.",
            "type": "integer"
          },
          "redactedStart": {
            "description": "The start position of the detection in the redacted data.",
            "type": "integer"
          },
          "score": {
            "description": "The confidence score of the detection.",
            "type": "number"
          },
          "start": {
            "description": "The start position of the detection in the original data.",
            "type": "integer"
          },
          "type": {
            "description": "The type of detection.",
            "enum": [
              "Keyword",
              "PII",
              "Secret",
              "CDT"
            ]
          }
        },
        "type": "object"
      },
      "trace": {
        "description": "This is a OTEL Trace.",
        "properties": {
          "ID": {
            "description": "ID is the identifier of the object.",
            "readOnly": true,
            "type": "string"
          },
          "end": {
            "description": "The end of the time window in any format supported by\nhttps://github.com/araddon/dateparse.",
            "example": "May 8, 2009 5:57:51 PM",
            "type": "string"
          },
          "endRelative": {
            "description": "The relative end of the time window as time.Duration.",
            "example": "10h",
            "type": "string"
          },
          "namespace": {
            "description": "The namespace of the object.",
            "readOnly": true,
            "type": "string"
          },
          "result": {
            "description": "The result of the request.",
            "type": "object"
          },
          "start": {
            "description": "The start of the time window in any format supported by\nhttps://github.com/araddon/dateparse.",
            "example": 1700083708672317036,
            "type": "string"
          },
          "startRelative": {
            "description": "The relative start of the time window as time.Duration.",
            "example": "10h",
            "type": "string"
          },
          "traceID": {
            "description": "The trace ID to query.",
            "example": [
              "1234567890abcdef"
            ],
            "type": "string"
          }
        },
        "required": [
          "traceID"
        ],
        "type": "object"
      },
      "traceref": {
        "description": "Holds all references to a trace.",
        "properties": {
          "parentSpanID": {
            "description": "The parent span ID that is being referenced.",
            "example": "00f067aa0ba902b7",
            "type": "string"
          },
          "spanEnd": {
            "description": "When the span ended.",
            "example": "2025-03-22T14:35:00.123456789Z",
            "format": "date-time",
            "type": "string"
          },
          "spanID": {
            "description": "The span ID that is being referenced.",
            "example": "6ba80aaa3b2f43d8",
            "type": "string"
          },
          "spanName": {
            "description": "The name of the span that is being collected.",
            "example": "acuvity_prompt_input_analysis",
            "type": "string"
          },
          "spanStart": {
            "description": "When the span started.",
            "example": "2025-03-22T14:35:00.123456789Z",
            "format": "date-time",
            "type": "string"
          },
          "traceID": {
            "description": "The Trace ID that is being referenced.",
            "example": "4bf92f3577b34da6a3ce929d0e0e4736",
            "type": "string"
          }
        },
        "required": [
          "spanEnd",
          "spanID",
          "spanName",
          "spanStart",
          "traceID"
        ],
        "type": "object"
      },
      "tracesearch": {
        "description": "This is a OTEL TraceQL query wrapper.",
        "properties": {
          "ID": {
            "description": "ID is the identifier of the object.",
            "readOnly": true,
            "type": "string"
          },
          "end": {
            "description": "The end of the time window in any format supported by\nhttps://github.com/araddon/dateparse.",
            "example": "May 8, 2009 5:57:51 PM",
            "type": "string"
          },
          "endRelative": {
            "description": "The relative end of the time window as time.Duration.",
            "example": "10h",
            "type": "string"
          },
          "namespace": {
            "description": "The namespace of the object.",
            "readOnly": true,
            "type": "string"
          },
          "query": {
            "description": "The query in TraceQL format.",
            "example": [
              "{resource.service.name = \"my-service\"}"
            ],
            "type": "string"
          },
          "result": {
            "description": "The result of the request.",
            "items": {
              "type": "object"
            },
            "type": "array"
          },
          "spansPerSpanSet": {
            "default": 32,
            "description": "The max number of spans to return per span set.",
            "type": "integer"
          },
          "start": {
            "description": "The start of the time window in any format supported by\nhttps://github.com/araddon/dateparse.",
            "example": 1700083708672317036,
            "type": "string"
          },
          "startRelative": {
            "description": "The relative start of the time window as time.Duration.",
            "example": "10h",
            "type": "string"
          }
        },
        "required": [
          "query"
        ],
        "type": "object"
      },
      "usertoken": {
        "description": "User Token are revocable long lived tokens for users.",
        "properties": {
          "ID": {
            "description": "ID is the identifier of the object.",
            "readOnly": true,
            "type": "string"
          },
          "claims": {
            "description": "The list of claims delivered in the token.",
            "items": {
              "type": "string"
            },
            "readOnly": true,
            "type": "array"
          },
          "clientType": {
            "default": "None",
            "description": "the client type of the user token.",
            "enum": [
              "None",
              "WebExtension",
              "Acushield",
              "Acuctl"
            ]
          },
          "createTime": {
            "description": "Creation date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          },
          "email": {
            "description": "The email of the user who requested the token.",
            "readOnly": true,
            "type": "string"
          },
          "expirationDate": {
            "description": "Tells when the token will expire.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          },
          "machineID": {
            "description": "ID of the source machine that initiated the creation of the token.",
            "example": "my-computer.local",
            "type": "string"
          },
          "name": {
            "description": "Name of the token is specified while creating the token.",
            "example": "my personal access token",
            "type": "string"
          },
          "namespace": {
            "description": "The namespace of the object.",
            "readOnly": true,
            "type": "string"
          },
          "sourceIP": {
            "description": "The source IP of the request that initiated the creation of the token.",
            "readOnly": true,
            "type": "string"
          },
          "token": {
            "description": "The generated token. It won't be stored.",
            "type": "string"
          },
          "tokenID": {
            "description": "The ID of the associated token.",
            "readOnly": true,
            "type": "string"
          },
          "transient": {
            "description": "If true, the token will not be stored and will only be revocable if you keep\ntrack of the token ID yourself. Also, the validity will be capped and the token\nwon't be long lived.",
            "type": "boolean"
          },
          "updateTime": {
            "description": "Last update date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          },
          "validity": {
            "default": "8760h",
            "description": "Configures the validity of the token.",
            "type": "string"
          }
        },
        "required": [
          "name"
        ],
        "type": "object"
      },
      "visitedurl": {
        "description": "This is a visited URL.",
        "properties": {
          "ID": {
            "description": "ID is the identifier of the object.",
            "readOnly": true,
            "type": "string"
          },
          "domainHits": {
            "description": "Domain that has been visited.",
            "example": [
              {
                "domain": "google.com",
                "hits": 1
              }
            ],
            "items": {
              "$ref": "#/components/schemas/domainhits"
            },
            "type": "array"
          },
          "importHash": {
            "description": "The hash of the structure used to compare with new import version.",
            "type": "string"
          },
          "importLabel": {
            "description": "The user-defined import label that allows the system to group resources from the\nsame import operation.",
            "type": "string"
          },
          "namespace": {
            "description": "The namespace of the object.",
            "readOnly": true,
            "type": "string"
          },
          "origin": {
            "default": "Proxy",
            "description": "Origin indicates from where the url has been tracked.",
            "enum": [
              "WebExtension",
              "Proxy"
            ]
          },
          "principal": {
            "$ref": "#/components/schemas/principal"
          }
        },
        "required": [
          "domainHits",
          "origin",
          "principal"
        ],
        "type": "object"
      },
      "watchedorg": {
        "description": "List the organization your organization watches.",
        "properties": {
          "ID": {
            "description": "ID is the identifier of the object.",
            "readOnly": true,
            "type": "string"
          },
          "name": {
            "description": "The name of the accessible organization.",
            "type": "string"
          },
          "namespace": {
            "description": "The namespace of the object.",
            "readOnly": true,
            "type": "string"
          },
          "orgNamespace": {
            "description": "The name namespace of the org.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "webextensionconfig": {
        "description": "WebExtensionConfig stores the configuration information for the webextension.",
        "properties": {
          "ID": {
            "description": "ID is the identifier of the object.",
            "readOnly": true,
            "type": "string"
          },
          "allowProxySettings": {
            "description": "Allows the web extension to set the proxy settings of the employee's browser.",
            "type": "boolean"
          },
          "createTime": {
            "description": "Creation date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          },
          "description": {
            "description": "Description of the webextension configuration.",
            "type": "string"
          },
          "importHash": {
            "description": "The hash of the structure used to compare with new import version.",
            "type": "string"
          },
          "importLabel": {
            "description": "The user-defined import label that allows the system to group resources from the\nsame import operation.",
            "type": "string"
          },
          "name": {
            "description": "The name of the webextension configuration.",
            "example": "default",
            "type": "string"
          },
          "namespace": {
            "description": "The namespace of the object.",
            "readOnly": true,
            "type": "string"
          },
          "refreshWebExtensionConfigInterval": {
            "default": 120,
            "description": "Defines the refresh interval in minutes for the configuration of the deployed\nweb extensions.",
            "type": "integer"
          },
          "reportVisitedURLsInterval": {
            "default": 60,
            "description": "Define the interval in minutes between two reports of the visited URLs.",
            "type": "integer"
          },
          "updateTime": {
            "description": "Last update date of the object.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          }
        },
        "required": [
          "name"
        ],
        "type": "object"
      }
    }
  },
  "info": {
    "contact": {
      "email": "contact@acuvity.ai",
      "name": "Acuvity Team",
      "url": "https://www.acuvity.ai/api"
    },
    "title": "api",
    "version": "1.0"
  },
  "openapi": "3.1.0",
  "paths": {
    "/accesspolicies": {
      "get": {
        "description": "List all available access policies.",
        "operationId": "get-all-AccessPolicies",
        "parameters": [
          {
            "description": "This is an example.",
            "example": "hello == world",
            "in": "query",
            "name": "q",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/accesspolicy"
                  },
                  "type": "array"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "post": {
        "description": "Creates a new access policy.",
        "operationId": "create-AccessPolicy",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/accesspolicy"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/accesspolicy"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      }
    },
    "/accesspolicies/{id}": {
      "delete": {
        "description": "Deletes the access policy with the given ID.",
        "operationId": "delete-AccessPolicy",
        "parameters": [
          {
            "description": "This is an example.",
            "example": "hello == world",
            "in": "query",
            "name": "q",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/accesspolicy"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "get": {
        "description": "Retrieves the access policy with the given ID.",
        "operationId": "get-AccessPolicy",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/accesspolicy"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "parameters": [
        {
          "in": "path",
          "name": "id",
          "required": true,
          "schema": {
            "type": "string"
          }
        }
      ],
      "put": {
        "description": "Updates the access policy with the given ID.",
        "operationId": "update-AccessPolicy",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/accesspolicy"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/accesspolicy"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      }
    },
    "/adminmagiclinks": {
      "post": {
        "description": "Creates a new magic link using admin api.",
        "operationId": "create-AdminMagicLink",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/adminmagiclink"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/adminmagiclink"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "admin"
        ]
      }
    },
    "/adminorgs": {
      "get": {
        "description": "List all existing orgs.",
        "operationId": "get-all-AdminOrgs",
        "parameters": [
          {
            "description": "This is an example.",
            "example": "hello == world",
            "in": "query",
            "name": "q",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/adminorg"
                  },
                  "type": "array"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "admin"
        ]
      },
      "post": {
        "description": "Creates a new organization using admin api.",
        "operationId": "create-AdminOrg",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/adminorg"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/adminorg"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "admin"
        ]
      }
    },
    "/adminorgs/{id}": {
      "get": {
        "description": "Retrieve the org by using the given ID. Note that the ID is the ID of the backing a3s namespace.",
        "operationId": "get-AdminOrg",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/adminorg"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "admin"
        ]
      },
      "parameters": [
        {
          "in": "path",
          "name": "id",
          "required": true,
          "schema": {
            "type": "string"
          }
        }
      ],
      "put": {
        "description": "Update the org by using the given ID. Note that the ID is the ID of the backing a3s namespace.",
        "operationId": "update-AdminOrg",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/adminorg"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/adminorg"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "admin"
        ]
      }
    },
    "/agentconfigs": {
      "get": {
        "description": "List all agent configurations.",
        "operationId": "get-all-AgentConfigs",
        "parameters": [
          {
            "description": "This is an example.",
            "example": "hello == world",
            "in": "query",
            "name": "q",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/agentconfig"
                  },
                  "type": "array"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "post": {
        "description": "Creates a new agent configuration.",
        "operationId": "create-AgentConfig",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/agentconfig"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/agentconfig"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      }
    },
    "/agentconfigs/{id}": {
      "delete": {
        "description": "Delete an agent configuration given its identifier.",
        "operationId": "delete-AgentConfig",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/agentconfig"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "get": {
        "description": "Retrieve an agent configuration given its identifier.",
        "operationId": "get-AgentConfig",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/agentconfig"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "parameters": [
        {
          "in": "path",
          "name": "id",
          "required": true,
          "schema": {
            "type": "string"
          }
        }
      ],
      "put": {
        "description": "Update an agent configuration given its identifier.",
        "operationId": "update-AgentConfig",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/agentconfig"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/agentconfig"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      }
    },
    "/agents": {
      "get": {
        "description": "List all available agents.",
        "operationId": "get-all-Agents",
        "parameters": [
          {
            "description": "This is an example.",
            "example": "hello == world",
            "in": "query",
            "name": "q",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/agent"
                  },
                  "type": "array"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "post": {
        "description": "Creates a new agent.",
        "operationId": "create-Agent",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/agent"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/agent"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      }
    },
    "/agents/{id}": {
      "delete": {
        "description": "Delete an agent given its identifier.",
        "operationId": "delete-Agent",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/agent"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "get": {
        "description": "Retrieve an agent given its identifier.",
        "operationId": "get-Agent",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/agent"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "parameters": [
        {
          "in": "path",
          "name": "id",
          "required": true,
          "schema": {
            "type": "string"
          }
        }
      ]
    },
    "/aidomains": {
      "get": {
        "description": "List all AI domains.",
        "operationId": "get-all-AIDomains",
        "parameters": [
          {
            "description": "The domain to look for.",
            "example": "domain=xxxx",
            "in": "query",
            "name": "domain",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "This is an example.",
            "example": "hello == world",
            "in": "query",
            "name": "q",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/aidomain"
                  },
                  "type": "array"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "post": {
        "description": "Creates a new AI domain.",
        "operationId": "create-AIDomain",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/aidomain"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/aidomain"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      }
    },
    "/aidomains/{id}": {
      "delete": {
        "description": "Delete an AI domain given its identifier.",
        "operationId": "delete-AIDomain",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/aidomain"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "get": {
        "description": "Retrieve an AI domain given its identifier.",
        "operationId": "get-AIDomain",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/aidomain"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "parameters": [
        {
          "in": "path",
          "name": "id",
          "required": true,
          "schema": {
            "type": "string"
          }
        }
      ],
      "put": {
        "description": "Update an AI domain given its identifier.",
        "operationId": "update-AIDomain",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/aidomain"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/aidomain"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      }
    },
    "/alertdefinitions": {
      "get": {
        "description": "List all available alert definitions.",
        "operationId": "get-all-AlertDefinitions",
        "parameters": [
          {
            "description": "This is an example.",
            "example": "hello == world",
            "in": "query",
            "name": "q",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/alertdefinition"
                  },
                  "type": "array"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "notification"
        ]
      },
      "post": {
        "description": "Creates a new alert definition.",
        "operationId": "create-AlertDefinition",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/alertdefinition"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/alertdefinition"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "notification"
        ]
      }
    },
    "/alertdefinitions/{id}": {
      "delete": {
        "description": "Deletes the alert definition with the given ID.",
        "operationId": "delete-AlertDefinition",
        "parameters": [
          {
            "description": "This is an example.",
            "example": "hello == world",
            "in": "query",
            "name": "q",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/alertdefinition"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "notification"
        ]
      },
      "get": {
        "description": "Retrieves the alert definition with the given ID.",
        "operationId": "get-AlertDefinition",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/alertdefinition"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "notification"
        ]
      },
      "parameters": [
        {
          "in": "path",
          "name": "id",
          "required": true,
          "schema": {
            "type": "string"
          }
        }
      ],
      "put": {
        "description": "Updates the alert definition with the given ID.",
        "operationId": "update-AlertDefinition",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/alertdefinition"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/alertdefinition"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "notification"
        ]
      }
    },
    "/alerts": {
      "get": {
        "description": "List all available alerts.",
        "operationId": "get-all-Alerts",
        "parameters": [
          {
            "description": "This is an example.",
            "example": "hello == world",
            "in": "query",
            "name": "q",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/alert"
                  },
                  "type": "array"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "notification"
        ]
      },
      "post": {
        "description": "Creates a new alert.",
        "operationId": "create-Alert",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/alert"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/alert"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "notification"
        ]
      }
    },
    "/alerts/{id}": {
      "delete": {
        "description": "Deletes the alert with the given ID.",
        "operationId": "delete-Alert",
        "parameters": [
          {
            "description": "This is an example.",
            "example": "hello == world",
            "in": "query",
            "name": "q",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/alert"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "notification"
        ]
      },
      "get": {
        "description": "Retrieves the alert with the given ID.",
        "operationId": "get-Alert",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/alert"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "notification"
        ]
      },
      "parameters": [
        {
          "in": "path",
          "name": "id",
          "required": true,
          "schema": {
            "type": "string"
          }
        }
      ],
      "put": {
        "description": "Updates the alert with the given ID.",
        "operationId": "update-Alert",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/alert"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/alert"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "notification"
        ]
      }
    },
    "/analyzers": {
      "get": {
        "description": "List of analyzers.",
        "operationId": "get-all-Analyzers",
        "parameters": [
          {
            "description": "This is an example.",
            "example": "hello == world",
            "in": "query",
            "name": "q",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/analyzer"
                  },
                  "type": "array"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "apex"
        ]
      }
    },
    "/apiauthorizations": {
      "get": {
        "description": "List all available api authorizations.",
        "operationId": "get-all-APIAuthorizations",
        "parameters": [
          {
            "description": "This is an example.",
            "example": "hello == world",
            "in": "query",
            "name": "q",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/apiauthorization"
                  },
                  "type": "array"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "post": {
        "description": "Creates a new api authorization policy.",
        "operationId": "create-APIAuthorization",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/apiauthorization"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/apiauthorization"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      }
    },
    "/apiauthorizations/{id}": {
      "delete": {
        "description": "Deletes the apiauthorizations with the given ID.",
        "operationId": "delete-APIAuthorization",
        "parameters": [
          {
            "description": "This is an example.",
            "example": "hello == world",
            "in": "query",
            "name": "q",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/apiauthorization"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "get": {
        "description": "Retrieves the apiauthorizations with the given ID.",
        "operationId": "get-APIAuthorization",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/apiauthorization"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "parameters": [
        {
          "in": "path",
          "name": "id",
          "required": true,
          "schema": {
            "type": "string"
          }
        }
      ],
      "put": {
        "description": "Updates the apiauthorizations with the given ID.",
        "operationId": "update-APIAuthorization",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/apiauthorization"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/apiauthorization"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      }
    },
    "/apps": {
      "get": {
        "description": "List all apps.",
        "operationId": "get-all-Apps",
        "parameters": [
          {
            "description": "This is an example.",
            "example": "hello == world",
            "in": "query",
            "name": "q",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/app"
                  },
                  "type": "array"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "post": {
        "description": "Creates a new apps.",
        "operationId": "create-App",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/app"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/app"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      }
    },
    "/apps/{id}": {
      "delete": {
        "description": "Deletes the App with the given ID.",
        "operationId": "delete-App",
        "parameters": [
          {
            "description": "This is an example.",
            "example": "hello == world",
            "in": "query",
            "name": "q",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/app"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "get": {
        "description": "Retrieves the App with the given ID.",
        "operationId": "get-App",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/app"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "parameters": [
        {
          "in": "path",
          "name": "id",
          "required": true,
          "schema": {
            "type": "string"
          }
        }
      ],
      "put": {
        "description": "Updates the App with the given ID.",
        "operationId": "update-App",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/app"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/app"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      }
    },
    "/apps/{id}/appcomponents": {
      "get": {
        "description": "Retrieve the list of app components for that application with their respective\nidentity tokens.",
        "operationId": "get-all-AppComponents-in-app",
        "parameters": [
          {
            "description": "This is an example.",
            "example": "hello == world",
            "in": "query",
            "name": "q",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/appcomponent"
                  },
                  "type": "array"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "parameters": [
        {
          "in": "path",
          "name": "id",
          "required": true,
          "schema": {
            "type": "string"
          }
        }
      ]
    },
    "/apptokens": {
      "get": {
        "description": "List all apptokens available.",
        "operationId": "get-all-AppTokens",
        "parameters": [
          {
            "description": "This is an example.",
            "example": "hello == world",
            "in": "query",
            "name": "q",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/apptoken"
                  },
                  "type": "array"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "post": {
        "description": "Creates a new app token.",
        "operationId": "create-AppToken",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/apptoken"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/apptoken"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      }
    },
    "/apptokens/{id}": {
      "delete": {
        "description": "Deletes the App Token with the given ID.",
        "operationId": "delete-AppToken",
        "parameters": [
          {
            "description": "This is an example.",
            "example": "hello == world",
            "in": "query",
            "name": "q",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/apptoken"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "get": {
        "description": "Retrieves the App Token with the given ID.",
        "operationId": "get-AppToken",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/apptoken"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "parameters": [
        {
          "in": "path",
          "name": "id",
          "required": true,
          "schema": {
            "type": "string"
          }
        }
      ]
    },
    "/authsettings": {
      "get": {
        "description": "Retrieve authentication settings for an organization.",
        "operationId": "get-all-AuthSettings",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/authsettings"
                  },
                  "type": "array"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      }
    },
    "/contentpolicies": {
      "get": {
        "description": "List all available content policies.",
        "operationId": "get-all-ContentPolicies",
        "parameters": [
          {
            "description": "This is an example.",
            "example": "hello == world",
            "in": "query",
            "name": "q",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/contentpolicy"
                  },
                  "type": "array"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "post": {
        "description": "Creates a new content policy.",
        "operationId": "create-ContentPolicy",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/contentpolicy"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/contentpolicy"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      }
    },
    "/contentpolicies/{id}": {
      "delete": {
        "description": "Deletes the content policy with the given ID.",
        "operationId": "delete-ContentPolicy",
        "parameters": [
          {
            "description": "This is an example.",
            "example": "hello == world",
            "in": "query",
            "name": "q",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/contentpolicy"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "get": {
        "description": "Retrieves the content policy with the given ID.",
        "operationId": "get-ContentPolicy",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/contentpolicy"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "parameters": [
        {
          "in": "path",
          "name": "id",
          "required": true,
          "schema": {
            "type": "string"
          }
        }
      ],
      "put": {
        "description": "Updates the content policy with the given ID.",
        "operationId": "update-ContentPolicy",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/contentpolicy"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/contentpolicy"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      }
    },
    "/customdatasets": {
      "get": {
        "description": "List all custom data sets.",
        "operationId": "get-all-CustomDataSets",
        "parameters": [
          {
            "description": "This is an example.",
            "example": "hello == world",
            "in": "query",
            "name": "q",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/customdataset"
                  },
                  "type": "array"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "post": {
        "description": "Creates a new custom data set.",
        "operationId": "create-CustomDataSet",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/customdataset"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/customdataset"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      }
    },
    "/customdatasets/{id}": {
      "delete": {
        "description": "Delete a custom data set given its identifier.",
        "operationId": "delete-CustomDataSet",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/customdataset"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "get": {
        "description": "Retrieve a custom data set given its identifier.",
        "operationId": "get-CustomDataSet",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/customdataset"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "parameters": [
        {
          "in": "path",
          "name": "id",
          "required": true,
          "schema": {
            "type": "string"
          }
        }
      ],
      "put": {
        "description": "Update a custom data set given its identifier.",
        "operationId": "update-CustomDataSet",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/customdataset"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/customdataset"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      }
    },
    "/customdatatypes": {
      "get": {
        "description": "List all custom data types.",
        "operationId": "get-all-CustomDataTypes",
        "parameters": [
          {
            "description": "This is an example.",
            "example": "hello == world",
            "in": "query",
            "name": "q",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/customdatatype"
                  },
                  "type": "array"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "post": {
        "description": "Creates a new custom data type.",
        "operationId": "create-CustomDataType",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/customdatatype"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/customdatatype"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      }
    },
    "/customdatatypes/{id}": {
      "delete": {
        "description": "Delete a custom data type given its identifier.",
        "operationId": "delete-CustomDataType",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/customdatatype"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "get": {
        "description": "Retrieve a custom data type given its identifier.",
        "operationId": "get-CustomDataType",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/customdatatype"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "parameters": [
        {
          "in": "path",
          "name": "id",
          "required": true,
          "schema": {
            "type": "string"
          }
        }
      ],
      "put": {
        "description": "Update a custom data type given its identifier.",
        "operationId": "update-CustomDataType",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/customdatatype"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/customdatatype"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      }
    },
    "/extractors": {
      "get": {
        "description": "List all available extractors.",
        "operationId": "get-all-Extractors",
        "parameters": [
          {
            "description": "This is an example.",
            "example": "hello == world",
            "in": "query",
            "name": "q",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/extractor"
                  },
                  "type": "array"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "post": {
        "description": "Creates a new extractor.",
        "operationId": "create-Extractor",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/extractor"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/extractor"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      }
    },
    "/extractors/{id}": {
      "delete": {
        "description": "Delete an extractor given its identifier.",
        "operationId": "delete-Extractor",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/extractor"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "get": {
        "description": "Retrieve an extractor given its identifier.",
        "operationId": "get-Extractor",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/extractor"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "parameters": [
        {
          "in": "path",
          "name": "id",
          "required": true,
          "schema": {
            "type": "string"
          }
        }
      ],
      "put": {
        "description": "Update an extractor given its identifier.",
        "operationId": "update-Extractor",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/extractor"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/extractor"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      }
    },
    "/feedbacks": {
      "get": {
        "description": "List all feedbacks.",
        "operationId": "get-all-Feedbacks",
        "parameters": [
          {
            "description": "This is an example.",
            "example": "hello == world",
            "in": "query",
            "name": "q",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/feedback"
                  },
                  "type": "array"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "post": {
        "description": "Creates a new feedback.",
        "operationId": "create-Feedback",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/feedback"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/feedback"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      }
    },
    "/feedbacks/{id}": {
      "delete": {
        "description": "Delete a feedback given its identifier.",
        "operationId": "delete-Feedback",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/feedback"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "get": {
        "description": "Retrieve a feedback given its identifier.",
        "operationId": "get-Feedback",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/feedback"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "parameters": [
        {
          "in": "path",
          "name": "id",
          "required": true,
          "schema": {
            "type": "string"
          }
        }
      ],
      "put": {
        "description": "Update a feedback given its identifier.",
        "operationId": "update-Feedback",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/feedback"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/feedback"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      }
    },
    "/gitbooktokens": {
      "get": {
        "description": "List all available access policies.",
        "operationId": "get-all-GitbookTokens",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/gitbooktoken"
                  },
                  "type": "array"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      }
    },
    "/ignoreddomains": {
      "get": {
        "description": "List all ignored domains.",
        "operationId": "get-all-IgnoredDomains",
        "parameters": [
          {
            "description": "This is an example.",
            "example": "hello == world",
            "in": "query",
            "name": "q",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/ignoreddomain"
                  },
                  "type": "array"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "post": {
        "description": "Creates a new ignored domain.",
        "operationId": "create-IgnoredDomain",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ignoreddomain"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ignoreddomain"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      }
    },
    "/ignoreddomains/{id}": {
      "delete": {
        "description": "Delete an ignored domain given its identifier.",
        "operationId": "delete-IgnoredDomain",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ignoreddomain"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "get": {
        "description": "Retrieve an ignored domain given its identifier.",
        "operationId": "get-IgnoredDomain",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ignoreddomain"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "parameters": [
        {
          "in": "path",
          "name": "id",
          "required": true,
          "schema": {
            "type": "string"
          }
        }
      ]
    },
    "/import": {
      "post": {
        "description": "Sends an import request.",
        "operationId": "create-Import",
        "parameters": [
          {
            "description": "If set, delete the current imported data.",
            "in": "query",
            "name": "delete",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/import"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/import"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core/import"
        ]
      }
    },
    "/labelvalues": {
      "post": {
        "description": "Requests all values for a label.",
        "operationId": "create-LabelValue",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/labelvalue"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/labelvalue"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      }
    },
    "/landings": {
      "get": {
        "description": "List all available landings.",
        "operationId": "get-all-Landings",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/landing"
                  },
                  "type": "array"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      }
    },
    "/metriclabelvalues": {
      "post": {
        "description": "Requests all metrics for a label.",
        "operationId": "create-MetricLabelValue",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/metriclabelvalue"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/metriclabelvalue"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      }
    },
    "/metricranges": {
      "post": {
        "description": "Creates a metric range query.",
        "operationId": "create-MetricRange",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/metricrange"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/metricrange"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      }
    },
    "/metrics": {
      "post": {
        "description": "Creates a metric query.",
        "operationId": "create-Metric",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/metric"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/metric"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      }
    },
    "/metricseries": {
      "post": {
        "description": "Create a metric series request.",
        "operationId": "create-MetricSerie",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/metricserie"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/metricserie"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      }
    },
    "/orgsettings": {
      "get": {
        "description": "List all orgsettings.",
        "operationId": "get-all-OrgSettings",
        "parameters": [
          {
            "description": "This is an example.",
            "example": "hello == world",
            "in": "query",
            "name": "q",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/orgsettings"
                  },
                  "type": "array"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "post": {
        "description": "Creates a new orgsettings.",
        "operationId": "create-OrgSettings",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/orgsettings"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/orgsettings"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      }
    },
    "/orgsettings/{id}": {
      "delete": {
        "description": "Delete a organization given its identifier.",
        "operationId": "delete-OrgSettings",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/orgsettings"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "get": {
        "description": "Retrieve a organization given its identifier.",
        "operationId": "get-OrgSettings",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/orgsettings"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "parameters": [
        {
          "in": "path",
          "name": "id",
          "required": true,
          "schema": {
            "type": "string"
          }
        }
      ],
      "put": {
        "description": "Update a organization given its identifier.",
        "operationId": "update-OrgSettings",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/orgsettings"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/orgsettings"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      }
    },
    "/orgstorages": {
      "get": {
        "description": "List all available orgstorages.",
        "operationId": "get-all-OrgStorages",
        "parameters": [
          {
            "description": "This is an example.",
            "example": "hello == world",
            "in": "query",
            "name": "q",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/orgstorage"
                  },
                  "type": "array"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "post": {
        "description": "Creates a new orgstorage.",
        "operationId": "create-OrgStorage",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/orgstorage"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/orgstorage"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      }
    },
    "/orgstorages/{id}": {
      "delete": {
        "description": "Delete an orgstorage given its identifier.",
        "operationId": "delete-OrgStorage",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/orgstorage"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "get": {
        "description": "Retrieve an orgstorage given its identifier.",
        "operationId": "get-OrgStorage",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/orgstorage"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "parameters": [
        {
          "in": "path",
          "name": "id",
          "required": true,
          "schema": {
            "type": "string"
          }
        }
      ],
      "put": {
        "description": "Update an orgstorage given its identifier.",
        "operationId": "update-OrgStorage",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/orgstorage"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/orgstorage"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      }
    },
    "/pacconfigs": {
      "get": {
        "description": "List all pac configs.",
        "operationId": "get-all-PACConfigs",
        "parameters": [
          {
            "description": "This is an example.",
            "example": "hello == world",
            "in": "query",
            "name": "q",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/pacconfig"
                  },
                  "type": "array"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "post": {
        "description": "Creates a new pac config.",
        "operationId": "create-PACConfig",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/pacconfig"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/pacconfig"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      }
    },
    "/pacconfigs/{id}": {
      "delete": {
        "description": "Delete an pacconfig given its identifier.",
        "operationId": "delete-PACConfig",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/pacconfig"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "get": {
        "description": "Retrieve an pacconfig given its identifier.",
        "operationId": "get-PACConfig",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/pacconfig"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "parameters": [
        {
          "in": "path",
          "name": "id",
          "required": true,
          "schema": {
            "type": "string"
          }
        }
      ],
      "put": {
        "description": "Update an pacconfig given its identifier.",
        "operationId": "update-PACConfig",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/pacconfig"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/pacconfig"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      }
    },
    "/pagedataviews": {
      "get": {
        "description": "List all page data views.",
        "operationId": "get-all-PageDataViews",
        "parameters": [
          {
            "description": "This is an example.",
            "example": "hello == world",
            "in": "query",
            "name": "q",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/pagedataview"
                  },
                  "type": "array"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "post": {
        "description": "Creates a new page data view.",
        "operationId": "create-PageDataView",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/pagedataview"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/pagedataview"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      }
    },
    "/pagedataviews/{id}": {
      "delete": {
        "description": "Deletes the page data view with the given ID.",
        "operationId": "delete-PageDataView",
        "parameters": [
          {
            "description": "This is an example.",
            "example": "hello == world",
            "in": "query",
            "name": "q",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/pagedataview"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "get": {
        "description": "Retrieves the page data view with the given ID.",
        "operationId": "get-PageDataView",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/pagedataview"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "parameters": [
        {
          "in": "path",
          "name": "id",
          "required": true,
          "schema": {
            "type": "string"
          }
        }
      ],
      "put": {
        "description": "Updates the page data view with the given ID.",
        "operationId": "update-PageDataView",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/pagedataview"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/pagedataview"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      }
    },
    "/projects": {
      "get": {
        "description": "List all projects.",
        "operationId": "get-all-Projects",
        "parameters": [
          {
            "description": "This is an example.",
            "example": "hello == world",
            "in": "query",
            "name": "q",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/project"
                  },
                  "type": "array"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "post": {
        "description": "Creates a new project.",
        "operationId": "create-Project",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/project"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/project"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      }
    },
    "/projects/{id}": {
      "delete": {
        "description": "Delete a project given its identifier.",
        "operationId": "delete-Project",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/project"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "get": {
        "description": "Retrieve a project given its identifier.",
        "operationId": "get-Project",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/project"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "parameters": [
        {
          "in": "path",
          "name": "id",
          "required": true,
          "schema": {
            "type": "string"
          }
        }
      ],
      "put": {
        "description": "Update a project given its identifier.",
        "operationId": "update-Project",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/project"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/project"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      }
    },
    "/providerdetails": {
      "get": {
        "description": "List all available provider details.",
        "operationId": "get-all-ProviderDetails",
        "parameters": [
          {
            "description": "If set, return the icons.",
            "in": "query",
            "name": "icon",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "This is an example.",
            "example": "hello == world",
            "in": "query",
            "name": "q",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/providerdetail"
                  },
                  "type": "array"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      }
    },
    "/providers": {
      "get": {
        "description": "List all available provider.",
        "operationId": "get-all-Providers",
        "parameters": [
          {
            "description": "If set, return the icons.",
            "in": "query",
            "name": "icon",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "This is an example.",
            "example": "hello == world",
            "in": "query",
            "name": "q",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/provider"
                  },
                  "type": "array"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "post": {
        "description": "Creates a new provider.",
        "operationId": "create-Provider",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/provider"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/provider"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      }
    },
    "/providers/{id}": {
      "delete": {
        "description": "Delete a provider given its identifier.",
        "operationId": "delete-Provider",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/provider"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "get": {
        "description": "Retrieve a provider given its identifier.",
        "operationId": "get-Provider",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/provider"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "parameters": [
        {
          "in": "path",
          "name": "id",
          "required": true,
          "schema": {
            "type": "string"
          }
        }
      ],
      "put": {
        "description": "Update a provider given its identifier.",
        "operationId": "update-Provider",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/provider"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/provider"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      }
    },
    "/providerteams": {
      "get": {
        "description": "List all provider teams.",
        "operationId": "get-all-ProviderTeams",
        "parameters": [
          {
            "description": "This is an example.",
            "example": "hello == world",
            "in": "query",
            "name": "q",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/providerteam"
                  },
                  "type": "array"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "post": {
        "description": "Creates a new provider team.",
        "operationId": "create-ProviderTeam",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/providerteam"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/providerteam"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      }
    },
    "/providerteams/{id}": {
      "delete": {
        "description": "Delete a provier team given its identifier.",
        "operationId": "delete-ProviderTeam",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/providerteam"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "get": {
        "description": "Retrieve a provier team given its identifier.",
        "operationId": "get-ProviderTeam",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/providerteam"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "parameters": [
        {
          "in": "path",
          "name": "id",
          "required": true,
          "schema": {
            "type": "string"
          }
        }
      ],
      "put": {
        "description": "Update a provier team given its identifier.",
        "operationId": "update-ProviderTeam",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/providerteam"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/providerteam"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      }
    },
    "/providertokens": {
      "get": {
        "description": "List all available provider tokens.",
        "operationId": "get-all-ProviderTokens",
        "parameters": [
          {
            "description": "This is an example.",
            "example": "hello == world",
            "in": "query",
            "name": "q",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/providertoken"
                  },
                  "type": "array"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "post": {
        "description": "Creates a new provider token list.",
        "operationId": "create-ProviderToken",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/providertoken"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/providertoken"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      }
    },
    "/providertokens/{id}": {
      "delete": {
        "description": "Delete a providertoken given its identifier.",
        "operationId": "delete-ProviderToken",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/providertoken"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "get": {
        "description": "Retrieve a providertoken given its identifier.",
        "operationId": "get-ProviderToken",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/providertoken"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "parameters": [
        {
          "in": "path",
          "name": "id",
          "required": true,
          "schema": {
            "type": "string"
          }
        }
      ]
    },
    "/proxyconfs": {
      "get": {
        "description": "List all available proxyconf.",
        "operationId": "get-all-ProxyConfs",
        "parameters": [
          {
            "description": "This is an example.",
            "example": "hello == world",
            "in": "query",
            "name": "q",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/proxyconf"
                  },
                  "type": "array"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "post": {
        "description": "Get a particular proxyconf.",
        "operationId": "create-ProxyConf",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/proxyconf"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/proxyconf"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      }
    },
    "/proxyroundtrips": {
      "post": {
        "description": "Creates a new proxy roundtrip.",
        "operationId": "create-ProxyRoundtrip",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/proxyroundtrip"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/proxyroundtrip"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      }
    },
    "/queries": {
      "get": {
        "description": "List all logs available.",
        "operationId": "get-all-Queries",
        "parameters": [
          {
            "description": "This is an example.",
            "example": "hello == world",
            "in": "query",
            "name": "q",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/query"
                  },
                  "type": "array"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "post": {
        "description": "Creates a new query.",
        "operationId": "create-Query",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/query"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/query"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      }
    },
    "/queries/{id}": {
      "delete": {
        "description": "Delete a log given its identifier.",
        "operationId": "delete-Query",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/query"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "get": {
        "description": "Retrieve a log given its identifier.",
        "operationId": "get-Query",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/query"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "parameters": [
        {
          "in": "path",
          "name": "id",
          "required": true,
          "schema": {
            "type": "string"
          }
        }
      ],
      "put": {
        "description": "Update a log given its identifier.",
        "operationId": "update-Query",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/query"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/query"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      }
    },
    "/queryranges": {
      "get": {
        "description": "List all logs available.",
        "operationId": "get-all-QueryRanges",
        "parameters": [
          {
            "description": "This is an example.",
            "example": "hello == world",
            "in": "query",
            "name": "q",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/queryrange"
                  },
                  "type": "array"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "post": {
        "description": "Creates a new queryrange.",
        "operationId": "create-QueryRange",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/queryrange"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/queryrange"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      }
    },
    "/queryranges/{id}": {
      "delete": {
        "description": "Delete a log given its identifier.",
        "operationId": "delete-QueryRange",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/queryrange"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "get": {
        "description": "Retrieve a log given its identifier.",
        "operationId": "get-QueryRange",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/queryrange"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "parameters": [
        {
          "in": "path",
          "name": "id",
          "required": true,
          "schema": {
            "type": "string"
          }
        }
      ],
      "put": {
        "description": "Update a log given its identifier.",
        "operationId": "update-QueryRange",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/queryrange"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/queryrange"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      }
    },
    "/roles": {
      "get": {
        "description": "List all roles.",
        "operationId": "get-all-Roles",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/role"
                  },
                  "type": "array"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      }
    },
    "/series": {
      "post": {
        "description": "send a series request.",
        "operationId": "create-Serie",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/serie"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/serie"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      }
    },
    "/signups": {
      "get": {
        "description": "List all existing signups requests.",
        "operationId": "get-all-Signups",
        "parameters": [
          {
            "description": "This is an example.",
            "example": "hello == world",
            "in": "query",
            "name": "q",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/signup"
                  },
                  "type": "array"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "post": {
        "description": "Creates a new signup request.",
        "operationId": "create-Signup",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/signup"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/signup"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      }
    },
    "/sinks": {
      "get": {
        "description": "List all available sinks.",
        "operationId": "get-all-Sinks",
        "parameters": [
          {
            "description": "This is an example.",
            "example": "hello == world",
            "in": "query",
            "name": "q",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/sink"
                  },
                  "type": "array"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "notification"
        ]
      },
      "post": {
        "description": "Creates a new sink.",
        "operationId": "create-Sink",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/sink"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/sink"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "notification"
        ]
      }
    },
    "/sinks/{id}": {
      "delete": {
        "description": "Deletes the sink with the given ID.",
        "operationId": "delete-Sink",
        "parameters": [
          {
            "description": "This is an example.",
            "example": "hello == world",
            "in": "query",
            "name": "q",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/sink"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "notification"
        ]
      },
      "get": {
        "description": "Retrieves the sink with the given ID.",
        "operationId": "get-Sink",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/sink"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "notification"
        ]
      },
      "parameters": [
        {
          "in": "path",
          "name": "id",
          "required": true,
          "schema": {
            "type": "string"
          }
        }
      ],
      "put": {
        "description": "Updates the sink with the given ID.",
        "operationId": "update-Sink",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/sink"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/sink"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "notification"
        ]
      }
    },
    "/teams": {
      "get": {
        "description": "List all teams.",
        "operationId": "get-all-Teams",
        "parameters": [
          {
            "description": "This is an example.",
            "example": "hello == world",
            "in": "query",
            "name": "q",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/team"
                  },
                  "type": "array"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "post": {
        "description": "Creates a new team.",
        "operationId": "create-Team",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/team"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/team"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      }
    },
    "/teams/{id}": {
      "delete": {
        "description": "Delete a team given its identifier.",
        "operationId": "delete-Team",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/team"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "get": {
        "description": "Retrieve a team given its identifier.",
        "operationId": "get-Team",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/team"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "parameters": [
        {
          "in": "path",
          "name": "id",
          "required": true,
          "schema": {
            "type": "string"
          }
        }
      ],
      "put": {
        "description": "Update a team given its identifier.",
        "operationId": "update-Team",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/team"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/team"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      }
    },
    "/traces": {
      "post": {
        "description": "send a trace request.",
        "operationId": "create-Trace",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/trace"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/trace"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      }
    },
    "/tracesearches": {
      "post": {
        "description": "send a tracesearch request.",
        "operationId": "create-TraceSearch",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/tracesearch"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/tracesearch"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      }
    },
    "/usertokens": {
      "get": {
        "description": "List all usertokens available.",
        "operationId": "get-all-UserTokens",
        "parameters": [
          {
            "description": "This is an example.",
            "example": "hello == world",
            "in": "query",
            "name": "q",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/usertoken"
                  },
                  "type": "array"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "post": {
        "description": "Creates a new app token.",
        "operationId": "create-UserToken",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/usertoken"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/usertoken"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      }
    },
    "/usertokens/{id}": {
      "delete": {
        "description": "Deletes the User Token with the given ID.",
        "operationId": "delete-UserToken",
        "parameters": [
          {
            "description": "This is an example.",
            "example": "hello == world",
            "in": "query",
            "name": "q",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/usertoken"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "get": {
        "description": "Retrieves the User Token with the given ID.",
        "operationId": "get-UserToken",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/usertoken"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "parameters": [
        {
          "in": "path",
          "name": "id",
          "required": true,
          "schema": {
            "type": "string"
          }
        }
      ]
    },
    "/visitedurls": {
      "get": {
        "description": "List all visited urls.",
        "operationId": "get-all-VisitedURLs",
        "parameters": [
          {
            "description": "This is an example.",
            "example": "hello == world",
            "in": "query",
            "name": "q",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/visitedurl"
                  },
                  "type": "array"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "post": {
        "description": "Creates a new visited url.",
        "operationId": "create-VisitedURL",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/visitedurl"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/visitedurl"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      }
    },
    "/visitedurls/{id}": {
      "get": {
        "description": "Retrieve a report given its identifier.",
        "operationId": "get-VisitedURL",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/visitedurl"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "parameters": [
        {
          "in": "path",
          "name": "id",
          "required": true,
          "schema": {
            "type": "string"
          }
        }
      ]
    },
    "/watchedorgs": {
      "get": {
        "description": "List of watched organizations.",
        "operationId": "get-all-WatchedOrgs",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/watchedorg"
                  },
                  "type": "array"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      }
    },
    "/webextensionconfigs": {
      "get": {
        "description": "List all web extension configurations.",
        "operationId": "get-all-WebExtensionConfigs",
        "parameters": [
          {
            "description": "This is an example.",
            "example": "hello == world",
            "in": "query",
            "name": "q",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/webextensionconfig"
                  },
                  "type": "array"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "post": {
        "description": "Creates a new web extension configuration.",
        "operationId": "create-WebExtensionConfig",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/webextensionconfig"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/webextensionconfig"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      }
    },
    "/webextensionconfigs/{id}": {
      "delete": {
        "description": "Delete a webextension configuration given its identifier.",
        "operationId": "delete-WebExtensionConfig",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/webextensionconfig"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "get": {
        "description": "Retrieve a webextension configuration given its identifier.",
        "operationId": "get-WebExtensionConfig",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/webextensionconfig"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      },
      "parameters": [
        {
          "in": "path",
          "name": "id",
          "required": true,
          "schema": {
            "type": "string"
          }
        }
      ],
      "put": {
        "description": "Update a webextension configuration given its identifier.",
        "operationId": "update-WebExtensionConfig",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/webextensionconfig"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/webextensionconfig"
                }
              }
            },
            "description": "n/a"
          }
        },
        "tags": [
          "core"
        ]
      }
    }
  },
  "servers": [
    {
      "url": "https://api.acuvity.ai"
    }
  ],
  "tags": [
    {
      "description": "This tag is for group 'admin'",
      "name": "admin"
    },
    {
      "description": "This tag is for group 'apex'",
      "name": "apex"
    },
    {
      "description": "This tag is for group 'core'",
      "name": "core"
    },
    {
      "description": "This tag is for group 'core/import'",
      "name": "core/import"
    },
    {
      "description": "This tag is for group 'migration'",
      "name": "migration"
    },
    {
      "description": "This tag is for group 'notification'",
      "name": "notification"
    }
  ]
}
