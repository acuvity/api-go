// Code generated by elegen. DO NOT EDIT.
// Source: go.acuvity.ai/elemental (templates/model.gotpl)

package api

import (
	"fmt"
	"slices"

	"github.com/globalsign/mgo/bson"
	"github.com/mitchellh/copystructure"
	"go.acuvity.ai/elemental"
)

// IngestTraceIdentity represents the Identity of the object.
var IngestTraceIdentity = elemental.Identity{
	Name:     "ingesttrace",
	Category: "ingesttraces",
	Package:  "colektor",
	Private:  false,
}

// IngestTracesList represents a list of IngestTraces
type IngestTracesList []*IngestTrace

// Identity returns the identity of the objects in the list.
func (o IngestTracesList) Identity() elemental.Identity {

	return IngestTraceIdentity
}

// Copy returns a pointer to a copy the IngestTracesList.
func (o IngestTracesList) Copy() elemental.Identifiables {

	out := slices.Clone(o)
	return &out
}

// Append appends the objects to the a new copy of the IngestTracesList.
func (o IngestTracesList) Append(objects ...elemental.Identifiable) elemental.Identifiables {

	out := slices.Clone(o)
	for _, obj := range objects {
		out = append(out, obj.(*IngestTrace))
	}

	return out
}

// List converts the object to an elemental.IdentifiablesList.
func (o IngestTracesList) List() elemental.IdentifiablesList {

	out := make(elemental.IdentifiablesList, len(o))
	for i := range len(o) {
		out[i] = o[i]
	}

	return out
}

// DefaultOrder returns the default ordering fields of the content.
func (o IngestTracesList) DefaultOrder() []string {

	return []string{}
}

// ToSparse returns the IngestTracesList converted to SparseIngestTracesList.
// Objects in the list will only contain the given fields. No field means entire field set.
func (o IngestTracesList) ToSparse(fields ...string) elemental.Identifiables {

	out := make(SparseIngestTracesList, len(o))
	for i := range len(o) {
		out[i] = o[i].ToSparse(fields...).(*SparseIngestTrace)
	}

	return out
}

// Version returns the version of the content.
func (o IngestTracesList) Version() int {

	return 1
}

// IngestTrace represents the model of a ingesttrace
type IngestTrace struct {
	// ID is the identifier of the object.
	ID string `json:"ID,omitempty" msgpack:"ID,omitempty" bson:"-" mapstructure:"ID,omitempty"`

	// The namespace of the object.
	Namespace string `json:"namespace,omitempty" msgpack:"namespace,omitempty" bson:"namespace,omitempty" mapstructure:"namespace,omitempty"`

	// The principal of the object.
	Principal *Principal `json:"principal" msgpack:"principal" bson:"principal" mapstructure:"principal,omitempty"`

	// The raw OTLP traces in JSON encoded format. If this is set, you must not set the
	// traces field. This will ingest everything about this trace and make it available
	// to Acuvity.
	Raw string `json:"raw" msgpack:"raw" bson:"raw" mapstructure:"raw,omitempty"`

	// The traces to ingest. If this is set, the raw input field must not be set. This
	// is the recommended way on how to ingest trace data into Acuvity. This will
	// ingest
	// only the necessary core data of a trace.
	Traces TraceRefsList `json:"traces" msgpack:"traces" bson:"traces" mapstructure:"traces,omitempty"`

	ModelVersion int `json:"-" msgpack:"-" bson:"_modelversion"`
}

// NewIngestTrace returns a new *IngestTrace
func NewIngestTrace() *IngestTrace {

	return &IngestTrace{
		ModelVersion: 1,
		Principal:    NewPrincipal(),
	}
}

// Identity returns the Identity of the object.
func (o *IngestTrace) Identity() elemental.Identity {

	return IngestTraceIdentity
}

// Identifier returns the value of the object's unique identifier.
func (o *IngestTrace) Identifier() string {

	return o.ID
}

// SetIdentifier sets the value of the object's unique identifier.
func (o *IngestTrace) SetIdentifier(id string) {

	o.ID = id
}

// GetBSON implements the bson marshaling interface.
// This is used to transparently convert ID to MongoDBID as ObectID.
func (o *IngestTrace) GetBSON() (any, error) {

	if o == nil {
		return nil, nil
	}

	s := &mongoAttributesIngestTrace{}

	if o.ID != "" {
		s.ID = bson.ObjectIdHex(o.ID)
	}
	s.Namespace = o.Namespace
	s.Principal = o.Principal
	s.Raw = o.Raw
	s.Traces = o.Traces

	return s, nil
}

// SetBSON implements the bson marshaling interface.
// This is used to transparently convert ID to MongoDBID as ObectID.
func (o *IngestTrace) SetBSON(raw bson.Raw) error {

	if o == nil || raw.Kind == bson.ElementNil {
		return bson.ErrSetZero
	}

	s := &mongoAttributesIngestTrace{}
	if err := raw.Unmarshal(s); err != nil {
		return err
	}

	o.ID = s.ID.Hex()
	o.Namespace = s.Namespace
	o.Principal = s.Principal
	o.Raw = s.Raw
	o.Traces = s.Traces

	return nil
}

// Version returns the hardcoded version of the model.
func (o *IngestTrace) Version() int {

	return 1
}

// BleveType implements the bleve.Classifier Interface.
func (o *IngestTrace) BleveType() string {

	return "ingesttrace"
}

// DefaultOrder returns the list of default ordering fields.
func (o *IngestTrace) DefaultOrder() []string {

	return []string{}
}

// Doc returns the documentation for the object
func (o *IngestTrace) Doc() string {

	return `Ingest Traces allows to import OTLP traces into the system.`
}

func (o *IngestTrace) String() string {

	return fmt.Sprintf("<%s:%s>", o.Identity().Name, o.Identifier())
}

// GetNamespace returns the Namespace of the receiver.
func (o *IngestTrace) GetNamespace() string {

	return o.Namespace
}

// SetNamespace sets the property Namespace of the receiver using the given value.
func (o *IngestTrace) SetNamespace(namespace string) {

	o.Namespace = namespace
}

// ToSparse returns the sparse version of the model.
// The returned object will only contain the given fields. No field means entire field set.
func (o *IngestTrace) ToSparse(fields ...string) elemental.SparseIdentifiable {

	if len(fields) == 0 {
		// nolint: goimports
		return &SparseIngestTrace{
			ID:        &o.ID,
			Namespace: &o.Namespace,
			Principal: o.Principal,
			Raw:       &o.Raw,
			Traces:    &o.Traces,
		}
	}

	sp := &SparseIngestTrace{}
	for _, f := range fields {
		switch f {
		case "ID":
			sp.ID = &(o.ID)
		case "namespace":
			sp.Namespace = &(o.Namespace)
		case "principal":
			sp.Principal = o.Principal
		case "raw":
			sp.Raw = &(o.Raw)
		case "traces":
			sp.Traces = &(o.Traces)
		}
	}

	return sp
}

// Patch apply the non nil value of a *SparseIngestTrace to the object.
func (o *IngestTrace) Patch(sparse elemental.SparseIdentifiable) {
	if !sparse.Identity().IsEqual(o.Identity()) {
		panic("cannot patch from a parse with different identity")
	}

	so := sparse.(*SparseIngestTrace)
	if so.ID != nil {
		o.ID = *so.ID
	}
	if so.Namespace != nil {
		o.Namespace = *so.Namespace
	}
	if so.Principal != nil {
		o.Principal = so.Principal
	}
	if so.Raw != nil {
		o.Raw = *so.Raw
	}
	if so.Traces != nil {
		o.Traces = *so.Traces
	}
}

// DeepCopy returns a deep copy if the IngestTrace.
func (o *IngestTrace) DeepCopy() *IngestTrace {

	if o == nil {
		return nil
	}

	out := &IngestTrace{}
	o.DeepCopyInto(out)

	return out
}

// DeepCopyInto copies the receiver into the given *IngestTrace.
func (o *IngestTrace) DeepCopyInto(out *IngestTrace) {

	target, err := copystructure.Copy(o)
	if err != nil {
		panic(fmt.Sprintf("Unable to deepcopy IngestTrace: %s", err))
	}

	*out = *target.(*IngestTrace)
}

// Validate valides the current information stored into the structure.
func (o *IngestTrace) Validate() error {

	errors := elemental.Errors{}
	requiredErrors := elemental.Errors{}

	if o.Principal != nil {
		elemental.ResetDefaultForZeroValues(o.Principal)
		if err := o.Principal.Validate(); err != nil {
			errors = errors.Append(err)
		}
	}

	if err := ValidateOTLPJSON("raw", o.Raw); err != nil {
		errors = errors.Append(err)
	}

	for _, sub := range o.Traces {
		elemental.ResetDefaultForZeroValues(sub)
		if err := sub.Validate(); err != nil {
			errors = errors.Append(err)
		}
	}

	// Custom object validation.
	if err := ValidateIngestTrace(o); err != nil {
		errors = errors.Append(err)
	}

	if len(requiredErrors) > 0 {
		return requiredErrors
	}

	if len(errors) > 0 {
		return errors
	}

	return nil
}

// SpecificationForAttribute returns the AttributeSpecification for the given attribute name key.
func (*IngestTrace) SpecificationForAttribute(name string) elemental.AttributeSpecification {

	if v, ok := IngestTraceAttributesMap[name]; ok {
		return v
	}

	// We could not find it, so let's check on the lower case indexed spec map
	return IngestTraceLowerCaseAttributesMap[name]
}

// AttributeSpecifications returns the full attribute specifications map.
func (*IngestTrace) AttributeSpecifications() map[string]elemental.AttributeSpecification {

	return IngestTraceAttributesMap
}

// ValueForAttribute returns the value for the given attribute.
// This is a very advanced function that you should not need but in some
// very specific use cases.
func (o *IngestTrace) ValueForAttribute(name string) any {

	switch name {
	case "ID":
		return o.ID
	case "namespace":
		return o.Namespace
	case "principal":
		return o.Principal
	case "raw":
		return o.Raw
	case "traces":
		return o.Traces
	}

	return nil
}

// IngestTraceAttributesMap represents the map of attribute for IngestTrace.
var IngestTraceAttributesMap = map[string]elemental.AttributeSpecification{
	"ID": {
		AllowedChoices: []string{},
		Autogenerated:  true,
		BSONFieldName:  "_id",
		ConvertedName:  "ID",
		Description:    `ID is the identifier of the object.`,
		Exposed:        true,
		Filterable:     true,
		Identifier:     true,
		Name:           "ID",
		Orderable:      true,
		ReadOnly:       true,
		Stored:         true,
		Type:           "string",
	},
	"Namespace": {
		AllowedChoices: []string{},
		Autogenerated:  true,
		BSONFieldName:  "namespace",
		ConvertedName:  "Namespace",
		Description:    `The namespace of the object.`,
		Exposed:        true,
		Getter:         true,
		Name:           "namespace",
		Orderable:      true,
		ReadOnly:       true,
		Setter:         true,
		Stored:         true,
		Type:           "string",
	},
	"Principal": {
		AllowedChoices: []string{},
		BSONFieldName:  "principal",
		ConvertedName:  "Principal",
		Description:    `The principal of the object.`,
		Exposed:        true,
		Name:           "principal",
		Required:       true,
		Stored:         true,
		SubType:        "principal",
		Type:           "ref",
	},
	"Raw": {
		AllowedChoices: []string{},
		BSONFieldName:  "raw",
		ConvertedName:  "Raw",
		Description: `The raw OTLP traces in JSON encoded format. If this is set, you must not set the
traces field. This will ingest everything about this trace and make it available
to Acuvity.`,
		Exposed: true,
		Name:    "raw",
		Stored:  true,
		Type:    "string",
	},
	"Traces": {
		AllowedChoices: []string{},
		BSONFieldName:  "traces",
		ConvertedName:  "Traces",
		Description: `The traces to ingest. If this is set, the raw input field must not be set. This
is the recommended way on how to ingest trace data into Acuvity. This will
ingest
only the necessary core data of a trace.`,
		Exposed: true,
		Name:    "traces",
		Stored:  true,
		SubType: "traceref",
		Type:    "refList",
	},
}

// IngestTraceLowerCaseAttributesMap represents the map of attribute for IngestTrace.
var IngestTraceLowerCaseAttributesMap = map[string]elemental.AttributeSpecification{
	"id": {
		AllowedChoices: []string{},
		Autogenerated:  true,
		BSONFieldName:  "_id",
		ConvertedName:  "ID",
		Description:    `ID is the identifier of the object.`,
		Exposed:        true,
		Filterable:     true,
		Identifier:     true,
		Name:           "ID",
		Orderable:      true,
		ReadOnly:       true,
		Stored:         true,
		Type:           "string",
	},
	"namespace": {
		AllowedChoices: []string{},
		Autogenerated:  true,
		BSONFieldName:  "namespace",
		ConvertedName:  "Namespace",
		Description:    `The namespace of the object.`,
		Exposed:        true,
		Getter:         true,
		Name:           "namespace",
		Orderable:      true,
		ReadOnly:       true,
		Setter:         true,
		Stored:         true,
		Type:           "string",
	},
	"principal": {
		AllowedChoices: []string{},
		BSONFieldName:  "principal",
		ConvertedName:  "Principal",
		Description:    `The principal of the object.`,
		Exposed:        true,
		Name:           "principal",
		Required:       true,
		Stored:         true,
		SubType:        "principal",
		Type:           "ref",
	},
	"raw": {
		AllowedChoices: []string{},
		BSONFieldName:  "raw",
		ConvertedName:  "Raw",
		Description: `The raw OTLP traces in JSON encoded format. If this is set, you must not set the
traces field. This will ingest everything about this trace and make it available
to Acuvity.`,
		Exposed: true,
		Name:    "raw",
		Stored:  true,
		Type:    "string",
	},
	"traces": {
		AllowedChoices: []string{},
		BSONFieldName:  "traces",
		ConvertedName:  "Traces",
		Description: `The traces to ingest. If this is set, the raw input field must not be set. This
is the recommended way on how to ingest trace data into Acuvity. This will
ingest
only the necessary core data of a trace.`,
		Exposed: true,
		Name:    "traces",
		Stored:  true,
		SubType: "traceref",
		Type:    "refList",
	},
}

// SparseIngestTracesList represents a list of SparseIngestTraces
type SparseIngestTracesList []*SparseIngestTrace

// Identity returns the identity of the objects in the list.
func (o SparseIngestTracesList) Identity() elemental.Identity {

	return IngestTraceIdentity
}

// Copy returns a pointer to a copy the SparseIngestTracesList.
func (o SparseIngestTracesList) Copy() elemental.Identifiables {

	copy := slices.Clone(o)
	return &copy
}

// Append appends the objects to the a new copy of the SparseIngestTracesList.
func (o SparseIngestTracesList) Append(objects ...elemental.Identifiable) elemental.Identifiables {

	out := slices.Clone(o)
	for _, obj := range objects {
		out = append(out, obj.(*SparseIngestTrace))
	}

	return out
}

// List converts the object to an elemental.IdentifiablesList.
func (o SparseIngestTracesList) List() elemental.IdentifiablesList {

	out := make(elemental.IdentifiablesList, len(o))
	for i := range len(o) {
		out[i] = o[i]
	}

	return out
}

// DefaultOrder returns the default ordering fields of the content.
func (o SparseIngestTracesList) DefaultOrder() []string {

	return []string{}
}

// ToPlain returns the SparseIngestTracesList converted to IngestTracesList.
func (o SparseIngestTracesList) ToPlain() elemental.IdentifiablesList {

	out := make(elemental.IdentifiablesList, len(o))
	for i := range len(o) {
		out[i] = o[i].ToPlain()
	}

	return out
}

// Version returns the version of the content.
func (o SparseIngestTracesList) Version() int {

	return 1
}

// SparseIngestTrace represents the sparse version of a ingesttrace.
type SparseIngestTrace struct {
	// ID is the identifier of the object.
	ID *string `json:"ID,omitempty" msgpack:"ID,omitempty" bson:"-" mapstructure:"ID,omitempty"`

	// The namespace of the object.
	Namespace *string `json:"namespace,omitempty" msgpack:"namespace,omitempty" bson:"namespace,omitempty" mapstructure:"namespace,omitempty"`

	// The principal of the object.
	Principal *Principal `json:"principal,omitempty" msgpack:"principal,omitempty" bson:"principal,omitempty" mapstructure:"principal,omitempty"`

	// The raw OTLP traces in JSON encoded format. If this is set, you must not set the
	// traces field. This will ingest everything about this trace and make it available
	// to Acuvity.
	Raw *string `json:"raw,omitempty" msgpack:"raw,omitempty" bson:"raw,omitempty" mapstructure:"raw,omitempty"`

	// The traces to ingest. If this is set, the raw input field must not be set. This
	// is the recommended way on how to ingest trace data into Acuvity. This will
	// ingest
	// only the necessary core data of a trace.
	Traces *TraceRefsList `json:"traces,omitempty" msgpack:"traces,omitempty" bson:"traces,omitempty" mapstructure:"traces,omitempty"`

	ModelVersion int `json:"-" msgpack:"-" bson:"_modelversion"`
}

// NewSparseIngestTrace returns a new  SparseIngestTrace.
func NewSparseIngestTrace() *SparseIngestTrace {
	return &SparseIngestTrace{}
}

// Identity returns the Identity of the sparse object.
func (o *SparseIngestTrace) Identity() elemental.Identity {

	return IngestTraceIdentity
}

// Identifier returns the value of the sparse object's unique identifier.
func (o *SparseIngestTrace) Identifier() string {

	if o.ID == nil {
		return ""
	}
	return *o.ID
}

// SetIdentifier sets the value of the sparse object's unique identifier.
func (o *SparseIngestTrace) SetIdentifier(id string) {

	if id != "" {
		o.ID = &id
	} else {
		o.ID = nil
	}
}

// GetBSON implements the bson marshaling interface.
// This is used to transparently convert ID to MongoDBID as ObectID.
func (o *SparseIngestTrace) GetBSON() (any, error) {

	if o == nil {
		return nil, nil
	}

	s := &mongoAttributesSparseIngestTrace{}

	if o.ID != nil {
		s.ID = bson.ObjectIdHex(*o.ID)
	}
	if o.Namespace != nil {
		s.Namespace = o.Namespace
	}
	if o.Principal != nil {
		s.Principal = o.Principal
	}
	if o.Raw != nil {
		s.Raw = o.Raw
	}
	if o.Traces != nil {
		s.Traces = o.Traces
	}

	return s, nil
}

// SetBSON implements the bson marshaling interface.
// This is used to transparently convert ID to MongoDBID as ObectID.
func (o *SparseIngestTrace) SetBSON(raw bson.Raw) error {

	if o == nil {
		return nil
	}

	s := &mongoAttributesSparseIngestTrace{}
	if err := raw.Unmarshal(s); err != nil {
		return err
	}

	id := s.ID.Hex()
	o.ID = &id
	if s.Namespace != nil {
		o.Namespace = s.Namespace
	}
	if s.Principal != nil {
		o.Principal = s.Principal
	}
	if s.Raw != nil {
		o.Raw = s.Raw
	}
	if s.Traces != nil {
		o.Traces = s.Traces
	}

	return nil
}

// Version returns the hardcoded version of the model.
func (o *SparseIngestTrace) Version() int {

	return 1
}

// ToPlain returns the plain version of the sparse model.
func (o *SparseIngestTrace) ToPlain() elemental.PlainIdentifiable {

	out := NewIngestTrace()
	if o.ID != nil {
		out.ID = *o.ID
	}
	if o.Namespace != nil {
		out.Namespace = *o.Namespace
	}
	if o.Principal != nil {
		out.Principal = o.Principal
	}
	if o.Raw != nil {
		out.Raw = *o.Raw
	}
	if o.Traces != nil {
		out.Traces = *o.Traces
	}

	return out
}

// GetNamespace returns the Namespace of the receiver.
func (o *SparseIngestTrace) GetNamespace() (out string) {

	if o.Namespace == nil {
		return
	}

	return *o.Namespace
}

// SetNamespace sets the property Namespace of the receiver using the address of the given value.
func (o *SparseIngestTrace) SetNamespace(namespace string) {

	o.Namespace = &namespace
}

// DeepCopy returns a deep copy if the SparseIngestTrace.
func (o *SparseIngestTrace) DeepCopy() *SparseIngestTrace {

	if o == nil {
		return nil
	}

	out := &SparseIngestTrace{}
	o.DeepCopyInto(out)

	return out
}

// DeepCopyInto copies the receiver into the given *SparseIngestTrace.
func (o *SparseIngestTrace) DeepCopyInto(out *SparseIngestTrace) {

	target, err := copystructure.Copy(o)
	if err != nil {
		panic(fmt.Sprintf("Unable to deepcopy SparseIngestTrace: %s", err))
	}

	*out = *target.(*SparseIngestTrace)
}

type mongoAttributesIngestTrace struct {
	ID        bson.ObjectId `bson:"_id,omitempty"`
	Namespace string        `bson:"namespace,omitempty"`
	Principal *Principal    `bson:"principal"`
	Raw       string        `bson:"raw"`
	Traces    TraceRefsList `bson:"traces"`
}
type mongoAttributesSparseIngestTrace struct {
	ID        bson.ObjectId  `bson:"_id,omitempty"`
	Namespace *string        `bson:"namespace,omitempty"`
	Principal *Principal     `bson:"principal,omitempty"`
	Raw       *string        `bson:"raw,omitempty"`
	Traces    *TraceRefsList `bson:"traces,omitempty"`
}
