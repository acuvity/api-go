// Code generated by elegen. DO NOT EDIT.
// Source: go.acuvity.ai/elemental (templates/model.gotpl)

package api

import (
	"fmt"
	"slices"

	"github.com/globalsign/mgo/bson"
	"github.com/mitchellh/copystructure"
	"go.acuvity.ai/elemental"
)

// DigestReportRequestIdentity represents the Identity of the object.
var DigestReportRequestIdentity = elemental.Identity{
	Name:     "digestreportrequest",
	Category: "digestreportrequests",
	Package:  "relae",
	Private:  false,
}

// DigestReportRequestsList represents a list of DigestReportRequests
type DigestReportRequestsList []*DigestReportRequest

// Identity returns the identity of the objects in the list.
func (o DigestReportRequestsList) Identity() elemental.Identity {

	return DigestReportRequestIdentity
}

// Copy returns a pointer to a copy the DigestReportRequestsList.
func (o DigestReportRequestsList) Copy() elemental.Identifiables {

	out := slices.Clone(o)
	return &out
}

// Append appends the objects to the a new copy of the DigestReportRequestsList.
func (o DigestReportRequestsList) Append(objects ...elemental.Identifiable) elemental.Identifiables {

	out := slices.Clone(o)
	for _, obj := range objects {
		out = append(out, obj.(*DigestReportRequest))
	}

	return out
}

// List converts the object to an elemental.IdentifiablesList.
func (o DigestReportRequestsList) List() elemental.IdentifiablesList {

	out := make(elemental.IdentifiablesList, len(o))
	for i := range len(o) {
		out[i] = o[i]
	}

	return out
}

// DefaultOrder returns the default ordering fields of the content.
func (o DigestReportRequestsList) DefaultOrder() []string {

	return []string{}
}

// ToSparse returns the DigestReportRequestsList converted to SparseDigestReportRequestsList.
// Objects in the list will only contain the given fields. No field means entire field set.
func (o DigestReportRequestsList) ToSparse(fields ...string) elemental.Identifiables {

	out := make(SparseDigestReportRequestsList, len(o))
	for i := range len(o) {
		out[i] = o[i].ToSparse(fields...).(*SparseDigestReportRequest)
	}

	return out
}

// Version returns the version of the content.
func (o DigestReportRequestsList) Version() int {

	return 1
}

// DigestReportRequest represents the model of a digestreportrequest
type DigestReportRequest struct {
	// The list of recipients to send the report to. If empty, the list from
	// orgsettings will be used.
	Recipients []string `json:"recipients" msgpack:"recipients" bson:"-" mapstructure:"recipients,omitempty"`

	// If enabled, save the report into database. Note that this will make the report
	// being considered the last auto generated report, and all the next one trends
	// will be calculated from this one. This is mostly never what you want to do.
	Save bool `json:"save" msgpack:"save" bson:"-" mapstructure:"save,omitempty"`

	// The time window for the report. The report will span from `[now() - tw, now()]`.
	// 24h is the minimum.
	TimeWindow string `json:"timeWindow" msgpack:"timeWindow" bson:"-" mapstructure:"timeWindow,omitempty"`

	ModelVersion int `json:"-" msgpack:"-" bson:"_modelversion"`
}

// NewDigestReportRequest returns a new *DigestReportRequest
func NewDigestReportRequest() *DigestReportRequest {

	return &DigestReportRequest{
		ModelVersion: 1,
		Recipients:   []string{},
		TimeWindow:   "24h",
	}
}

// Identity returns the Identity of the object.
func (o *DigestReportRequest) Identity() elemental.Identity {

	return DigestReportRequestIdentity
}

// Identifier returns the value of the object's unique identifier.
func (o *DigestReportRequest) Identifier() string {

	return ""
}

// SetIdentifier sets the value of the object's unique identifier.
func (o *DigestReportRequest) SetIdentifier(id string) {

}

// GetBSON implements the bson marshaling interface.
// This is used to transparently convert ID to MongoDBID as ObectID.
func (o *DigestReportRequest) GetBSON() (any, error) {

	if o == nil {
		return nil, nil
	}

	s := &mongoAttributesDigestReportRequest{}

	return s, nil
}

// SetBSON implements the bson marshaling interface.
// This is used to transparently convert ID to MongoDBID as ObectID.
func (o *DigestReportRequest) SetBSON(raw bson.Raw) error {

	if o == nil {
		return nil
	}

	s := &mongoAttributesDigestReportRequest{}
	if err := raw.Unmarshal(s); err != nil {
		return err
	}

	return nil
}

// Version returns the hardcoded version of the model.
func (o *DigestReportRequest) Version() int {

	return 1
}

// BleveType implements the bleve.Classifier Interface.
func (o *DigestReportRequest) BleveType() string {

	return "digestreportrequest"
}

// DefaultOrder returns the list of default ordering fields.
func (o *DigestReportRequest) DefaultOrder() []string {

	return []string{}
}

// Doc returns the documentation for the object
func (o *DigestReportRequest) Doc() string {

	return `Represents a request to create a digest report.`
}

func (o *DigestReportRequest) String() string {

	return fmt.Sprintf("<%s:%s>", o.Identity().Name, o.Identifier())
}

// ToSparse returns the sparse version of the model.
// The returned object will only contain the given fields. No field means entire field set.
func (o *DigestReportRequest) ToSparse(fields ...string) elemental.SparseIdentifiable {

	if len(fields) == 0 {
		// nolint: goimports
		return &SparseDigestReportRequest{
			Recipients: &o.Recipients,
			Save:       &o.Save,
			TimeWindow: &o.TimeWindow,
		}
	}

	sp := &SparseDigestReportRequest{}
	for _, f := range fields {
		switch f {
		case "recipients":
			sp.Recipients = &(o.Recipients)
		case "save":
			sp.Save = &(o.Save)
		case "timeWindow":
			sp.TimeWindow = &(o.TimeWindow)
		}
	}

	return sp
}

// Patch apply the non nil value of a *SparseDigestReportRequest to the object.
func (o *DigestReportRequest) Patch(sparse elemental.SparseIdentifiable) {
	if !sparse.Identity().IsEqual(o.Identity()) {
		panic("cannot patch from a parse with different identity")
	}

	so := sparse.(*SparseDigestReportRequest)
	if so.Recipients != nil {
		o.Recipients = *so.Recipients
	}
	if so.Save != nil {
		o.Save = *so.Save
	}
	if so.TimeWindow != nil {
		o.TimeWindow = *so.TimeWindow
	}
}

// DeepCopy returns a deep copy if the DigestReportRequest.
func (o *DigestReportRequest) DeepCopy() *DigestReportRequest {

	if o == nil {
		return nil
	}

	out := &DigestReportRequest{}
	o.DeepCopyInto(out)

	return out
}

// DeepCopyInto copies the receiver into the given *DigestReportRequest.
func (o *DigestReportRequest) DeepCopyInto(out *DigestReportRequest) {

	target, err := copystructure.Copy(o)
	if err != nil {
		panic(fmt.Sprintf("Unable to deepcopy DigestReportRequest: %s", err))
	}

	*out = *target.(*DigestReportRequest)
}

// Validate valides the current information stored into the structure.
func (o *DigestReportRequest) Validate() error {

	errors := elemental.Errors{}
	requiredErrors := elemental.Errors{}

	if err := ValidateEmails("recipients", o.Recipients); err != nil {
		errors = errors.Append(err)
	}

	if err := ValidateDuration("timeWindow", o.TimeWindow); err != nil {
		errors = errors.Append(err)
	}

	if len(requiredErrors) > 0 {
		return requiredErrors
	}

	if len(errors) > 0 {
		return errors
	}

	return nil
}

// SpecificationForAttribute returns the AttributeSpecification for the given attribute name key.
func (*DigestReportRequest) SpecificationForAttribute(name string) elemental.AttributeSpecification {

	if v, ok := DigestReportRequestAttributesMap[name]; ok {
		return v
	}

	// We could not find it, so let's check on the lower case indexed spec map
	return DigestReportRequestLowerCaseAttributesMap[name]
}

// AttributeSpecifications returns the full attribute specifications map.
func (*DigestReportRequest) AttributeSpecifications() map[string]elemental.AttributeSpecification {

	return DigestReportRequestAttributesMap
}

// ValueForAttribute returns the value for the given attribute.
// This is a very advanced function that you should not need but in some
// very specific use cases.
func (o *DigestReportRequest) ValueForAttribute(name string) any {

	switch name {
	case "recipients":
		return o.Recipients
	case "save":
		return o.Save
	case "timeWindow":
		return o.TimeWindow
	}

	return nil
}

// DigestReportRequestAttributesMap represents the map of attribute for DigestReportRequest.
var DigestReportRequestAttributesMap = map[string]elemental.AttributeSpecification{
	"Recipients": {
		AllowedChoices: []string{},
		ConvertedName:  "Recipients",
		Description: `The list of recipients to send the report to. If empty, the list from
orgsettings will be used.`,
		Exposed: true,
		Name:    "recipients",
		SubType: "string",
		Type:    "list",
	},
	"Save": {
		AllowedChoices: []string{},
		ConvertedName:  "Save",
		Description: `If enabled, save the report into database. Note that this will make the report
being considered the last auto generated report, and all the next one trends
will be calculated from this one. This is mostly never what you want to do.`,
		Exposed: true,
		Name:    "save",
		Type:    "boolean",
	},
	"TimeWindow": {
		AllowedChoices: []string{},
		ConvertedName:  "TimeWindow",
		DefaultValue:   "24h",
		Description: `The time window for the report. The report will span from ` + "`" + `[now() - tw, now()]` + "`" + `.
24h is the minimum.`,
		Exposed: true,
		Name:    "timeWindow",
		Type:    "string",
	},
}

// DigestReportRequestLowerCaseAttributesMap represents the map of attribute for DigestReportRequest.
var DigestReportRequestLowerCaseAttributesMap = map[string]elemental.AttributeSpecification{
	"recipients": {
		AllowedChoices: []string{},
		ConvertedName:  "Recipients",
		Description: `The list of recipients to send the report to. If empty, the list from
orgsettings will be used.`,
		Exposed: true,
		Name:    "recipients",
		SubType: "string",
		Type:    "list",
	},
	"save": {
		AllowedChoices: []string{},
		ConvertedName:  "Save",
		Description: `If enabled, save the report into database. Note that this will make the report
being considered the last auto generated report, and all the next one trends
will be calculated from this one. This is mostly never what you want to do.`,
		Exposed: true,
		Name:    "save",
		Type:    "boolean",
	},
	"timewindow": {
		AllowedChoices: []string{},
		ConvertedName:  "TimeWindow",
		DefaultValue:   "24h",
		Description: `The time window for the report. The report will span from ` + "`" + `[now() - tw, now()]` + "`" + `.
24h is the minimum.`,
		Exposed: true,
		Name:    "timeWindow",
		Type:    "string",
	},
}

// SparseDigestReportRequestsList represents a list of SparseDigestReportRequests
type SparseDigestReportRequestsList []*SparseDigestReportRequest

// Identity returns the identity of the objects in the list.
func (o SparseDigestReportRequestsList) Identity() elemental.Identity {

	return DigestReportRequestIdentity
}

// Copy returns a pointer to a copy the SparseDigestReportRequestsList.
func (o SparseDigestReportRequestsList) Copy() elemental.Identifiables {

	copy := slices.Clone(o)
	return &copy
}

// Append appends the objects to the a new copy of the SparseDigestReportRequestsList.
func (o SparseDigestReportRequestsList) Append(objects ...elemental.Identifiable) elemental.Identifiables {

	out := slices.Clone(o)
	for _, obj := range objects {
		out = append(out, obj.(*SparseDigestReportRequest))
	}

	return out
}

// List converts the object to an elemental.IdentifiablesList.
func (o SparseDigestReportRequestsList) List() elemental.IdentifiablesList {

	out := make(elemental.IdentifiablesList, len(o))
	for i := range len(o) {
		out[i] = o[i]
	}

	return out
}

// DefaultOrder returns the default ordering fields of the content.
func (o SparseDigestReportRequestsList) DefaultOrder() []string {

	return []string{}
}

// ToPlain returns the SparseDigestReportRequestsList converted to DigestReportRequestsList.
func (o SparseDigestReportRequestsList) ToPlain() elemental.IdentifiablesList {

	out := make(elemental.IdentifiablesList, len(o))
	for i := range len(o) {
		out[i] = o[i].ToPlain()
	}

	return out
}

// Version returns the version of the content.
func (o SparseDigestReportRequestsList) Version() int {

	return 1
}

// SparseDigestReportRequest represents the sparse version of a digestreportrequest.
type SparseDigestReportRequest struct {
	// The list of recipients to send the report to. If empty, the list from
	// orgsettings will be used.
	Recipients *[]string `json:"recipients,omitempty" msgpack:"recipients,omitempty" bson:"-" mapstructure:"recipients,omitempty"`

	// If enabled, save the report into database. Note that this will make the report
	// being considered the last auto generated report, and all the next one trends
	// will be calculated from this one. This is mostly never what you want to do.
	Save *bool `json:"save,omitempty" msgpack:"save,omitempty" bson:"-" mapstructure:"save,omitempty"`

	// The time window for the report. The report will span from `[now() - tw, now()]`.
	// 24h is the minimum.
	TimeWindow *string `json:"timeWindow,omitempty" msgpack:"timeWindow,omitempty" bson:"-" mapstructure:"timeWindow,omitempty"`

	ModelVersion int `json:"-" msgpack:"-" bson:"_modelversion"`
}

// NewSparseDigestReportRequest returns a new  SparseDigestReportRequest.
func NewSparseDigestReportRequest() *SparseDigestReportRequest {
	return &SparseDigestReportRequest{}
}

// Identity returns the Identity of the sparse object.
func (o *SparseDigestReportRequest) Identity() elemental.Identity {

	return DigestReportRequestIdentity
}

// Identifier returns the value of the sparse object's unique identifier.
func (o *SparseDigestReportRequest) Identifier() string {

	return ""
}

// SetIdentifier sets the value of the sparse object's unique identifier.
func (o *SparseDigestReportRequest) SetIdentifier(id string) {

}

// GetBSON implements the bson marshaling interface.
// This is used to transparently convert ID to MongoDBID as ObectID.
func (o *SparseDigestReportRequest) GetBSON() (any, error) {

	if o == nil {
		return nil, nil
	}

	s := &mongoAttributesSparseDigestReportRequest{}

	return s, nil
}

// SetBSON implements the bson marshaling interface.
// This is used to transparently convert ID to MongoDBID as ObectID.
func (o *SparseDigestReportRequest) SetBSON(raw bson.Raw) error {

	if o == nil {
		return nil
	}

	s := &mongoAttributesSparseDigestReportRequest{}
	if err := raw.Unmarshal(s); err != nil {
		return err
	}

	return nil
}

// Version returns the hardcoded version of the model.
func (o *SparseDigestReportRequest) Version() int {

	return 1
}

// ToPlain returns the plain version of the sparse model.
func (o *SparseDigestReportRequest) ToPlain() elemental.PlainIdentifiable {

	out := NewDigestReportRequest()
	if o.Recipients != nil {
		out.Recipients = *o.Recipients
	}
	if o.Save != nil {
		out.Save = *o.Save
	}
	if o.TimeWindow != nil {
		out.TimeWindow = *o.TimeWindow
	}

	return out
}

// DeepCopy returns a deep copy if the SparseDigestReportRequest.
func (o *SparseDigestReportRequest) DeepCopy() *SparseDigestReportRequest {

	if o == nil {
		return nil
	}

	out := &SparseDigestReportRequest{}
	o.DeepCopyInto(out)

	return out
}

// DeepCopyInto copies the receiver into the given *SparseDigestReportRequest.
func (o *SparseDigestReportRequest) DeepCopyInto(out *SparseDigestReportRequest) {

	target, err := copystructure.Copy(o)
	if err != nil {
		panic(fmt.Sprintf("Unable to deepcopy SparseDigestReportRequest: %s", err))
	}

	*out = *target.(*SparseDigestReportRequest)
}

type mongoAttributesDigestReportRequest struct {
}
type mongoAttributesSparseDigestReportRequest struct {
}
