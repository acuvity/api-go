// Code generated by elegen. DO NOT EDIT.
// Source: go.acuvity.ai/elemental (templates/model.gotpl)

package api

import (
	"fmt"

	"github.com/globalsign/mgo/bson"
	"github.com/mitchellh/copystructure"
	"go.acuvity.ai/elemental"
)

// AppComponentEgressModeValue represents the possible values for attribute "egressMode".
type AppComponentEgressModeValue string

const (
	// AppComponentEgressModeDisabled represents the value Disabled.
	AppComponentEgressModeDisabled AppComponentEgressModeValue = "Disabled"

	// AppComponentEgressModeInline represents the value Inline.
	AppComponentEgressModeInline AppComponentEgressModeValue = "Inline"

	// AppComponentEgressModeMirror represents the value Mirror.
	AppComponentEgressModeMirror AppComponentEgressModeValue = "Mirror"
)

// AppComponentIdentity represents the Identity of the object.
var AppComponentIdentity = elemental.Identity{
	Name:     "appcomponent",
	Category: "appcomponents",
	Package:  "lain",
	Private:  false,
}

// AppComponentsList represents a list of AppComponents
type AppComponentsList []*AppComponent

// Identity returns the identity of the objects in the list.
func (o AppComponentsList) Identity() elemental.Identity {

	return AppComponentIdentity
}

// Copy returns a pointer to a copy the AppComponentsList.
func (o AppComponentsList) Copy() elemental.Identifiables {

	out := append(AppComponentsList{}, o...)
	return &out
}

// Append appends the objects to the a new copy of the AppComponentsList.
func (o AppComponentsList) Append(objects ...elemental.Identifiable) elemental.Identifiables {

	out := append(AppComponentsList{}, o...)
	for _, obj := range objects {
		out = append(out, obj.(*AppComponent))
	}

	return out
}

// List converts the object to an elemental.IdentifiablesList.
func (o AppComponentsList) List() elemental.IdentifiablesList {

	out := make(elemental.IdentifiablesList, len(o))
	for i := 0; i < len(o); i++ {
		out[i] = o[i]
	}

	return out
}

// DefaultOrder returns the default ordering fields of the content.
func (o AppComponentsList) DefaultOrder() []string {

	return []string{}
}

// ToSparse returns the AppComponentsList converted to SparseAppComponentsList.
// Objects in the list will only contain the given fields. No field means entire field set.
func (o AppComponentsList) ToSparse(fields ...string) elemental.Identifiables {

	out := make(SparseAppComponentsList, len(o))
	for i := 0; i < len(o); i++ {
		out[i] = o[i].ToSparse(fields...).(*SparseAppComponent)
	}

	return out
}

// Version returns the version of the content.
func (o AppComponentsList) Version() int {

	return 1
}

// AppComponent represents the model of a appcomponent
type AppComponent struct {
	// EXPERIMENTAL. If egress mode is inline, the Apex will act as a transparent
	// proxy. The certificates that will be served by the proxy are generated by the
	// Apex itself which are issued by a dynamic TLS CA. If you enable this feature,
	// the matching app component instances will get the CA certificate dynamically
	// injected into the system trust store.
	CAInjectionEnabled bool `json:"CAInjectionEnabled" msgpack:"CAInjectionEnabled" bson:"cainjectionenabled" mapstructure:"CAInjectionEnabled,omitempty"`

	// The description of the component.
	Description string `json:"description" msgpack:"description" bson:"description" mapstructure:"description,omitempty"`

	// The egress datapath mode to use for network traffic going out to providers for
	// this application component. By default this is set to disabled. However, this
	// can be changed to mirror traffic where the Apex is only providing visibility
	// with no possibility of any access or content policies to take effect. Or this
	// can be set to inline in which case all traffic to providers will be redirected
	// to the Apex which acts as a transparent proxy in this case. In this mode access
	// and content policies will take effect.
	EgressMode AppComponentEgressModeValue `json:"egressMode" msgpack:"egressMode" bson:"egressmode" mapstructure:"egressMode,omitempty"`

	// The ingress provider configurations to serve for this application. If this app
	// component serves multiple ingress providers, you must define an ingress provider
	// config for every single one of them. If you need access to the same ingress
	// provider over different port configurations (for example one serving https while
	// another port serves plain http), then you must define two ingress provider
	// configurations and reuse the same provider name within the configuration.
	IngressProviderConfigs IngressProviderConfigsList `json:"ingressProviderConfigs,omitempty" msgpack:"ingressProviderConfigs,omitempty" bson:"ingressproviderconfigs,omitempty" mapstructure:"ingressProviderConfigs,omitempty"`

	// The component name.
	Name string `json:"name" msgpack:"name" bson:"name" mapstructure:"name,omitempty"`

	// If given, this is the provider name that this component represents. This
	// **MUST** match the name of a provider.
	ProviderName string `json:"providerName,omitempty" msgpack:"providerName,omitempty" bson:"providername,omitempty" mapstructure:"providerName,omitempty"`

	// A tag expression that identify an application component based on downstream
	// labels.
	Selector [][]string `json:"selector,omitempty" msgpack:"selector,omitempty" bson:"selector,omitempty" mapstructure:"selector,omitempty"`

	// The token for the current component. Only populated by the backend when the
	// caller's
	// claim match the parents app.subject.
	Token string `json:"token,omitempty" msgpack:"token,omitempty" bson:"-" mapstructure:"token,omitempty"`

	ModelVersion int `json:"-" msgpack:"-" bson:"_modelversion"`
}

// NewAppComponent returns a new *AppComponent
func NewAppComponent() *AppComponent {

	return &AppComponent{
		ModelVersion: 1,
		EgressMode:   AppComponentEgressModeDisabled,
		Selector:     [][]string{},
	}
}

// Identity returns the Identity of the object.
func (o *AppComponent) Identity() elemental.Identity {

	return AppComponentIdentity
}

// Identifier returns the value of the object's unique identifier.
func (o *AppComponent) Identifier() string {

	return ""
}

// SetIdentifier sets the value of the object's unique identifier.
func (o *AppComponent) SetIdentifier(id string) {

}

// GetBSON implements the bson marshaling interface.
// This is used to transparently convert ID to MongoDBID as ObectID.
func (o *AppComponent) GetBSON() (any, error) {

	if o == nil {
		return nil, nil
	}

	s := &mongoAttributesAppComponent{}

	s.CAInjectionEnabled = o.CAInjectionEnabled
	s.Description = o.Description
	s.EgressMode = o.EgressMode
	s.IngressProviderConfigs = o.IngressProviderConfigs
	s.Name = o.Name
	s.ProviderName = o.ProviderName
	s.Selector = o.Selector

	return s, nil
}

// SetBSON implements the bson marshaling interface.
// This is used to transparently convert ID to MongoDBID as ObectID.
func (o *AppComponent) SetBSON(raw bson.Raw) error {

	if o == nil {
		return nil
	}

	s := &mongoAttributesAppComponent{}
	if err := raw.Unmarshal(s); err != nil {
		return err
	}

	o.CAInjectionEnabled = s.CAInjectionEnabled
	o.Description = s.Description
	o.EgressMode = s.EgressMode
	o.IngressProviderConfigs = s.IngressProviderConfigs
	o.Name = s.Name
	o.ProviderName = s.ProviderName
	o.Selector = s.Selector

	return nil
}

// Version returns the hardcoded version of the model.
func (o *AppComponent) Version() int {

	return 1
}

// BleveType implements the bleve.Classifier Interface.
func (o *AppComponent) BleveType() string {

	return "appcomponent"
}

// DefaultOrder returns the list of default ordering fields.
func (o *AppComponent) DefaultOrder() []string {

	return []string{}
}

// Doc returns the documentation for the object
func (o *AppComponent) Doc() string {

	return `Represents a particular component of the application.`
}

func (o *AppComponent) String() string {

	return fmt.Sprintf("<%s:%s>", o.Identity().Name, o.Identifier())
}

// ToSparse returns the sparse version of the model.
// The returned object will only contain the given fields. No field means entire field set.
func (o *AppComponent) ToSparse(fields ...string) elemental.SparseIdentifiable {

	if len(fields) == 0 {
		// nolint: goimports
		return &SparseAppComponent{
			CAInjectionEnabled:     &o.CAInjectionEnabled,
			Description:            &o.Description,
			EgressMode:             &o.EgressMode,
			IngressProviderConfigs: &o.IngressProviderConfigs,
			Name:                   &o.Name,
			ProviderName:           &o.ProviderName,
			Selector:               &o.Selector,
			Token:                  &o.Token,
		}
	}

	sp := &SparseAppComponent{}
	for _, f := range fields {
		switch f {
		case "CAInjectionEnabled":
			sp.CAInjectionEnabled = &(o.CAInjectionEnabled)
		case "description":
			sp.Description = &(o.Description)
		case "egressMode":
			sp.EgressMode = &(o.EgressMode)
		case "ingressProviderConfigs":
			sp.IngressProviderConfigs = &(o.IngressProviderConfigs)
		case "name":
			sp.Name = &(o.Name)
		case "providerName":
			sp.ProviderName = &(o.ProviderName)
		case "selector":
			sp.Selector = &(o.Selector)
		case "token":
			sp.Token = &(o.Token)
		}
	}

	return sp
}

// Patch apply the non nil value of a *SparseAppComponent to the object.
func (o *AppComponent) Patch(sparse elemental.SparseIdentifiable) {
	if !sparse.Identity().IsEqual(o.Identity()) {
		panic("cannot patch from a parse with different identity")
	}

	so := sparse.(*SparseAppComponent)
	if so.CAInjectionEnabled != nil {
		o.CAInjectionEnabled = *so.CAInjectionEnabled
	}
	if so.Description != nil {
		o.Description = *so.Description
	}
	if so.EgressMode != nil {
		o.EgressMode = *so.EgressMode
	}
	if so.IngressProviderConfigs != nil {
		o.IngressProviderConfigs = *so.IngressProviderConfigs
	}
	if so.Name != nil {
		o.Name = *so.Name
	}
	if so.ProviderName != nil {
		o.ProviderName = *so.ProviderName
	}
	if so.Selector != nil {
		o.Selector = *so.Selector
	}
	if so.Token != nil {
		o.Token = *so.Token
	}
}

// DeepCopy returns a deep copy if the AppComponent.
func (o *AppComponent) DeepCopy() *AppComponent {

	if o == nil {
		return nil
	}

	out := &AppComponent{}
	o.DeepCopyInto(out)

	return out
}

// DeepCopyInto copies the receiver into the given *AppComponent.
func (o *AppComponent) DeepCopyInto(out *AppComponent) {

	target, err := copystructure.Copy(o)
	if err != nil {
		panic(fmt.Sprintf("Unable to deepcopy AppComponent: %s", err))
	}

	*out = *target.(*AppComponent)
}

// Validate valides the current information stored into the structure.
func (o *AppComponent) Validate() error {

	errors := elemental.Errors{}
	requiredErrors := elemental.Errors{}

	if err := elemental.ValidateStringInList("egressMode", string(o.EgressMode), []string{"Disabled", "Mirror", "Inline"}, false); err != nil {
		errors = errors.Append(err)
	}

	for _, sub := range o.IngressProviderConfigs {
		elemental.ResetDefaultForZeroValues(sub)
		if err := sub.Validate(); err != nil {
			errors = errors.Append(err)
		}
	}

	if err := elemental.ValidateRequiredString("name", o.Name); err != nil {
		requiredErrors = requiredErrors.Append(err)
	}

	if err := elemental.ValidatePattern("name", o.Name, `^[a-zA-Z0-9-_]+$`, `must only contain alpha numerical characters, '-' or '_'.`, true); err != nil {
		errors = errors.Append(err)
	}

	if err := ValidateTagsExpression("selector", o.Selector); err != nil {
		errors = errors.Append(err)
	}

	if len(requiredErrors) > 0 {
		return requiredErrors
	}

	if len(errors) > 0 {
		return errors
	}

	return nil
}

// SpecificationForAttribute returns the AttributeSpecification for the given attribute name key.
func (*AppComponent) SpecificationForAttribute(name string) elemental.AttributeSpecification {

	if v, ok := AppComponentAttributesMap[name]; ok {
		return v
	}

	// We could not find it, so let's check on the lower case indexed spec map
	return AppComponentLowerCaseAttributesMap[name]
}

// AttributeSpecifications returns the full attribute specifications map.
func (*AppComponent) AttributeSpecifications() map[string]elemental.AttributeSpecification {

	return AppComponentAttributesMap
}

// ValueForAttribute returns the value for the given attribute.
// This is a very advanced function that you should not need but in some
// very specific use cases.
func (o *AppComponent) ValueForAttribute(name string) any {

	switch name {
	case "CAInjectionEnabled":
		return o.CAInjectionEnabled
	case "description":
		return o.Description
	case "egressMode":
		return o.EgressMode
	case "ingressProviderConfigs":
		return o.IngressProviderConfigs
	case "name":
		return o.Name
	case "providerName":
		return o.ProviderName
	case "selector":
		return o.Selector
	case "token":
		return o.Token
	}

	return nil
}

// AppComponentAttributesMap represents the map of attribute for AppComponent.
var AppComponentAttributesMap = map[string]elemental.AttributeSpecification{
	"CAInjectionEnabled": {
		AllowedChoices: []string{},
		BSONFieldName:  "cainjectionenabled",
		ConvertedName:  "CAInjectionEnabled",
		Description: `EXPERIMENTAL. If egress mode is inline, the Apex will act as a transparent
proxy. The certificates that will be served by the proxy are generated by the
Apex itself which are issued by a dynamic TLS CA. If you enable this feature,
the matching app component instances will get the CA certificate dynamically
injected into the system trust store.`,
		Exposed: true,
		Name:    "CAInjectionEnabled",
		Stored:  true,
		Type:    "boolean",
	},
	"Description": {
		AllowedChoices: []string{},
		BSONFieldName:  "description",
		ConvertedName:  "Description",
		Description:    `The description of the component.`,
		Exposed:        true,
		Name:           "description",
		Stored:         true,
		Type:           "string",
	},
	"EgressMode": {
		AllowedChoices: []string{"Disabled", "Mirror", "Inline"},
		BSONFieldName:  "egressmode",
		ConvertedName:  "EgressMode",
		DefaultValue:   AppComponentEgressModeDisabled,
		Description: `The egress datapath mode to use for network traffic going out to providers for
this application component. By default this is set to disabled. However, this
can be changed to mirror traffic where the Apex is only providing visibility
with no possibility of any access or content policies to take effect. Or this
can be set to inline in which case all traffic to providers will be redirected
to the Apex which acts as a transparent proxy in this case. In this mode access
and content policies will take effect.`,
		Exposed: true,
		Name:    "egressMode",
		Stored:  true,
		Type:    "enum",
	},
	"IngressProviderConfigs": {
		AllowedChoices: []string{},
		BSONFieldName:  "ingressproviderconfigs",
		ConvertedName:  "IngressProviderConfigs",
		Description: `The ingress provider configurations to serve for this application. If this app
component serves multiple ingress providers, you must define an ingress provider
config for every single one of them. If you need access to the same ingress
provider over different port configurations (for example one serving https while
another port serves plain http), then you must define two ingress provider
configurations and reuse the same provider name within the configuration.`,
		Exposed: true,
		Name:    "ingressProviderConfigs",
		Stored:  true,
		SubType: "ingressproviderconfig",
		Type:    "refList",
	},
	"Name": {
		AllowedChars:   `^[a-zA-Z0-9-_]+$`,
		AllowedChoices: []string{},
		BSONFieldName:  "name",
		ConvertedName:  "Name",
		Description:    `The component name.`,
		Exposed:        true,
		Name:           "name",
		Required:       true,
		Stored:         true,
		Type:           "string",
	},
	"ProviderName": {
		AllowedChoices: []string{},
		BSONFieldName:  "providername",
		ConvertedName:  "ProviderName",
		Description: `If given, this is the provider name that this component represents. This
**MUST** match the name of a provider.`,
		Exposed: true,
		Name:    "providerName",
		Stored:  true,
		Type:    "string",
	},
	"Selector": {
		AllowedChoices: []string{},
		BSONFieldName:  "selector",
		ConvertedName:  "Selector",
		Description: `A tag expression that identify an application component based on downstream
labels.`,
		Exposed: true,
		Name:    "selector",
		Stored:  true,
		SubType: "[][]string",
		Type:    "external",
	},
	"Token": {
		AllowedChoices: []string{},
		Autogenerated:  true,
		ConvertedName:  "Token",
		Description: `The token for the current component. Only populated by the backend when the
caller's
claim match the parents app.subject.`,
		Exposed:   true,
		Name:      "token",
		ReadOnly:  true,
		Transient: true,
		Type:      "string",
	},
}

// AppComponentLowerCaseAttributesMap represents the map of attribute for AppComponent.
var AppComponentLowerCaseAttributesMap = map[string]elemental.AttributeSpecification{
	"cainjectionenabled": {
		AllowedChoices: []string{},
		BSONFieldName:  "cainjectionenabled",
		ConvertedName:  "CAInjectionEnabled",
		Description: `EXPERIMENTAL. If egress mode is inline, the Apex will act as a transparent
proxy. The certificates that will be served by the proxy are generated by the
Apex itself which are issued by a dynamic TLS CA. If you enable this feature,
the matching app component instances will get the CA certificate dynamically
injected into the system trust store.`,
		Exposed: true,
		Name:    "CAInjectionEnabled",
		Stored:  true,
		Type:    "boolean",
	},
	"description": {
		AllowedChoices: []string{},
		BSONFieldName:  "description",
		ConvertedName:  "Description",
		Description:    `The description of the component.`,
		Exposed:        true,
		Name:           "description",
		Stored:         true,
		Type:           "string",
	},
	"egressmode": {
		AllowedChoices: []string{"Disabled", "Mirror", "Inline"},
		BSONFieldName:  "egressmode",
		ConvertedName:  "EgressMode",
		DefaultValue:   AppComponentEgressModeDisabled,
		Description: `The egress datapath mode to use for network traffic going out to providers for
this application component. By default this is set to disabled. However, this
can be changed to mirror traffic where the Apex is only providing visibility
with no possibility of any access or content policies to take effect. Or this
can be set to inline in which case all traffic to providers will be redirected
to the Apex which acts as a transparent proxy in this case. In this mode access
and content policies will take effect.`,
		Exposed: true,
		Name:    "egressMode",
		Stored:  true,
		Type:    "enum",
	},
	"ingressproviderconfigs": {
		AllowedChoices: []string{},
		BSONFieldName:  "ingressproviderconfigs",
		ConvertedName:  "IngressProviderConfigs",
		Description: `The ingress provider configurations to serve for this application. If this app
component serves multiple ingress providers, you must define an ingress provider
config for every single one of them. If you need access to the same ingress
provider over different port configurations (for example one serving https while
another port serves plain http), then you must define two ingress provider
configurations and reuse the same provider name within the configuration.`,
		Exposed: true,
		Name:    "ingressProviderConfigs",
		Stored:  true,
		SubType: "ingressproviderconfig",
		Type:    "refList",
	},
	"name": {
		AllowedChars:   `^[a-zA-Z0-9-_]+$`,
		AllowedChoices: []string{},
		BSONFieldName:  "name",
		ConvertedName:  "Name",
		Description:    `The component name.`,
		Exposed:        true,
		Name:           "name",
		Required:       true,
		Stored:         true,
		Type:           "string",
	},
	"providername": {
		AllowedChoices: []string{},
		BSONFieldName:  "providername",
		ConvertedName:  "ProviderName",
		Description: `If given, this is the provider name that this component represents. This
**MUST** match the name of a provider.`,
		Exposed: true,
		Name:    "providerName",
		Stored:  true,
		Type:    "string",
	},
	"selector": {
		AllowedChoices: []string{},
		BSONFieldName:  "selector",
		ConvertedName:  "Selector",
		Description: `A tag expression that identify an application component based on downstream
labels.`,
		Exposed: true,
		Name:    "selector",
		Stored:  true,
		SubType: "[][]string",
		Type:    "external",
	},
	"token": {
		AllowedChoices: []string{},
		Autogenerated:  true,
		ConvertedName:  "Token",
		Description: `The token for the current component. Only populated by the backend when the
caller's
claim match the parents app.subject.`,
		Exposed:   true,
		Name:      "token",
		ReadOnly:  true,
		Transient: true,
		Type:      "string",
	},
}

// SparseAppComponentsList represents a list of SparseAppComponents
type SparseAppComponentsList []*SparseAppComponent

// Identity returns the identity of the objects in the list.
func (o SparseAppComponentsList) Identity() elemental.Identity {

	return AppComponentIdentity
}

// Copy returns a pointer to a copy the SparseAppComponentsList.
func (o SparseAppComponentsList) Copy() elemental.Identifiables {

	copy := append(SparseAppComponentsList{}, o...)
	return &copy
}

// Append appends the objects to the a new copy of the SparseAppComponentsList.
func (o SparseAppComponentsList) Append(objects ...elemental.Identifiable) elemental.Identifiables {

	out := append(SparseAppComponentsList{}, o...)
	for _, obj := range objects {
		out = append(out, obj.(*SparseAppComponent))
	}

	return out
}

// List converts the object to an elemental.IdentifiablesList.
func (o SparseAppComponentsList) List() elemental.IdentifiablesList {

	out := make(elemental.IdentifiablesList, len(o))
	for i := 0; i < len(o); i++ {
		out[i] = o[i]
	}

	return out
}

// DefaultOrder returns the default ordering fields of the content.
func (o SparseAppComponentsList) DefaultOrder() []string {

	return []string{}
}

// ToPlain returns the SparseAppComponentsList converted to AppComponentsList.
func (o SparseAppComponentsList) ToPlain() elemental.IdentifiablesList {

	out := make(elemental.IdentifiablesList, len(o))
	for i := 0; i < len(o); i++ {
		out[i] = o[i].ToPlain()
	}

	return out
}

// Version returns the version of the content.
func (o SparseAppComponentsList) Version() int {

	return 1
}

// SparseAppComponent represents the sparse version of a appcomponent.
type SparseAppComponent struct {
	// EXPERIMENTAL. If egress mode is inline, the Apex will act as a transparent
	// proxy. The certificates that will be served by the proxy are generated by the
	// Apex itself which are issued by a dynamic TLS CA. If you enable this feature,
	// the matching app component instances will get the CA certificate dynamically
	// injected into the system trust store.
	CAInjectionEnabled *bool `json:"CAInjectionEnabled,omitempty" msgpack:"CAInjectionEnabled,omitempty" bson:"cainjectionenabled,omitempty" mapstructure:"CAInjectionEnabled,omitempty"`

	// The description of the component.
	Description *string `json:"description,omitempty" msgpack:"description,omitempty" bson:"description,omitempty" mapstructure:"description,omitempty"`

	// The egress datapath mode to use for network traffic going out to providers for
	// this application component. By default this is set to disabled. However, this
	// can be changed to mirror traffic where the Apex is only providing visibility
	// with no possibility of any access or content policies to take effect. Or this
	// can be set to inline in which case all traffic to providers will be redirected
	// to the Apex which acts as a transparent proxy in this case. In this mode access
	// and content policies will take effect.
	EgressMode *AppComponentEgressModeValue `json:"egressMode,omitempty" msgpack:"egressMode,omitempty" bson:"egressmode,omitempty" mapstructure:"egressMode,omitempty"`

	// The ingress provider configurations to serve for this application. If this app
	// component serves multiple ingress providers, you must define an ingress provider
	// config for every single one of them. If you need access to the same ingress
	// provider over different port configurations (for example one serving https while
	// another port serves plain http), then you must define two ingress provider
	// configurations and reuse the same provider name within the configuration.
	IngressProviderConfigs *IngressProviderConfigsList `json:"ingressProviderConfigs,omitempty" msgpack:"ingressProviderConfigs,omitempty" bson:"ingressproviderconfigs,omitempty" mapstructure:"ingressProviderConfigs,omitempty"`

	// The component name.
	Name *string `json:"name,omitempty" msgpack:"name,omitempty" bson:"name,omitempty" mapstructure:"name,omitempty"`

	// If given, this is the provider name that this component represents. This
	// **MUST** match the name of a provider.
	ProviderName *string `json:"providerName,omitempty" msgpack:"providerName,omitempty" bson:"providername,omitempty" mapstructure:"providerName,omitempty"`

	// A tag expression that identify an application component based on downstream
	// labels.
	Selector *[][]string `json:"selector,omitempty" msgpack:"selector,omitempty" bson:"selector,omitempty" mapstructure:"selector,omitempty"`

	// The token for the current component. Only populated by the backend when the
	// caller's
	// claim match the parents app.subject.
	Token *string `json:"token,omitempty" msgpack:"token,omitempty" bson:"-" mapstructure:"token,omitempty"`

	ModelVersion int `json:"-" msgpack:"-" bson:"_modelversion"`
}

// NewSparseAppComponent returns a new  SparseAppComponent.
func NewSparseAppComponent() *SparseAppComponent {
	return &SparseAppComponent{}
}

// Identity returns the Identity of the sparse object.
func (o *SparseAppComponent) Identity() elemental.Identity {

	return AppComponentIdentity
}

// Identifier returns the value of the sparse object's unique identifier.
func (o *SparseAppComponent) Identifier() string {

	return ""
}

// SetIdentifier sets the value of the sparse object's unique identifier.
func (o *SparseAppComponent) SetIdentifier(id string) {

}

// GetBSON implements the bson marshaling interface.
// This is used to transparently convert ID to MongoDBID as ObectID.
func (o *SparseAppComponent) GetBSON() (any, error) {

	if o == nil {
		return nil, nil
	}

	s := &mongoAttributesSparseAppComponent{}

	if o.CAInjectionEnabled != nil {
		s.CAInjectionEnabled = o.CAInjectionEnabled
	}
	if o.Description != nil {
		s.Description = o.Description
	}
	if o.EgressMode != nil {
		s.EgressMode = o.EgressMode
	}
	if o.IngressProviderConfigs != nil {
		s.IngressProviderConfigs = o.IngressProviderConfigs
	}
	if o.Name != nil {
		s.Name = o.Name
	}
	if o.ProviderName != nil {
		s.ProviderName = o.ProviderName
	}
	if o.Selector != nil {
		s.Selector = o.Selector
	}

	return s, nil
}

// SetBSON implements the bson marshaling interface.
// This is used to transparently convert ID to MongoDBID as ObectID.
func (o *SparseAppComponent) SetBSON(raw bson.Raw) error {

	if o == nil {
		return nil
	}

	s := &mongoAttributesSparseAppComponent{}
	if err := raw.Unmarshal(s); err != nil {
		return err
	}

	if s.CAInjectionEnabled != nil {
		o.CAInjectionEnabled = s.CAInjectionEnabled
	}
	if s.Description != nil {
		o.Description = s.Description
	}
	if s.EgressMode != nil {
		o.EgressMode = s.EgressMode
	}
	if s.IngressProviderConfigs != nil {
		o.IngressProviderConfigs = s.IngressProviderConfigs
	}
	if s.Name != nil {
		o.Name = s.Name
	}
	if s.ProviderName != nil {
		o.ProviderName = s.ProviderName
	}
	if s.Selector != nil {
		o.Selector = s.Selector
	}

	return nil
}

// Version returns the hardcoded version of the model.
func (o *SparseAppComponent) Version() int {

	return 1
}

// ToPlain returns the plain version of the sparse model.
func (o *SparseAppComponent) ToPlain() elemental.PlainIdentifiable {

	out := NewAppComponent()
	if o.CAInjectionEnabled != nil {
		out.CAInjectionEnabled = *o.CAInjectionEnabled
	}
	if o.Description != nil {
		out.Description = *o.Description
	}
	if o.EgressMode != nil {
		out.EgressMode = *o.EgressMode
	}
	if o.IngressProviderConfigs != nil {
		out.IngressProviderConfigs = *o.IngressProviderConfigs
	}
	if o.Name != nil {
		out.Name = *o.Name
	}
	if o.ProviderName != nil {
		out.ProviderName = *o.ProviderName
	}
	if o.Selector != nil {
		out.Selector = *o.Selector
	}
	if o.Token != nil {
		out.Token = *o.Token
	}

	return out
}

// DeepCopy returns a deep copy if the SparseAppComponent.
func (o *SparseAppComponent) DeepCopy() *SparseAppComponent {

	if o == nil {
		return nil
	}

	out := &SparseAppComponent{}
	o.DeepCopyInto(out)

	return out
}

// DeepCopyInto copies the receiver into the given *SparseAppComponent.
func (o *SparseAppComponent) DeepCopyInto(out *SparseAppComponent) {

	target, err := copystructure.Copy(o)
	if err != nil {
		panic(fmt.Sprintf("Unable to deepcopy SparseAppComponent: %s", err))
	}

	*out = *target.(*SparseAppComponent)
}

type mongoAttributesAppComponent struct {
	CAInjectionEnabled     bool                        `bson:"cainjectionenabled"`
	Description            string                      `bson:"description"`
	EgressMode             AppComponentEgressModeValue `bson:"egressmode"`
	IngressProviderConfigs IngressProviderConfigsList  `bson:"ingressproviderconfigs,omitempty"`
	Name                   string                      `bson:"name"`
	ProviderName           string                      `bson:"providername,omitempty"`
	Selector               [][]string                  `bson:"selector,omitempty"`
}
type mongoAttributesSparseAppComponent struct {
	CAInjectionEnabled     *bool                        `bson:"cainjectionenabled,omitempty"`
	Description            *string                      `bson:"description,omitempty"`
	EgressMode             *AppComponentEgressModeValue `bson:"egressmode,omitempty"`
	IngressProviderConfigs *IngressProviderConfigsList  `bson:"ingressproviderconfigs,omitempty"`
	Name                   *string                      `bson:"name,omitempty"`
	ProviderName           *string                      `bson:"providername,omitempty"`
	Selector               *[][]string                  `bson:"selector,omitempty"`
}
