// Code generated by elegen. DO NOT EDIT.
// Source: go.acuvity.ai/elemental (templates/model.gotpl)

package api

import (
	"fmt"

	"github.com/globalsign/mgo/bson"
	"github.com/mitchellh/copystructure"
	"go.acuvity.ai/elemental"
)

// ScanRequestAnonymizationValue represents the possible values for attribute "anonymization".
type ScanRequestAnonymizationValue string

const (
	// ScanRequestAnonymizationFixedSize represents the value FixedSize.
	ScanRequestAnonymizationFixedSize ScanRequestAnonymizationValue = "FixedSize"

	// ScanRequestAnonymizationVariableSize represents the value VariableSize.
	ScanRequestAnonymizationVariableSize ScanRequestAnonymizationValue = "VariableSize"
)

// ScanRequestTypeValue represents the possible values for attribute "type".
type ScanRequestTypeValue string

const (
	// ScanRequestTypeInput represents the value Input.
	ScanRequestTypeInput ScanRequestTypeValue = "Input"

	// ScanRequestTypeOutput represents the value Output.
	ScanRequestTypeOutput ScanRequestTypeValue = "Output"
)

// ScanRequestIdentity represents the Identity of the object.
var ScanRequestIdentity = elemental.Identity{
	Name:     "scanrequest",
	Category: "scanrequests",
	Package:  "proxy",
	Private:  false,
}

// ScanRequestsList represents a list of ScanRequests
type ScanRequestsList []*ScanRequest

// Identity returns the identity of the objects in the list.
func (o ScanRequestsList) Identity() elemental.Identity {

	return ScanRequestIdentity
}

// Copy returns a pointer to a copy the ScanRequestsList.
func (o ScanRequestsList) Copy() elemental.Identifiables {

	out := append(ScanRequestsList{}, o...)
	return &out
}

// Append appends the objects to the a new copy of the ScanRequestsList.
func (o ScanRequestsList) Append(objects ...elemental.Identifiable) elemental.Identifiables {

	out := append(ScanRequestsList{}, o...)
	for _, obj := range objects {
		out = append(out, obj.(*ScanRequest))
	}

	return out
}

// List converts the object to an elemental.IdentifiablesList.
func (o ScanRequestsList) List() elemental.IdentifiablesList {

	out := make(elemental.IdentifiablesList, len(o))
	for i := 0; i < len(o); i++ {
		out[i] = o[i]
	}

	return out
}

// DefaultOrder returns the default ordering fields of the content.
func (o ScanRequestsList) DefaultOrder() []string {

	return []string{}
}

// ToSparse returns the ScanRequestsList converted to SparseScanRequestsList.
// Objects in the list will only contain the given fields. No field means entire field set.
func (o ScanRequestsList) ToSparse(fields ...string) elemental.Identifiables {

	out := make(SparseScanRequestsList, len(o))
	for i := 0; i < len(o); i++ {
		out[i] = o[i].ToSparse(fields...).(*SparseScanRequest)
	}

	return out
}

// Version returns the version of the content.
func (o ScanRequestsList) Version() int {

	return 1
}

// ScanRequest represents the model of a scanrequest
type ScanRequest struct {
	// AccessPolicy allows to pass optional Rego access policy. If not set,
	// The action is always Allow,
	// If it is set, it will be run, and the final decision will be computed based
	// on that policy.
	// If the rego code does not start with package main, then the needed
	// classic package definition and  acuvity imports will be added
	// automatically.
	// If the code starts with package main, then everything remains untouched.
	AccessPolicy string `json:"accessPolicy,omitempty" msgpack:"accessPolicy,omitempty" bson:"-" mapstructure:"accessPolicy,omitempty"`

	// The analyzers parameter allows for customizing which analyzers should be used,
	// overriding the default selection. Each analyzer entry can optionally include a
	// prefix to modify its behavior:
	//
	//   - No prefix: Runs only the specified analyzers and any dependencies required
	// for deeper analyzis (slower but more acurate).
	//   - '+' (enable): Activates an analyzer that is disabled by default.
	//   - '-' (disable): Disables an analyzer that is enabled by default.
	//   - '@' (direct execution): Runs the analyzer immediately, bypassing the deeper
	// analyzis (faster but less acurate).
	//
	// An analyzers entry can be specified using:
	//   - The analyzer name (e.g., 'Toxicity detector')
	//   - The analyzer ID (e.g., 'en-text-toxicity-detector')
	//   - The analyzer group (e.g., 'Detectors')
	//   - A detector name (e.g., 'toxic')
	//   - A detector label (e.g., 'insult')
	//   - A detector group (e.g., 'Malcontents')
	//
	// If left empty, all default analyzers will be executed.
	Analyzers []string `json:"analyzers,omitempty" msgpack:"analyzers,omitempty" bson:"-" mapstructure:"analyzers,omitempty"`

	// Annotations attached to the extraction.
	Annotations map[string]string `json:"annotations,omitempty" msgpack:"annotations,omitempty" bson:"-" mapstructure:"annotations,omitempty"`

	// How to anonymize the data. If deanonymize is true, then VariablSize is required.
	Anonymization ScanRequestAnonymizationValue `json:"anonymization" msgpack:"anonymization" bson:"anonymization" mapstructure:"anonymization,omitempty"`

	// In the case of a contentPolicy that asks for a confirmation, this is the
	// hash you must send back to bypass the block. This is only useful when a
	// content policy has been set or is evaluated remotely.
	BypassHash string `json:"bypassHash,omitempty" msgpack:"bypassHash,omitempty" bson:"bypasshash,omitempty" mapstructure:"bypassHash,omitempty"`

	// ContentPolicy allows to pass optional Rego content policy. If not set,
	// The action is always Allow, and there cannot be any alerts raised etc
	// If it is set, it will be run, and the final decision will be computed based
	// on that policy.
	// If the rego code does not start with package main, then the needed
	// classic package definition and  acuvity imports will be added
	// automatically.
	// If the code starts with package main, then everything remains untouched.
	ContentPolicy string `json:"contentPolicy,omitempty" msgpack:"contentPolicy,omitempty" bson:"-" mapstructure:"contentPolicy,omitempty"`

	// The extractions to request.
	Extractions []*ExtractionRequest `json:"extractions" msgpack:"extractions" bson:"-" mapstructure:"extractions,omitempty"`

	// The keywords found during classification.
	Keywords []string `json:"keywords,omitempty" msgpack:"keywords,omitempty" bson:"-" mapstructure:"keywords,omitempty"`

	// Messages to process and provide detections for. Use data in extractions for
	// processing binary data.
	Messages []string `json:"messages,omitempty" msgpack:"messages,omitempty" bson:"-" mapstructure:"messages,omitempty"`

	// If true, the system will not log the contents that were scanned.
	MinimalLogging bool `json:"minimalLogging,omitempty" msgpack:"minimalLogging,omitempty" bson:"-" mapstructure:"minimalLogging,omitempty"`

	// The redactions to perform if they are detected.
	Redactions []string `json:"redactions,omitempty" msgpack:"redactions,omitempty" bson:"redactions,omitempty" mapstructure:"redactions,omitempty"`

	// The type of text.
	Type ScanRequestTypeValue `json:"type" msgpack:"type" bson:"type" mapstructure:"type,omitempty"`

	ModelVersion int `json:"-" msgpack:"-" bson:"_modelversion"`
}

// NewScanRequest returns a new *ScanRequest
func NewScanRequest() *ScanRequest {

	return &ScanRequest{
		ModelVersion:  1,
		Analyzers:     []string{},
		Annotations:   map[string]string{},
		Anonymization: ScanRequestAnonymizationFixedSize,
	}
}

// Identity returns the Identity of the object.
func (o *ScanRequest) Identity() elemental.Identity {

	return ScanRequestIdentity
}

// Identifier returns the value of the object's unique identifier.
func (o *ScanRequest) Identifier() string {

	return ""
}

// SetIdentifier sets the value of the object's unique identifier.
func (o *ScanRequest) SetIdentifier(id string) {

}

// GetBSON implements the bson marshaling interface.
// This is used to transparently convert ID to MongoDBID as ObectID.
func (o *ScanRequest) GetBSON() (any, error) {

	if o == nil {
		return nil, nil
	}

	s := &mongoAttributesScanRequest{}

	s.Anonymization = o.Anonymization
	s.BypassHash = o.BypassHash
	s.Redactions = o.Redactions
	s.Type = o.Type

	return s, nil
}

// SetBSON implements the bson marshaling interface.
// This is used to transparently convert ID to MongoDBID as ObectID.
func (o *ScanRequest) SetBSON(raw bson.Raw) error {

	if o == nil {
		return nil
	}

	s := &mongoAttributesScanRequest{}
	if err := raw.Unmarshal(s); err != nil {
		return err
	}

	o.Anonymization = s.Anonymization
	o.BypassHash = s.BypassHash
	o.Redactions = s.Redactions
	o.Type = s.Type

	return nil
}

// Version returns the hardcoded version of the model.
func (o *ScanRequest) Version() int {

	return 1
}

// BleveType implements the bleve.Classifier Interface.
func (o *ScanRequest) BleveType() string {

	return "scanrequest"
}

// DefaultOrder returns the list of default ordering fields.
func (o *ScanRequest) DefaultOrder() []string {

	return []string{}
}

// Doc returns the documentation for the object
func (o *ScanRequest) Doc() string {

	return `This is a scan request.`
}

func (o *ScanRequest) String() string {

	return fmt.Sprintf("<%s:%s>", o.Identity().Name, o.Identifier())
}

// ToSparse returns the sparse version of the model.
// The returned object will only contain the given fields. No field means entire field set.
func (o *ScanRequest) ToSparse(fields ...string) elemental.SparseIdentifiable {

	if len(fields) == 0 {
		// nolint: goimports
		return &SparseScanRequest{
			AccessPolicy:   &o.AccessPolicy,
			Analyzers:      &o.Analyzers,
			Annotations:    &o.Annotations,
			Anonymization:  &o.Anonymization,
			BypassHash:     &o.BypassHash,
			ContentPolicy:  &o.ContentPolicy,
			Extractions:    &o.Extractions,
			Keywords:       &o.Keywords,
			Messages:       &o.Messages,
			MinimalLogging: &o.MinimalLogging,
			Redactions:     &o.Redactions,
			Type:           &o.Type,
		}
	}

	sp := &SparseScanRequest{}
	for _, f := range fields {
		switch f {
		case "accessPolicy":
			sp.AccessPolicy = &(o.AccessPolicy)
		case "analyzers":
			sp.Analyzers = &(o.Analyzers)
		case "annotations":
			sp.Annotations = &(o.Annotations)
		case "anonymization":
			sp.Anonymization = &(o.Anonymization)
		case "bypassHash":
			sp.BypassHash = &(o.BypassHash)
		case "contentPolicy":
			sp.ContentPolicy = &(o.ContentPolicy)
		case "extractions":
			sp.Extractions = &(o.Extractions)
		case "keywords":
			sp.Keywords = &(o.Keywords)
		case "messages":
			sp.Messages = &(o.Messages)
		case "minimalLogging":
			sp.MinimalLogging = &(o.MinimalLogging)
		case "redactions":
			sp.Redactions = &(o.Redactions)
		case "type":
			sp.Type = &(o.Type)
		}
	}

	return sp
}

// Patch apply the non nil value of a *SparseScanRequest to the object.
func (o *ScanRequest) Patch(sparse elemental.SparseIdentifiable) {
	if !sparse.Identity().IsEqual(o.Identity()) {
		panic("cannot patch from a parse with different identity")
	}

	so := sparse.(*SparseScanRequest)
	if so.AccessPolicy != nil {
		o.AccessPolicy = *so.AccessPolicy
	}
	if so.Analyzers != nil {
		o.Analyzers = *so.Analyzers
	}
	if so.Annotations != nil {
		o.Annotations = *so.Annotations
	}
	if so.Anonymization != nil {
		o.Anonymization = *so.Anonymization
	}
	if so.BypassHash != nil {
		o.BypassHash = *so.BypassHash
	}
	if so.ContentPolicy != nil {
		o.ContentPolicy = *so.ContentPolicy
	}
	if so.Extractions != nil {
		o.Extractions = *so.Extractions
	}
	if so.Keywords != nil {
		o.Keywords = *so.Keywords
	}
	if so.Messages != nil {
		o.Messages = *so.Messages
	}
	if so.MinimalLogging != nil {
		o.MinimalLogging = *so.MinimalLogging
	}
	if so.Redactions != nil {
		o.Redactions = *so.Redactions
	}
	if so.Type != nil {
		o.Type = *so.Type
	}
}

// DeepCopy returns a deep copy if the ScanRequest.
func (o *ScanRequest) DeepCopy() *ScanRequest {

	if o == nil {
		return nil
	}

	out := &ScanRequest{}
	o.DeepCopyInto(out)

	return out
}

// DeepCopyInto copies the receiver into the given *ScanRequest.
func (o *ScanRequest) DeepCopyInto(out *ScanRequest) {

	target, err := copystructure.Copy(o)
	if err != nil {
		panic(fmt.Sprintf("Unable to deepcopy ScanRequest: %s", err))
	}

	*out = *target.(*ScanRequest)
}

// Validate valides the current information stored into the structure.
func (o *ScanRequest) Validate() error {

	errors := elemental.Errors{}
	requiredErrors := elemental.Errors{}

	if err := ValidateRego("accessPolicy", o.AccessPolicy); err != nil {
		errors = errors.Append(err)
	}

	if err := elemental.ValidateStringInList("anonymization", string(o.Anonymization), []string{"FixedSize", "VariableSize"}, false); err != nil {
		errors = errors.Append(err)
	}

	if err := ValidateRego("contentPolicy", o.ContentPolicy); err != nil {
		errors = errors.Append(err)
	}

	for _, sub := range o.Extractions {
		if sub == nil {
			continue
		}
		elemental.ResetDefaultForZeroValues(sub)
		if err := sub.Validate(); err != nil {
			errors = errors.Append(err)
		}
	}

	if err := elemental.ValidateStringInList("type", string(o.Type), []string{"Input", "Output"}, false); err != nil {
		errors = errors.Append(err)
	}

	if len(requiredErrors) > 0 {
		return requiredErrors
	}

	if len(errors) > 0 {
		return errors
	}

	return nil
}

// SpecificationForAttribute returns the AttributeSpecification for the given attribute name key.
func (*ScanRequest) SpecificationForAttribute(name string) elemental.AttributeSpecification {

	if v, ok := ScanRequestAttributesMap[name]; ok {
		return v
	}

	// We could not find it, so let's check on the lower case indexed spec map
	return ScanRequestLowerCaseAttributesMap[name]
}

// AttributeSpecifications returns the full attribute specifications map.
func (*ScanRequest) AttributeSpecifications() map[string]elemental.AttributeSpecification {

	return ScanRequestAttributesMap
}

// ValueForAttribute returns the value for the given attribute.
// This is a very advanced function that you should not need but in some
// very specific use cases.
func (o *ScanRequest) ValueForAttribute(name string) any {

	switch name {
	case "accessPolicy":
		return o.AccessPolicy
	case "analyzers":
		return o.Analyzers
	case "annotations":
		return o.Annotations
	case "anonymization":
		return o.Anonymization
	case "bypassHash":
		return o.BypassHash
	case "contentPolicy":
		return o.ContentPolicy
	case "extractions":
		return o.Extractions
	case "keywords":
		return o.Keywords
	case "messages":
		return o.Messages
	case "minimalLogging":
		return o.MinimalLogging
	case "redactions":
		return o.Redactions
	case "type":
		return o.Type
	}

	return nil
}

// ScanRequestAttributesMap represents the map of attribute for ScanRequest.
var ScanRequestAttributesMap = map[string]elemental.AttributeSpecification{
	"AccessPolicy": {
		AllowedChoices: []string{},
		ConvertedName:  "AccessPolicy",
		Description: `AccessPolicy allows to pass optional Rego access policy. If not set,
The action is always Allow,
If it is set, it will be run, and the final decision will be computed based
on that policy.
If the rego code does not start with package main, then the needed
classic package definition and  acuvity imports will be added
automatically.
If the code starts with package main, then everything remains untouched.`,
		Exposed: true,
		Name:    "accessPolicy",
		Type:    "string",
	},
	"Analyzers": {
		AllowedChoices: []string{},
		ConvertedName:  "Analyzers",
		Description: `The analyzers parameter allows for customizing which analyzers should be used,
overriding the default selection. Each analyzer entry can optionally include a
prefix to modify its behavior:

  - No prefix: Runs only the specified analyzers and any dependencies required
for deeper analyzis (slower but more acurate).
  - '+' (enable): Activates an analyzer that is disabled by default.
  - '-' (disable): Disables an analyzer that is enabled by default.
  - '@' (direct execution): Runs the analyzer immediately, bypassing the deeper
analyzis (faster but less acurate).

An analyzers entry can be specified using:
  - The analyzer name (e.g., 'Toxicity detector')
  - The analyzer ID (e.g., 'en-text-toxicity-detector')
  - The analyzer group (e.g., 'Detectors')
  - A detector name (e.g., 'toxic')
  - A detector label (e.g., 'insult')
  - A detector group (e.g., 'Malcontents')

If left empty, all default analyzers will be executed.`,
		Exposed: true,
		Name:    "analyzers",
		SubType: "string",
		Type:    "list",
	},
	"Annotations": {
		AllowedChoices: []string{},
		ConvertedName:  "Annotations",
		Description:    `Annotations attached to the extraction.`,
		Exposed:        true,
		Name:           "annotations",
		SubType:        "map[string]string",
		Type:           "external",
	},
	"Anonymization": {
		AllowedChoices: []string{"FixedSize", "VariableSize"},
		BSONFieldName:  "anonymization",
		ConvertedName:  "Anonymization",
		DefaultValue:   ScanRequestAnonymizationFixedSize,
		Description:    `How to anonymize the data. If deanonymize is true, then VariablSize is required.`,
		Exposed:        true,
		Name:           "anonymization",
		Stored:         true,
		Type:           "enum",
	},
	"BypassHash": {
		AllowedChoices: []string{},
		BSONFieldName:  "bypasshash",
		ConvertedName:  "BypassHash",
		Description: `In the case of a contentPolicy that asks for a confirmation, this is the
hash you must send back to bypass the block. This is only useful when a
content policy has been set or is evaluated remotely.`,
		Exposed: true,
		Name:    "bypassHash",
		Stored:  true,
		Type:    "string",
	},
	"ContentPolicy": {
		AllowedChoices: []string{},
		ConvertedName:  "ContentPolicy",
		Description: `ContentPolicy allows to pass optional Rego content policy. If not set,
The action is always Allow, and there cannot be any alerts raised etc
If it is set, it will be run, and the final decision will be computed based
on that policy.
If the rego code does not start with package main, then the needed
classic package definition and  acuvity imports will be added
automatically.
If the code starts with package main, then everything remains untouched.`,
		Exposed: true,
		Name:    "contentPolicy",
		Type:    "string",
	},
	"Extractions": {
		AllowedChoices: []string{},
		ConvertedName:  "Extractions",
		Description:    `The extractions to request.`,
		Exposed:        true,
		Name:           "extractions",
		SubType:        "extractionrequest",
		Type:           "refList",
	},
	"Keywords": {
		AllowedChoices: []string{},
		ConvertedName:  "Keywords",
		Description:    `The keywords found during classification.`,
		Exposed:        true,
		Name:           "keywords",
		SubType:        "string",
		Type:           "list",
	},
	"Messages": {
		AllowedChoices: []string{},
		ConvertedName:  "Messages",
		Description: `Messages to process and provide detections for. Use data in extractions for
processing binary data.`,
		Exposed: true,
		Name:    "messages",
		SubType: "string",
		Type:    "list",
	},
	"MinimalLogging": {
		AllowedChoices: []string{},
		ConvertedName:  "MinimalLogging",
		Description:    `If true, the system will not log the contents that were scanned.`,
		Exposed:        true,
		Name:           "minimalLogging",
		Type:           "boolean",
	},
	"Redactions": {
		AllowedChoices: []string{},
		BSONFieldName:  "redactions",
		ConvertedName:  "Redactions",
		Description:    `The redactions to perform if they are detected.`,
		Exposed:        true,
		Name:           "redactions",
		Stored:         true,
		SubType:        "string",
		Type:           "list",
	},
	"Type": {
		AllowedChoices: []string{"Input", "Output"},
		BSONFieldName:  "type",
		ConvertedName:  "Type",
		Description:    `The type of text.`,
		Exposed:        true,
		Name:           "type",
		Stored:         true,
		Type:           "enum",
	},
}

// ScanRequestLowerCaseAttributesMap represents the map of attribute for ScanRequest.
var ScanRequestLowerCaseAttributesMap = map[string]elemental.AttributeSpecification{
	"accesspolicy": {
		AllowedChoices: []string{},
		ConvertedName:  "AccessPolicy",
		Description: `AccessPolicy allows to pass optional Rego access policy. If not set,
The action is always Allow,
If it is set, it will be run, and the final decision will be computed based
on that policy.
If the rego code does not start with package main, then the needed
classic package definition and  acuvity imports will be added
automatically.
If the code starts with package main, then everything remains untouched.`,
		Exposed: true,
		Name:    "accessPolicy",
		Type:    "string",
	},
	"analyzers": {
		AllowedChoices: []string{},
		ConvertedName:  "Analyzers",
		Description: `The analyzers parameter allows for customizing which analyzers should be used,
overriding the default selection. Each analyzer entry can optionally include a
prefix to modify its behavior:

  - No prefix: Runs only the specified analyzers and any dependencies required
for deeper analyzis (slower but more acurate).
  - '+' (enable): Activates an analyzer that is disabled by default.
  - '-' (disable): Disables an analyzer that is enabled by default.
  - '@' (direct execution): Runs the analyzer immediately, bypassing the deeper
analyzis (faster but less acurate).

An analyzers entry can be specified using:
  - The analyzer name (e.g., 'Toxicity detector')
  - The analyzer ID (e.g., 'en-text-toxicity-detector')
  - The analyzer group (e.g., 'Detectors')
  - A detector name (e.g., 'toxic')
  - A detector label (e.g., 'insult')
  - A detector group (e.g., 'Malcontents')

If left empty, all default analyzers will be executed.`,
		Exposed: true,
		Name:    "analyzers",
		SubType: "string",
		Type:    "list",
	},
	"annotations": {
		AllowedChoices: []string{},
		ConvertedName:  "Annotations",
		Description:    `Annotations attached to the extraction.`,
		Exposed:        true,
		Name:           "annotations",
		SubType:        "map[string]string",
		Type:           "external",
	},
	"anonymization": {
		AllowedChoices: []string{"FixedSize", "VariableSize"},
		BSONFieldName:  "anonymization",
		ConvertedName:  "Anonymization",
		DefaultValue:   ScanRequestAnonymizationFixedSize,
		Description:    `How to anonymize the data. If deanonymize is true, then VariablSize is required.`,
		Exposed:        true,
		Name:           "anonymization",
		Stored:         true,
		Type:           "enum",
	},
	"bypasshash": {
		AllowedChoices: []string{},
		BSONFieldName:  "bypasshash",
		ConvertedName:  "BypassHash",
		Description: `In the case of a contentPolicy that asks for a confirmation, this is the
hash you must send back to bypass the block. This is only useful when a
content policy has been set or is evaluated remotely.`,
		Exposed: true,
		Name:    "bypassHash",
		Stored:  true,
		Type:    "string",
	},
	"contentpolicy": {
		AllowedChoices: []string{},
		ConvertedName:  "ContentPolicy",
		Description: `ContentPolicy allows to pass optional Rego content policy. If not set,
The action is always Allow, and there cannot be any alerts raised etc
If it is set, it will be run, and the final decision will be computed based
on that policy.
If the rego code does not start with package main, then the needed
classic package definition and  acuvity imports will be added
automatically.
If the code starts with package main, then everything remains untouched.`,
		Exposed: true,
		Name:    "contentPolicy",
		Type:    "string",
	},
	"extractions": {
		AllowedChoices: []string{},
		ConvertedName:  "Extractions",
		Description:    `The extractions to request.`,
		Exposed:        true,
		Name:           "extractions",
		SubType:        "extractionrequest",
		Type:           "refList",
	},
	"keywords": {
		AllowedChoices: []string{},
		ConvertedName:  "Keywords",
		Description:    `The keywords found during classification.`,
		Exposed:        true,
		Name:           "keywords",
		SubType:        "string",
		Type:           "list",
	},
	"messages": {
		AllowedChoices: []string{},
		ConvertedName:  "Messages",
		Description: `Messages to process and provide detections for. Use data in extractions for
processing binary data.`,
		Exposed: true,
		Name:    "messages",
		SubType: "string",
		Type:    "list",
	},
	"minimallogging": {
		AllowedChoices: []string{},
		ConvertedName:  "MinimalLogging",
		Description:    `If true, the system will not log the contents that were scanned.`,
		Exposed:        true,
		Name:           "minimalLogging",
		Type:           "boolean",
	},
	"redactions": {
		AllowedChoices: []string{},
		BSONFieldName:  "redactions",
		ConvertedName:  "Redactions",
		Description:    `The redactions to perform if they are detected.`,
		Exposed:        true,
		Name:           "redactions",
		Stored:         true,
		SubType:        "string",
		Type:           "list",
	},
	"type": {
		AllowedChoices: []string{"Input", "Output"},
		BSONFieldName:  "type",
		ConvertedName:  "Type",
		Description:    `The type of text.`,
		Exposed:        true,
		Name:           "type",
		Stored:         true,
		Type:           "enum",
	},
}

// SparseScanRequestsList represents a list of SparseScanRequests
type SparseScanRequestsList []*SparseScanRequest

// Identity returns the identity of the objects in the list.
func (o SparseScanRequestsList) Identity() elemental.Identity {

	return ScanRequestIdentity
}

// Copy returns a pointer to a copy the SparseScanRequestsList.
func (o SparseScanRequestsList) Copy() elemental.Identifiables {

	copy := append(SparseScanRequestsList{}, o...)
	return &copy
}

// Append appends the objects to the a new copy of the SparseScanRequestsList.
func (o SparseScanRequestsList) Append(objects ...elemental.Identifiable) elemental.Identifiables {

	out := append(SparseScanRequestsList{}, o...)
	for _, obj := range objects {
		out = append(out, obj.(*SparseScanRequest))
	}

	return out
}

// List converts the object to an elemental.IdentifiablesList.
func (o SparseScanRequestsList) List() elemental.IdentifiablesList {

	out := make(elemental.IdentifiablesList, len(o))
	for i := 0; i < len(o); i++ {
		out[i] = o[i]
	}

	return out
}

// DefaultOrder returns the default ordering fields of the content.
func (o SparseScanRequestsList) DefaultOrder() []string {

	return []string{}
}

// ToPlain returns the SparseScanRequestsList converted to ScanRequestsList.
func (o SparseScanRequestsList) ToPlain() elemental.IdentifiablesList {

	out := make(elemental.IdentifiablesList, len(o))
	for i := 0; i < len(o); i++ {
		out[i] = o[i].ToPlain()
	}

	return out
}

// Version returns the version of the content.
func (o SparseScanRequestsList) Version() int {

	return 1
}

// SparseScanRequest represents the sparse version of a scanrequest.
type SparseScanRequest struct {
	// AccessPolicy allows to pass optional Rego access policy. If not set,
	// The action is always Allow,
	// If it is set, it will be run, and the final decision will be computed based
	// on that policy.
	// If the rego code does not start with package main, then the needed
	// classic package definition and  acuvity imports will be added
	// automatically.
	// If the code starts with package main, then everything remains untouched.
	AccessPolicy *string `json:"accessPolicy,omitempty" msgpack:"accessPolicy,omitempty" bson:"-" mapstructure:"accessPolicy,omitempty"`

	// The analyzers parameter allows for customizing which analyzers should be used,
	// overriding the default selection. Each analyzer entry can optionally include a
	// prefix to modify its behavior:
	//
	//   - No prefix: Runs only the specified analyzers and any dependencies required
	// for deeper analyzis (slower but more acurate).
	//   - '+' (enable): Activates an analyzer that is disabled by default.
	//   - '-' (disable): Disables an analyzer that is enabled by default.
	//   - '@' (direct execution): Runs the analyzer immediately, bypassing the deeper
	// analyzis (faster but less acurate).
	//
	// An analyzers entry can be specified using:
	//   - The analyzer name (e.g., 'Toxicity detector')
	//   - The analyzer ID (e.g., 'en-text-toxicity-detector')
	//   - The analyzer group (e.g., 'Detectors')
	//   - A detector name (e.g., 'toxic')
	//   - A detector label (e.g., 'insult')
	//   - A detector group (e.g., 'Malcontents')
	//
	// If left empty, all default analyzers will be executed.
	Analyzers *[]string `json:"analyzers,omitempty" msgpack:"analyzers,omitempty" bson:"-" mapstructure:"analyzers,omitempty"`

	// Annotations attached to the extraction.
	Annotations *map[string]string `json:"annotations,omitempty" msgpack:"annotations,omitempty" bson:"-" mapstructure:"annotations,omitempty"`

	// How to anonymize the data. If deanonymize is true, then VariablSize is required.
	Anonymization *ScanRequestAnonymizationValue `json:"anonymization,omitempty" msgpack:"anonymization,omitempty" bson:"anonymization,omitempty" mapstructure:"anonymization,omitempty"`

	// In the case of a contentPolicy that asks for a confirmation, this is the
	// hash you must send back to bypass the block. This is only useful when a
	// content policy has been set or is evaluated remotely.
	BypassHash *string `json:"bypassHash,omitempty" msgpack:"bypassHash,omitempty" bson:"bypasshash,omitempty" mapstructure:"bypassHash,omitempty"`

	// ContentPolicy allows to pass optional Rego content policy. If not set,
	// The action is always Allow, and there cannot be any alerts raised etc
	// If it is set, it will be run, and the final decision will be computed based
	// on that policy.
	// If the rego code does not start with package main, then the needed
	// classic package definition and  acuvity imports will be added
	// automatically.
	// If the code starts with package main, then everything remains untouched.
	ContentPolicy *string `json:"contentPolicy,omitempty" msgpack:"contentPolicy,omitempty" bson:"-" mapstructure:"contentPolicy,omitempty"`

	// The extractions to request.
	Extractions *[]*ExtractionRequest `json:"extractions,omitempty" msgpack:"extractions,omitempty" bson:"-" mapstructure:"extractions,omitempty"`

	// The keywords found during classification.
	Keywords *[]string `json:"keywords,omitempty" msgpack:"keywords,omitempty" bson:"-" mapstructure:"keywords,omitempty"`

	// Messages to process and provide detections for. Use data in extractions for
	// processing binary data.
	Messages *[]string `json:"messages,omitempty" msgpack:"messages,omitempty" bson:"-" mapstructure:"messages,omitempty"`

	// If true, the system will not log the contents that were scanned.
	MinimalLogging *bool `json:"minimalLogging,omitempty" msgpack:"minimalLogging,omitempty" bson:"-" mapstructure:"minimalLogging,omitempty"`

	// The redactions to perform if they are detected.
	Redactions *[]string `json:"redactions,omitempty" msgpack:"redactions,omitempty" bson:"redactions,omitempty" mapstructure:"redactions,omitempty"`

	// The type of text.
	Type *ScanRequestTypeValue `json:"type,omitempty" msgpack:"type,omitempty" bson:"type,omitempty" mapstructure:"type,omitempty"`

	ModelVersion int `json:"-" msgpack:"-" bson:"_modelversion"`
}

// NewSparseScanRequest returns a new  SparseScanRequest.
func NewSparseScanRequest() *SparseScanRequest {
	return &SparseScanRequest{}
}

// Identity returns the Identity of the sparse object.
func (o *SparseScanRequest) Identity() elemental.Identity {

	return ScanRequestIdentity
}

// Identifier returns the value of the sparse object's unique identifier.
func (o *SparseScanRequest) Identifier() string {

	return ""
}

// SetIdentifier sets the value of the sparse object's unique identifier.
func (o *SparseScanRequest) SetIdentifier(id string) {

}

// GetBSON implements the bson marshaling interface.
// This is used to transparently convert ID to MongoDBID as ObectID.
func (o *SparseScanRequest) GetBSON() (any, error) {

	if o == nil {
		return nil, nil
	}

	s := &mongoAttributesSparseScanRequest{}

	if o.Anonymization != nil {
		s.Anonymization = o.Anonymization
	}
	if o.BypassHash != nil {
		s.BypassHash = o.BypassHash
	}
	if o.Redactions != nil {
		s.Redactions = o.Redactions
	}
	if o.Type != nil {
		s.Type = o.Type
	}

	return s, nil
}

// SetBSON implements the bson marshaling interface.
// This is used to transparently convert ID to MongoDBID as ObectID.
func (o *SparseScanRequest) SetBSON(raw bson.Raw) error {

	if o == nil {
		return nil
	}

	s := &mongoAttributesSparseScanRequest{}
	if err := raw.Unmarshal(s); err != nil {
		return err
	}

	if s.Anonymization != nil {
		o.Anonymization = s.Anonymization
	}
	if s.BypassHash != nil {
		o.BypassHash = s.BypassHash
	}
	if s.Redactions != nil {
		o.Redactions = s.Redactions
	}
	if s.Type != nil {
		o.Type = s.Type
	}

	return nil
}

// Version returns the hardcoded version of the model.
func (o *SparseScanRequest) Version() int {

	return 1
}

// ToPlain returns the plain version of the sparse model.
func (o *SparseScanRequest) ToPlain() elemental.PlainIdentifiable {

	out := NewScanRequest()
	if o.AccessPolicy != nil {
		out.AccessPolicy = *o.AccessPolicy
	}
	if o.Analyzers != nil {
		out.Analyzers = *o.Analyzers
	}
	if o.Annotations != nil {
		out.Annotations = *o.Annotations
	}
	if o.Anonymization != nil {
		out.Anonymization = *o.Anonymization
	}
	if o.BypassHash != nil {
		out.BypassHash = *o.BypassHash
	}
	if o.ContentPolicy != nil {
		out.ContentPolicy = *o.ContentPolicy
	}
	if o.Extractions != nil {
		out.Extractions = *o.Extractions
	}
	if o.Keywords != nil {
		out.Keywords = *o.Keywords
	}
	if o.Messages != nil {
		out.Messages = *o.Messages
	}
	if o.MinimalLogging != nil {
		out.MinimalLogging = *o.MinimalLogging
	}
	if o.Redactions != nil {
		out.Redactions = *o.Redactions
	}
	if o.Type != nil {
		out.Type = *o.Type
	}

	return out
}

// DeepCopy returns a deep copy if the SparseScanRequest.
func (o *SparseScanRequest) DeepCopy() *SparseScanRequest {

	if o == nil {
		return nil
	}

	out := &SparseScanRequest{}
	o.DeepCopyInto(out)

	return out
}

// DeepCopyInto copies the receiver into the given *SparseScanRequest.
func (o *SparseScanRequest) DeepCopyInto(out *SparseScanRequest) {

	target, err := copystructure.Copy(o)
	if err != nil {
		panic(fmt.Sprintf("Unable to deepcopy SparseScanRequest: %s", err))
	}

	*out = *target.(*SparseScanRequest)
}

type mongoAttributesScanRequest struct {
	Anonymization ScanRequestAnonymizationValue `bson:"anonymization"`
	BypassHash    string                        `bson:"bypasshash,omitempty"`
	Redactions    []string                      `bson:"redactions,omitempty"`
	Type          ScanRequestTypeValue          `bson:"type"`
}
type mongoAttributesSparseScanRequest struct {
	Anonymization *ScanRequestAnonymizationValue `bson:"anonymization,omitempty"`
	BypassHash    *string                        `bson:"bypasshash,omitempty"`
	Redactions    *[]string                      `bson:"redactions,omitempty"`
	Type          *ScanRequestTypeValue          `bson:"type,omitempty"`
}
