// Code generated by elegen. DO NOT EDIT.
// Source: go.acuvity.ai/elemental (templates/model.gotpl)

package api

import (
	"fmt"
	"slices"
	"time"

	"github.com/globalsign/mgo/bson"
	"github.com/mitchellh/copystructure"
	"go.acuvity.ai/elemental"
)

// TraceRefKindValue represents the possible values for attribute "kind".
type TraceRefKindValue string

const (
	// TraceRefKindClient represents the value Client.
	TraceRefKindClient TraceRefKindValue = "Client"

	// TraceRefKindConsumer represents the value Consumer.
	TraceRefKindConsumer TraceRefKindValue = "Consumer"

	// TraceRefKindInternal represents the value Internal.
	TraceRefKindInternal TraceRefKindValue = "Internal"

	// TraceRefKindProducer represents the value Producer.
	TraceRefKindProducer TraceRefKindValue = "Producer"

	// TraceRefKindServer represents the value Server.
	TraceRefKindServer TraceRefKindValue = "Server"

	// TraceRefKindUnspecified represents the value Unspecified.
	TraceRefKindUnspecified TraceRefKindValue = "Unspecified"
)

// TraceRefStatusCodeValue represents the possible values for attribute "statusCode".
type TraceRefStatusCodeValue string

const (
	// TraceRefStatusCodeError represents the value Error.
	TraceRefStatusCodeError TraceRefStatusCodeValue = "Error"

	// TraceRefStatusCodeOK represents the value OK.
	TraceRefStatusCodeOK TraceRefStatusCodeValue = "OK"

	// TraceRefStatusCodeUnset represents the value Unset.
	TraceRefStatusCodeUnset TraceRefStatusCodeValue = "Unset"
)

// TraceRefIdentity represents the Identity of the object.
var TraceRefIdentity = elemental.Identity{
	Name:     "traceref",
	Category: "tracerefs",
	Package:  "colektor",
	Private:  false,
}

// TraceRefsList represents a list of TraceRefs
type TraceRefsList []*TraceRef

// Identity returns the identity of the objects in the list.
func (o TraceRefsList) Identity() elemental.Identity {

	return TraceRefIdentity
}

// Copy returns a pointer to a copy the TraceRefsList.
func (o TraceRefsList) Copy() elemental.Identifiables {

	out := slices.Clone(o)
	return &out
}

// Append appends the objects to the a new copy of the TraceRefsList.
func (o TraceRefsList) Append(objects ...elemental.Identifiable) elemental.Identifiables {

	out := slices.Clone(o)
	for _, obj := range objects {
		out = append(out, obj.(*TraceRef))
	}

	return out
}

// List converts the object to an elemental.IdentifiablesList.
func (o TraceRefsList) List() elemental.IdentifiablesList {

	out := make(elemental.IdentifiablesList, len(o))
	for i := range len(o) {
		out[i] = o[i]
	}

	return out
}

// DefaultOrder returns the default ordering fields of the content.
func (o TraceRefsList) DefaultOrder() []string {

	return []string{}
}

// ToSparse returns the TraceRefsList converted to SparseTraceRefsList.
// Objects in the list will only contain the given fields. No field means entire field set.
func (o TraceRefsList) ToSparse(fields ...string) elemental.Identifiables {

	out := make(SparseTraceRefsList, len(o))
	for i := range len(o) {
		out[i] = o[i].ToSparse(fields...).(*SparseTraceRef)
	}

	return out
}

// Version returns the version of the content.
func (o TraceRefsList) Version() int {

	return 1
}

// TraceRef represents the model of a traceref
type TraceRef struct {
	// The kind of the span.
	Kind TraceRefKindValue `json:"kind" msgpack:"kind" bson:"kind" mapstructure:"kind,omitempty"`

	// The parent span ID that is being referenced as hex encoded string.
	ParentSpanID string `json:"parentSpanID,omitempty" msgpack:"parentSpanID,omitempty" bson:"parentspanid,omitempty" mapstructure:"parentSpanID,omitempty"`

	// When the span ended.
	SpanEnd time.Time `json:"spanEnd" msgpack:"spanEnd" bson:"spanend" mapstructure:"spanEnd,omitempty"`

	// The span ID that is being referenced.
	SpanID string `json:"spanID" msgpack:"spanID" bson:"spanid" mapstructure:"spanID,omitempty"`

	// The name of the span that is being collected.
	SpanName string `json:"spanName" msgpack:"spanName" bson:"spanname" mapstructure:"spanName,omitempty"`

	// When the span started.
	SpanStart time.Time `json:"spanStart" msgpack:"spanStart" bson:"spanstart" mapstructure:"spanStart,omitempty"`

	// Status Code of a span.
	StatusCode TraceRefStatusCodeValue `json:"statusCode" msgpack:"statusCode" bson:"statuscode" mapstructure:"statusCode,omitempty"`

	// A developer-facing human readable error message.
	StatusMessage string `json:"statusMessage" msgpack:"statusMessage" bson:"statusmessage" mapstructure:"statusMessage,omitempty"`

	// The Trace ID that is being referenced as hex encoded string.
	TraceID string `json:"traceID" msgpack:"traceID" bson:"traceid" mapstructure:"traceID,omitempty"`

	// The transparent span ID that is being referenced. If the application operates in
	// transparent tracing mode, then this field must be set to the span ID that this
	// span is originally referencing.
	TransparentSpanID string `json:"transparentSpanID" msgpack:"transparentSpanID" bson:"transparentspanid" mapstructure:"transparentSpanID,omitempty"`

	ModelVersion int `json:"-" msgpack:"-" bson:"_modelversion"`
}

// NewTraceRef returns a new *TraceRef
func NewTraceRef() *TraceRef {

	return &TraceRef{
		ModelVersion: 1,
		Kind:         TraceRefKindUnspecified,
		StatusCode:   TraceRefStatusCodeUnset,
	}
}

// Identity returns the Identity of the object.
func (o *TraceRef) Identity() elemental.Identity {

	return TraceRefIdentity
}

// Identifier returns the value of the object's unique identifier.
func (o *TraceRef) Identifier() string {

	return ""
}

// SetIdentifier sets the value of the object's unique identifier.
func (o *TraceRef) SetIdentifier(id string) {

}

// GetBSON implements the bson marshaling interface.
// This is used to transparently convert ID to MongoDBID as ObectID.
func (o *TraceRef) GetBSON() (any, error) {

	if o == nil {
		return nil, nil
	}

	s := &mongoAttributesTraceRef{}

	s.Kind = o.Kind
	s.ParentSpanID = o.ParentSpanID
	s.SpanEnd = o.SpanEnd
	s.SpanID = o.SpanID
	s.SpanName = o.SpanName
	s.SpanStart = o.SpanStart
	s.StatusCode = o.StatusCode
	s.StatusMessage = o.StatusMessage
	s.TraceID = o.TraceID
	s.TransparentSpanID = o.TransparentSpanID

	return s, nil
}

// SetBSON implements the bson marshaling interface.
// This is used to transparently convert ID to MongoDBID as ObectID.
func (o *TraceRef) SetBSON(raw bson.Raw) error {

	if o == nil || raw.Kind == bson.ElementNil {
		return bson.ErrSetZero
	}

	s := &mongoAttributesTraceRef{}
	if err := raw.Unmarshal(s); err != nil {
		return err
	}

	o.Kind = s.Kind
	o.ParentSpanID = s.ParentSpanID
	o.SpanEnd = s.SpanEnd
	o.SpanID = s.SpanID
	o.SpanName = s.SpanName
	o.SpanStart = s.SpanStart
	o.StatusCode = s.StatusCode
	o.StatusMessage = s.StatusMessage
	o.TraceID = s.TraceID
	o.TransparentSpanID = s.TransparentSpanID

	return nil
}

// Version returns the hardcoded version of the model.
func (o *TraceRef) Version() int {

	return 1
}

// BleveType implements the bleve.Classifier Interface.
func (o *TraceRef) BleveType() string {

	return "traceref"
}

// DefaultOrder returns the list of default ordering fields.
func (o *TraceRef) DefaultOrder() []string {

	return []string{}
}

// Doc returns the documentation for the object
func (o *TraceRef) Doc() string {

	return `Holds all references to a trace which are also the essentials of the span data.`
}

func (o *TraceRef) String() string {

	return fmt.Sprintf("<%s:%s>", o.Identity().Name, o.Identifier())
}

// ToSparse returns the sparse version of the model.
// The returned object will only contain the given fields. No field means entire field set.
func (o *TraceRef) ToSparse(fields ...string) elemental.SparseIdentifiable {

	if len(fields) == 0 {
		// nolint: goimports
		return &SparseTraceRef{
			Kind:              &o.Kind,
			ParentSpanID:      &o.ParentSpanID,
			SpanEnd:           &o.SpanEnd,
			SpanID:            &o.SpanID,
			SpanName:          &o.SpanName,
			SpanStart:         &o.SpanStart,
			StatusCode:        &o.StatusCode,
			StatusMessage:     &o.StatusMessage,
			TraceID:           &o.TraceID,
			TransparentSpanID: &o.TransparentSpanID,
		}
	}

	sp := &SparseTraceRef{}
	for _, f := range fields {
		switch f {
		case "kind":
			sp.Kind = &(o.Kind)
		case "parentSpanID":
			sp.ParentSpanID = &(o.ParentSpanID)
		case "spanEnd":
			sp.SpanEnd = &(o.SpanEnd)
		case "spanID":
			sp.SpanID = &(o.SpanID)
		case "spanName":
			sp.SpanName = &(o.SpanName)
		case "spanStart":
			sp.SpanStart = &(o.SpanStart)
		case "statusCode":
			sp.StatusCode = &(o.StatusCode)
		case "statusMessage":
			sp.StatusMessage = &(o.StatusMessage)
		case "traceID":
			sp.TraceID = &(o.TraceID)
		case "transparentSpanID":
			sp.TransparentSpanID = &(o.TransparentSpanID)
		}
	}

	return sp
}

// Patch apply the non nil value of a *SparseTraceRef to the object.
func (o *TraceRef) Patch(sparse elemental.SparseIdentifiable) {
	if !sparse.Identity().IsEqual(o.Identity()) {
		panic("cannot patch from a parse with different identity")
	}

	so := sparse.(*SparseTraceRef)
	if so.Kind != nil {
		o.Kind = *so.Kind
	}
	if so.ParentSpanID != nil {
		o.ParentSpanID = *so.ParentSpanID
	}
	if so.SpanEnd != nil {
		o.SpanEnd = *so.SpanEnd
	}
	if so.SpanID != nil {
		o.SpanID = *so.SpanID
	}
	if so.SpanName != nil {
		o.SpanName = *so.SpanName
	}
	if so.SpanStart != nil {
		o.SpanStart = *so.SpanStart
	}
	if so.StatusCode != nil {
		o.StatusCode = *so.StatusCode
	}
	if so.StatusMessage != nil {
		o.StatusMessage = *so.StatusMessage
	}
	if so.TraceID != nil {
		o.TraceID = *so.TraceID
	}
	if so.TransparentSpanID != nil {
		o.TransparentSpanID = *so.TransparentSpanID
	}
}

// DeepCopy returns a deep copy if the TraceRef.
func (o *TraceRef) DeepCopy() *TraceRef {

	if o == nil {
		return nil
	}

	out := &TraceRef{}
	o.DeepCopyInto(out)

	return out
}

// DeepCopyInto copies the receiver into the given *TraceRef.
func (o *TraceRef) DeepCopyInto(out *TraceRef) {

	target, err := copystructure.Copy(o)
	if err != nil {
		panic(fmt.Sprintf("Unable to deepcopy TraceRef: %s", err))
	}

	*out = *target.(*TraceRef)
}

// Validate valides the current information stored into the structure.
func (o *TraceRef) Validate() error {

	errors := elemental.Errors{}
	requiredErrors := elemental.Errors{}

	if err := elemental.ValidateStringInList("kind", string(o.Kind), []string{"Unspecified", "Internal", "Server", "Client", "Producer", "Consumer"}, false); err != nil {
		errors = errors.Append(err)
	}

	if err := ValidateSpanID("parentSpanID", o.ParentSpanID); err != nil {
		errors = errors.Append(err)
	}

	if err := elemental.ValidateRequiredTime("spanEnd", o.SpanEnd); err != nil {
		requiredErrors = requiredErrors.Append(err)
	}

	if err := elemental.ValidateRequiredString("spanID", o.SpanID); err != nil {
		requiredErrors = requiredErrors.Append(err)
	}

	if err := ValidateSpanID("spanID", o.SpanID); err != nil {
		errors = errors.Append(err)
	}

	if err := elemental.ValidateRequiredString("spanName", o.SpanName); err != nil {
		requiredErrors = requiredErrors.Append(err)
	}

	if err := elemental.ValidateRequiredTime("spanStart", o.SpanStart); err != nil {
		requiredErrors = requiredErrors.Append(err)
	}

	if err := elemental.ValidateStringInList("statusCode", string(o.StatusCode), []string{"Unset", "OK", "Error"}, false); err != nil {
		errors = errors.Append(err)
	}

	if err := elemental.ValidateRequiredString("traceID", o.TraceID); err != nil {
		requiredErrors = requiredErrors.Append(err)
	}

	if err := ValidateTraceID("traceID", o.TraceID); err != nil {
		errors = errors.Append(err)
	}

	if err := ValidateSpanID("transparentSpanID", o.TransparentSpanID); err != nil {
		errors = errors.Append(err)
	}

	if len(requiredErrors) > 0 {
		return requiredErrors
	}

	if len(errors) > 0 {
		return errors
	}

	return nil
}

// SpecificationForAttribute returns the AttributeSpecification for the given attribute name key.
func (*TraceRef) SpecificationForAttribute(name string) elemental.AttributeSpecification {

	if v, ok := TraceRefAttributesMap[name]; ok {
		return v
	}

	// We could not find it, so let's check on the lower case indexed spec map
	return TraceRefLowerCaseAttributesMap[name]
}

// AttributeSpecifications returns the full attribute specifications map.
func (*TraceRef) AttributeSpecifications() map[string]elemental.AttributeSpecification {

	return TraceRefAttributesMap
}

// ValueForAttribute returns the value for the given attribute.
// This is a very advanced function that you should not need but in some
// very specific use cases.
func (o *TraceRef) ValueForAttribute(name string) any {

	switch name {
	case "kind":
		return o.Kind
	case "parentSpanID":
		return o.ParentSpanID
	case "spanEnd":
		return o.SpanEnd
	case "spanID":
		return o.SpanID
	case "spanName":
		return o.SpanName
	case "spanStart":
		return o.SpanStart
	case "statusCode":
		return o.StatusCode
	case "statusMessage":
		return o.StatusMessage
	case "traceID":
		return o.TraceID
	case "transparentSpanID":
		return o.TransparentSpanID
	}

	return nil
}

// TraceRefAttributesMap represents the map of attribute for TraceRef.
var TraceRefAttributesMap = map[string]elemental.AttributeSpecification{
	"Kind": {
		AllowedChoices: []string{"Unspecified", "Internal", "Server", "Client", "Producer", "Consumer"},
		BSONFieldName:  "kind",
		ConvertedName:  "Kind",
		DefaultValue:   TraceRefKindUnspecified,
		Description:    `The kind of the span.`,
		Exposed:        true,
		Name:           "kind",
		Stored:         true,
		Type:           "enum",
	},
	"ParentSpanID": {
		AllowedChoices: []string{},
		BSONFieldName:  "parentspanid",
		ConvertedName:  "ParentSpanID",
		Description:    `The parent span ID that is being referenced as hex encoded string.`,
		Exposed:        true,
		Name:           "parentSpanID",
		Stored:         true,
		Type:           "string",
	},
	"SpanEnd": {
		AllowedChoices: []string{},
		BSONFieldName:  "spanend",
		ConvertedName:  "SpanEnd",
		Description:    `When the span ended.`,
		Exposed:        true,
		Name:           "spanEnd",
		Required:       true,
		Stored:         true,
		Type:           "time",
	},
	"SpanID": {
		AllowedChoices: []string{},
		BSONFieldName:  "spanid",
		ConvertedName:  "SpanID",
		Description:    `The span ID that is being referenced.`,
		Exposed:        true,
		Name:           "spanID",
		Required:       true,
		Stored:         true,
		Type:           "string",
	},
	"SpanName": {
		AllowedChoices: []string{},
		BSONFieldName:  "spanname",
		ConvertedName:  "SpanName",
		Description:    `The name of the span that is being collected.`,
		Exposed:        true,
		Name:           "spanName",
		Required:       true,
		Stored:         true,
		Type:           "string",
	},
	"SpanStart": {
		AllowedChoices: []string{},
		BSONFieldName:  "spanstart",
		ConvertedName:  "SpanStart",
		Description:    `When the span started.`,
		Exposed:        true,
		Name:           "spanStart",
		Required:       true,
		Stored:         true,
		Type:           "time",
	},
	"StatusCode": {
		AllowedChoices: []string{"Unset", "OK", "Error"},
		BSONFieldName:  "statuscode",
		ConvertedName:  "StatusCode",
		DefaultValue:   TraceRefStatusCodeUnset,
		Description:    `Status Code of a span.`,
		Exposed:        true,
		Name:           "statusCode",
		Stored:         true,
		Type:           "enum",
	},
	"StatusMessage": {
		AllowedChoices: []string{},
		BSONFieldName:  "statusmessage",
		ConvertedName:  "StatusMessage",
		Description:    `A developer-facing human readable error message.`,
		Exposed:        true,
		Name:           "statusMessage",
		Stored:         true,
		Type:           "string",
	},
	"TraceID": {
		AllowedChoices: []string{},
		BSONFieldName:  "traceid",
		ConvertedName:  "TraceID",
		Description:    `The Trace ID that is being referenced as hex encoded string.`,
		Exposed:        true,
		Name:           "traceID",
		Required:       true,
		Stored:         true,
		Type:           "string",
	},
	"TransparentSpanID": {
		AllowedChoices: []string{},
		BSONFieldName:  "transparentspanid",
		ConvertedName:  "TransparentSpanID",
		Description: `The transparent span ID that is being referenced. If the application operates in
transparent tracing mode, then this field must be set to the span ID that this
span is originally referencing.`,
		Exposed: true,
		Name:    "transparentSpanID",
		Stored:  true,
		Type:    "string",
	},
}

// TraceRefLowerCaseAttributesMap represents the map of attribute for TraceRef.
var TraceRefLowerCaseAttributesMap = map[string]elemental.AttributeSpecification{
	"kind": {
		AllowedChoices: []string{"Unspecified", "Internal", "Server", "Client", "Producer", "Consumer"},
		BSONFieldName:  "kind",
		ConvertedName:  "Kind",
		DefaultValue:   TraceRefKindUnspecified,
		Description:    `The kind of the span.`,
		Exposed:        true,
		Name:           "kind",
		Stored:         true,
		Type:           "enum",
	},
	"parentspanid": {
		AllowedChoices: []string{},
		BSONFieldName:  "parentspanid",
		ConvertedName:  "ParentSpanID",
		Description:    `The parent span ID that is being referenced as hex encoded string.`,
		Exposed:        true,
		Name:           "parentSpanID",
		Stored:         true,
		Type:           "string",
	},
	"spanend": {
		AllowedChoices: []string{},
		BSONFieldName:  "spanend",
		ConvertedName:  "SpanEnd",
		Description:    `When the span ended.`,
		Exposed:        true,
		Name:           "spanEnd",
		Required:       true,
		Stored:         true,
		Type:           "time",
	},
	"spanid": {
		AllowedChoices: []string{},
		BSONFieldName:  "spanid",
		ConvertedName:  "SpanID",
		Description:    `The span ID that is being referenced.`,
		Exposed:        true,
		Name:           "spanID",
		Required:       true,
		Stored:         true,
		Type:           "string",
	},
	"spanname": {
		AllowedChoices: []string{},
		BSONFieldName:  "spanname",
		ConvertedName:  "SpanName",
		Description:    `The name of the span that is being collected.`,
		Exposed:        true,
		Name:           "spanName",
		Required:       true,
		Stored:         true,
		Type:           "string",
	},
	"spanstart": {
		AllowedChoices: []string{},
		BSONFieldName:  "spanstart",
		ConvertedName:  "SpanStart",
		Description:    `When the span started.`,
		Exposed:        true,
		Name:           "spanStart",
		Required:       true,
		Stored:         true,
		Type:           "time",
	},
	"statuscode": {
		AllowedChoices: []string{"Unset", "OK", "Error"},
		BSONFieldName:  "statuscode",
		ConvertedName:  "StatusCode",
		DefaultValue:   TraceRefStatusCodeUnset,
		Description:    `Status Code of a span.`,
		Exposed:        true,
		Name:           "statusCode",
		Stored:         true,
		Type:           "enum",
	},
	"statusmessage": {
		AllowedChoices: []string{},
		BSONFieldName:  "statusmessage",
		ConvertedName:  "StatusMessage",
		Description:    `A developer-facing human readable error message.`,
		Exposed:        true,
		Name:           "statusMessage",
		Stored:         true,
		Type:           "string",
	},
	"traceid": {
		AllowedChoices: []string{},
		BSONFieldName:  "traceid",
		ConvertedName:  "TraceID",
		Description:    `The Trace ID that is being referenced as hex encoded string.`,
		Exposed:        true,
		Name:           "traceID",
		Required:       true,
		Stored:         true,
		Type:           "string",
	},
	"transparentspanid": {
		AllowedChoices: []string{},
		BSONFieldName:  "transparentspanid",
		ConvertedName:  "TransparentSpanID",
		Description: `The transparent span ID that is being referenced. If the application operates in
transparent tracing mode, then this field must be set to the span ID that this
span is originally referencing.`,
		Exposed: true,
		Name:    "transparentSpanID",
		Stored:  true,
		Type:    "string",
	},
}

// SparseTraceRefsList represents a list of SparseTraceRefs
type SparseTraceRefsList []*SparseTraceRef

// Identity returns the identity of the objects in the list.
func (o SparseTraceRefsList) Identity() elemental.Identity {

	return TraceRefIdentity
}

// Copy returns a pointer to a copy the SparseTraceRefsList.
func (o SparseTraceRefsList) Copy() elemental.Identifiables {

	copy := slices.Clone(o)
	return &copy
}

// Append appends the objects to the a new copy of the SparseTraceRefsList.
func (o SparseTraceRefsList) Append(objects ...elemental.Identifiable) elemental.Identifiables {

	out := slices.Clone(o)
	for _, obj := range objects {
		out = append(out, obj.(*SparseTraceRef))
	}

	return out
}

// List converts the object to an elemental.IdentifiablesList.
func (o SparseTraceRefsList) List() elemental.IdentifiablesList {

	out := make(elemental.IdentifiablesList, len(o))
	for i := range len(o) {
		out[i] = o[i]
	}

	return out
}

// DefaultOrder returns the default ordering fields of the content.
func (o SparseTraceRefsList) DefaultOrder() []string {

	return []string{}
}

// ToPlain returns the SparseTraceRefsList converted to TraceRefsList.
func (o SparseTraceRefsList) ToPlain() elemental.IdentifiablesList {

	out := make(elemental.IdentifiablesList, len(o))
	for i := range len(o) {
		out[i] = o[i].ToPlain()
	}

	return out
}

// Version returns the version of the content.
func (o SparseTraceRefsList) Version() int {

	return 1
}

// SparseTraceRef represents the sparse version of a traceref.
type SparseTraceRef struct {
	// The kind of the span.
	Kind *TraceRefKindValue `json:"kind,omitempty" msgpack:"kind,omitempty" bson:"kind,omitempty" mapstructure:"kind,omitempty"`

	// The parent span ID that is being referenced as hex encoded string.
	ParentSpanID *string `json:"parentSpanID,omitempty" msgpack:"parentSpanID,omitempty" bson:"parentspanid,omitempty" mapstructure:"parentSpanID,omitempty"`

	// When the span ended.
	SpanEnd *time.Time `json:"spanEnd,omitempty" msgpack:"spanEnd,omitempty" bson:"spanend,omitempty" mapstructure:"spanEnd,omitempty"`

	// The span ID that is being referenced.
	SpanID *string `json:"spanID,omitempty" msgpack:"spanID,omitempty" bson:"spanid,omitempty" mapstructure:"spanID,omitempty"`

	// The name of the span that is being collected.
	SpanName *string `json:"spanName,omitempty" msgpack:"spanName,omitempty" bson:"spanname,omitempty" mapstructure:"spanName,omitempty"`

	// When the span started.
	SpanStart *time.Time `json:"spanStart,omitempty" msgpack:"spanStart,omitempty" bson:"spanstart,omitempty" mapstructure:"spanStart,omitempty"`

	// Status Code of a span.
	StatusCode *TraceRefStatusCodeValue `json:"statusCode,omitempty" msgpack:"statusCode,omitempty" bson:"statuscode,omitempty" mapstructure:"statusCode,omitempty"`

	// A developer-facing human readable error message.
	StatusMessage *string `json:"statusMessage,omitempty" msgpack:"statusMessage,omitempty" bson:"statusmessage,omitempty" mapstructure:"statusMessage,omitempty"`

	// The Trace ID that is being referenced as hex encoded string.
	TraceID *string `json:"traceID,omitempty" msgpack:"traceID,omitempty" bson:"traceid,omitempty" mapstructure:"traceID,omitempty"`

	// The transparent span ID that is being referenced. If the application operates in
	// transparent tracing mode, then this field must be set to the span ID that this
	// span is originally referencing.
	TransparentSpanID *string `json:"transparentSpanID,omitempty" msgpack:"transparentSpanID,omitempty" bson:"transparentspanid,omitempty" mapstructure:"transparentSpanID,omitempty"`

	ModelVersion int `json:"-" msgpack:"-" bson:"_modelversion"`
}

// NewSparseTraceRef returns a new  SparseTraceRef.
func NewSparseTraceRef() *SparseTraceRef {
	return &SparseTraceRef{}
}

// Identity returns the Identity of the sparse object.
func (o *SparseTraceRef) Identity() elemental.Identity {

	return TraceRefIdentity
}

// Identifier returns the value of the sparse object's unique identifier.
func (o *SparseTraceRef) Identifier() string {

	return ""
}

// SetIdentifier sets the value of the sparse object's unique identifier.
func (o *SparseTraceRef) SetIdentifier(id string) {

}

// GetBSON implements the bson marshaling interface.
// This is used to transparently convert ID to MongoDBID as ObectID.
func (o *SparseTraceRef) GetBSON() (any, error) {

	if o == nil {
		return nil, nil
	}

	s := &mongoAttributesSparseTraceRef{}

	if o.Kind != nil {
		s.Kind = o.Kind
	}
	if o.ParentSpanID != nil {
		s.ParentSpanID = o.ParentSpanID
	}
	if o.SpanEnd != nil {
		s.SpanEnd = o.SpanEnd
	}
	if o.SpanID != nil {
		s.SpanID = o.SpanID
	}
	if o.SpanName != nil {
		s.SpanName = o.SpanName
	}
	if o.SpanStart != nil {
		s.SpanStart = o.SpanStart
	}
	if o.StatusCode != nil {
		s.StatusCode = o.StatusCode
	}
	if o.StatusMessage != nil {
		s.StatusMessage = o.StatusMessage
	}
	if o.TraceID != nil {
		s.TraceID = o.TraceID
	}
	if o.TransparentSpanID != nil {
		s.TransparentSpanID = o.TransparentSpanID
	}

	return s, nil
}

// SetBSON implements the bson marshaling interface.
// This is used to transparently convert ID to MongoDBID as ObectID.
func (o *SparseTraceRef) SetBSON(raw bson.Raw) error {

	if o == nil {
		return nil
	}

	s := &mongoAttributesSparseTraceRef{}
	if err := raw.Unmarshal(s); err != nil {
		return err
	}

	if s.Kind != nil {
		o.Kind = s.Kind
	}
	if s.ParentSpanID != nil {
		o.ParentSpanID = s.ParentSpanID
	}
	if s.SpanEnd != nil {
		o.SpanEnd = s.SpanEnd
	}
	if s.SpanID != nil {
		o.SpanID = s.SpanID
	}
	if s.SpanName != nil {
		o.SpanName = s.SpanName
	}
	if s.SpanStart != nil {
		o.SpanStart = s.SpanStart
	}
	if s.StatusCode != nil {
		o.StatusCode = s.StatusCode
	}
	if s.StatusMessage != nil {
		o.StatusMessage = s.StatusMessage
	}
	if s.TraceID != nil {
		o.TraceID = s.TraceID
	}
	if s.TransparentSpanID != nil {
		o.TransparentSpanID = s.TransparentSpanID
	}

	return nil
}

// Version returns the hardcoded version of the model.
func (o *SparseTraceRef) Version() int {

	return 1
}

// ToPlain returns the plain version of the sparse model.
func (o *SparseTraceRef) ToPlain() elemental.PlainIdentifiable {

	out := NewTraceRef()
	if o.Kind != nil {
		out.Kind = *o.Kind
	}
	if o.ParentSpanID != nil {
		out.ParentSpanID = *o.ParentSpanID
	}
	if o.SpanEnd != nil {
		out.SpanEnd = *o.SpanEnd
	}
	if o.SpanID != nil {
		out.SpanID = *o.SpanID
	}
	if o.SpanName != nil {
		out.SpanName = *o.SpanName
	}
	if o.SpanStart != nil {
		out.SpanStart = *o.SpanStart
	}
	if o.StatusCode != nil {
		out.StatusCode = *o.StatusCode
	}
	if o.StatusMessage != nil {
		out.StatusMessage = *o.StatusMessage
	}
	if o.TraceID != nil {
		out.TraceID = *o.TraceID
	}
	if o.TransparentSpanID != nil {
		out.TransparentSpanID = *o.TransparentSpanID
	}

	return out
}

// DeepCopy returns a deep copy if the SparseTraceRef.
func (o *SparseTraceRef) DeepCopy() *SparseTraceRef {

	if o == nil {
		return nil
	}

	out := &SparseTraceRef{}
	o.DeepCopyInto(out)

	return out
}

// DeepCopyInto copies the receiver into the given *SparseTraceRef.
func (o *SparseTraceRef) DeepCopyInto(out *SparseTraceRef) {

	target, err := copystructure.Copy(o)
	if err != nil {
		panic(fmt.Sprintf("Unable to deepcopy SparseTraceRef: %s", err))
	}

	*out = *target.(*SparseTraceRef)
}

type mongoAttributesTraceRef struct {
	Kind              TraceRefKindValue       `bson:"kind"`
	ParentSpanID      string                  `bson:"parentspanid,omitempty"`
	SpanEnd           time.Time               `bson:"spanend"`
	SpanID            string                  `bson:"spanid"`
	SpanName          string                  `bson:"spanname"`
	SpanStart         time.Time               `bson:"spanstart"`
	StatusCode        TraceRefStatusCodeValue `bson:"statuscode"`
	StatusMessage     string                  `bson:"statusmessage"`
	TraceID           string                  `bson:"traceid"`
	TransparentSpanID string                  `bson:"transparentspanid"`
}
type mongoAttributesSparseTraceRef struct {
	Kind              *TraceRefKindValue       `bson:"kind,omitempty"`
	ParentSpanID      *string                  `bson:"parentspanid,omitempty"`
	SpanEnd           *time.Time               `bson:"spanend,omitempty"`
	SpanID            *string                  `bson:"spanid,omitempty"`
	SpanName          *string                  `bson:"spanname,omitempty"`
	SpanStart         *time.Time               `bson:"spanstart,omitempty"`
	StatusCode        *TraceRefStatusCodeValue `bson:"statuscode,omitempty"`
	StatusMessage     *string                  `bson:"statusmessage,omitempty"`
	TraceID           *string                  `bson:"traceid,omitempty"`
	TransparentSpanID *string                  `bson:"transparentspanid,omitempty"`
}
