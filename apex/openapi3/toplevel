{
  "components": {
    "schemas": {
      "alertevent": {
        "description": "Represents an alert event raised by a policy.",
        "properties": {
          "alertDefinition": {
            "description": "The name of the alert definition that triggered the alert event.",
            "example": "warning-notification",
            "type": "string"
          },
          "alertDefinitionNamespace": {
            "description": "The namespace of the alert definition.",
            "type": "string"
          },
          "principal": {
            "$ref": "#/components/schemas/principal"
          },
          "provider": {
            "description": "The provider used that the alert came from.",
            "type": "string"
          },
          "timestamp": {
            "description": "When the alert event was raised.",
            "format": "date-time",
            "readOnly": true,
            "type": "string"
          }
        },
        "required": [
          "alertDefinition",
          "principal"
        ],
        "type": "object"
      },
      "analyzer": {
        "description": "Represents an analyzer.",
        "properties": {
          "ID": {
            "description": "ID is the identifier of the object.",
            "readOnly": true,
            "type": "string"
          },
          "description": {
            "description": "The description of the analyzer.",
            "type": "string"
          },
          "detectionMatchers": {
            "description": "A list of detection matcher that will trigger the analyzer.",
            "example": [
              [
                {
                  "confidence": "Medium",
                  "group": "Text",
                  "name": "txt",
                  "operator": "min"
                }
              ]
            ],
            "items": {
              "items": {
                "type": "object"
              },
              "type": "array"
            },
            "type": "array"
          },
          "detectors": {
            "description": "The detectors the analyzer can use.",
            "items": {
              "$ref": "#/components/schemas/detector"
            },
            "type": "array"
          },
          "enabled": {
            "description": "Tell if the analyzer is enabled by default.",
            "type": "boolean"
          },
          "group": {
            "description": "The group the analyzer belongs to.",
            "type": "string"
          },
          "models": {
            "description": "The models used by the analyzer.",
            "items": {
              "$ref": "#/components/schemas/analyzermodel"
            },
            "type": "array"
          },
          "name": {
            "description": "The name of the analyzer.",
            "type": "string"
          },
          "namespace": {
            "description": "The namespace of the object.",
            "readOnly": true,
            "type": "string"
          }
        },
        "type": "object"
      },
      "analyzermodel": {
        "description": "Represent an analyzer model.",
        "properties": {
          "name": {
            "description": "The name of the model.",
            "type": "string"
          },
          "revision": {
            "description": "The revision of the model.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "detectionmatcher": {
        "description": "Represent a detection matcher.\nA Detection Matcher serves as a filtering mechanism for analyzers, determining\nwhich detections should trigger an analysis. It allows for flexible pattern\nmatching on detection attributes such as name, label, and group using glob-style\nwildcards. Additionally, it enables confidence-based filtering by defining\nthresholds and comparison operators. Detection Matchers provide a structured way\nto control when and how analyzers engage with incoming detections.",
        "properties": {
          "confidence": {
            "default": "Low",
            "description": "The detection confidence level to operate on.",
            "enum": [
              "Unlikely",
              "Low",
              "Medium",
              "High"
            ]
          },
          "description": {
            "description": "The description of the detection matcher.",
            "type": "string"
          },
          "group": {
            "default": "*",
            "description": "The group pattern used to match detection group. Supports glob-style wildcards\n(e.g. 'Text*' matches 'Text', 'Text_'). Default value is '*' meaning matching\nany\ndetection group.",
            "example": "Text",
            "type": "string"
          },
          "label": {
            "default": "*",
            "description": "The label pattern used to match detection label. Supports glob-style wildcards\n(e.g. 'txt*' matches 'txt', 'txtuf8'). Default value is '*' meaning matching any\ndetection label.",
            "example": "txt",
            "type": "string"
          },
          "name": {
            "default": "*",
            "description": "The name pattern used to match detection name. Supports glob-style wildcards\n(e.g. 'txt*' matches 'txt', 'txtuf8'). Default value is '*' meaning matching any\ndetection name.",
            "example": "txt",
            "type": "string"
          },
          "operator": {
            "default": "Min",
            "description": "Specifies how to compare the detection's confidence value against the matcher's\nthreshold:\n- 'Is': All Detections confidence must exactly match the threshold\n- 'Min': At least one detection confidence must be greater than or equal to the\nthreshold\n- 'Max': At least one detection confidence must be less than the threshold\nThe default value is 'Min'.",
            "enum": [
              "Is",
              "Min",
              "Max"
            ]
          }
        },
        "type": "object"
      },
      "detector": {
        "description": "Represent a detector an analyzer can use.",
        "properties": {
          "description": {
            "description": "The description of the detection.",
            "type": "string"
          },
          "group": {
            "description": "The group the detection belongs to.",
            "type": "string"
          },
          "label": {
            "description": "The label returned by the model.",
            "type": "string"
          },
          "name": {
            "description": "The name of the detection.",
            "type": "string"
          },
          "positional": {
            "description": "Tell if the detection is positional.",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "elementalerror": {
        "properties": {
          "code": {
            "description": "Error code",
            "type": "integer"
          },
          "data": {
            "description": "Additional error data",
            "type": "object"
          },
          "description": {
            "description": "Error description",
            "type": "string"
          },
          "subject": {
            "description": "Error subject",
            "type": "string"
          },
          "title": {
            "description": "Error title",
            "type": "string"
          },
          "trace": {
            "description": "Error trace",
            "type": "string"
          }
        },
        "type": "object"
      },
      "extraction": {
        "description": "Represents the extracted information to log.",
        "properties": {
          "PIIs": {
            "additionalProperties": {
              "type": "number"
            },
            "description": "The PIIs found during classification.\n\nThe current list can be obtained through the analyzers API by searching for\ndetector groups 'PIIs' accross all analyzers.\n\nExample of PIIs detected: aba_routing_number, address, bank_account,\nbitcoin_wallet, credit_card, driver_license, email_address, itin_number,\nlocation, medical_license, money_amount, passport_number, person, phone_number,\nssn.\n\nIf a key is not present in the map that implies that entity was not detected. If\nan entity is detected then the value is a score. Here's how to interpret the\nscores:\n  - confidence: 'low', 0 \u003c score \u003c0.33\n  - confidence: 'medium', 0.33 \u003c= score \u003c 0.66\n  - confidence: 'high', 0.66 \u003c= score \u003c= 1.",
            "example": {
              "ssn": 0.8
            },
            "type": "object"
          },
          "annotations": {
            "additionalProperties": {
              "type": "string"
            },
            "description": "Annotations attached to the extraction.",
            "type": "object"
          },
          "categories": {
            "description": "The categories are remapping of the modalities in a more human friendly way.",
            "items": {
              "$ref": "#/components/schemas/modality"
            },
            "type": "array"
          },
          "confidentiality": {
            "description": "The level of general confidentiality of the input.",
            "example": 0.9,
            "type": "number"
          },
          "customDataTypes": {
            "additionalProperties": {
              "type": "number"
            },
            "description": "The custom data types found during classification.\n\nIf a key is not present in the map that implies that entity was not detected. If\nan entity is detected then the value is a score. Here's how to interpret the\nscores:\n  - confidence: 'low', 0 \u003c score \u003c0.33\n  - confidence: 'medium', 0.33 \u003c= score \u003c 0.66\n  - confidence: 'high', 0.66 \u003c= score \u003c= 1.",
            "example": {
              "my_cdt": 1
            },
            "type": "object"
          },
          "data": {
            "description": "The data extracted.",
            "type": "string"
          },
          "dataSets": {
            "additionalProperties": {
              "additionalProperties": {
                "type": "number"
              },
              "type": "object"
            },
            "description": "The data sets found during classification.",
            "example": {
              "cds": {
                "ct1": 1,
                "ct2": 2
              }
            },
            "type": "object"
          },
          "detections": {
            "description": "The textual detections found while applying policies.",
            "items": {
              "$ref": "#/components/schemas/textualdetection"
            },
            "type": "array"
          },
          "exploits": {
            "additionalProperties": {
              "type": "number"
            },
            "description": "The various exploits attempts.\n\nThe current list can be obtained through the analyzers API by searching for\ndetector groups 'Exploits' accross all analyzers.\n\nExample of exploits detected: jailbreak, prompt_injection, malicious_url.\n\nIf a key is not present in the map that implies that entity was not detected. If\nan entity is detected then the value is a score. Here's how to interpret the\nscores:\n  - confidence: 'low', 0 \u003c score \u003c0.33\n  - confidence: 'medium', 0.33 \u003c= score \u003c 0.66\n  - confidence: 'high', 0.66 \u003c= score \u003c= 1.",
            "example": {
              "prompt_injection": 0.8
            },
            "type": "object"
          },
          "hash": {
            "description": "The hash of the extraction.",
            "type": "string"
          },
          "intent": {
            "additionalProperties": {
              "type": "number"
            },
            "description": "The estimated intent embodied into the text.\n\nThe current list can be obtained through the analyzers API by searching for\ndetector groups 'Intent' accross all analyzers.\n\nExample of intent detected: explain, outline, summarize, write.\n\nIf a key is not present in the map that implies that entity was not detected. If\nan entity is detected then the value is a score. Here's how to interpret the\nscores:\n  - confidence: 'low', 0 \u003c score \u003c0.33\n  - confidence: 'medium', 0.33 \u003c= score \u003c 0.66\n  - confidence: 'high', 0.66 \u003c= score \u003c= 1.",
            "example": {
              "write": 0.8
            },
            "type": "object"
          },
          "internal": {
            "description": "If true, this extraction is for internal use only. This can be used by agentic\nsystems to mark an extraction as internal only as opposed to user facing.",
            "type": "boolean"
          },
          "isFile": {
            "description": "If true, the data of the extraction is a file.",
            "type": "boolean"
          },
          "isStored": {
            "description": "If true, indicates that the file has been stored.",
            "type": "boolean"
          },
          "keywords": {
            "additionalProperties": {
              "type": "number"
            },
            "description": "The keywords found during classification.\n\nIf a key is not present in the map that implies that entity was not detected. If\nan entity is detected then the value is a score. Here's how to interpret the\nscores:\n  - confidence: 'low', 0 \u003c score \u003c0.33\n  - confidence: 'medium', 0.33 \u003c= score \u003c 0.66\n  - confidence: 'high', 0.66 \u003c= score \u003c= 1.",
            "example": {
              "my_keywork": 0.8
            },
            "type": "object"
          },
          "label": {
            "description": "A means of distinguishing what was extracted, such as prompt, input file or\ncode.",
            "type": "string"
          },
          "languages": {
            "additionalProperties": {
              "type": "number"
            },
            "description": "The language of the classification.\n\nThe current list can be obtained through the analyzers API by searching for\ndetector groups 'Languages' accross all analyzers.\n\nExample of languages: chinese, english, french, german, gibberish, japanese,\nrussian, spanish.\n\nIf a key is not present in the map that implies that entity was not detected. If\nan entity is detected then the value is a score. Here's how to interpret the\nscores:\n  - confidence: 'low', 0 \u003c score \u003c0.33\n  - confidence: 'medium', 0.33 \u003c= score \u003c 0.66\n  - confidence: 'high', 0.66 \u003c= score \u003c= 1.",
            "example": {
              "english": 0.8
            },
            "type": "object"
          },
          "malcontents": {
            "additionalProperties": {
              "type": "number"
            },
            "description": "The various malcontents attempts.\n\nThe current list can be obtained through the analyzers API by searching for\ndetector groups 'Malcontents' accross all analyzers.\n\nExample of malcontents: biased, harmful, toxic.\n\nIf a key is not present in the map that implies that entity was not detected. If\nan entity is detected then the value is a score. Here's how to interpret the\nscores:\n  - confidence: 'low', 0 \u003c score \u003c0.33\n  - confidence: 'medium', 0.33 \u003c= score \u003c 0.66\n  - confidence: 'high', 0.66 \u003c= score \u003c= 1.",
            "example": {
              "toxic": 0.8
            },
            "type": "object"
          },
          "modalities": {
            "description": "The modalities of data detected in the data.",
            "items": {
              "$ref": "#/components/schemas/modality"
            },
            "type": "array"
          },
          "relevance": {
            "description": "The level of general organization relevance of the input.\n\nIf a key is not present in the map that implies that entity was not detected. If\nan entity is detected then the value is a score. Here's how to interpret the\nscores:\n  - confidence: 'low', 0 \u003c score \u003c0.33\n  - confidence: 'medium', 0.33 \u003c= score \u003c 0.66\n  - confidence: 'high', 0.66 \u003c= score \u003c= 1.",
            "example": 0.9,
            "type": "number"
          },
          "secrets": {
            "additionalProperties": {
              "type": "number"
            },
            "description": "The secrets found during classification.\n\nThe current list can be obtained through the analyzers API by searching for\ndetector groups 'Secrets' accross all analyzers.\n\nExample of secrets: adafruit, alibaba, anthropic, apideck, apify, atlassian,\naws_secret_key, buildkite, checkout, clickuppersonal, contentfulpersonalaccess,\ncredentials, database_url_with_credentials, databricks, denodeploy, dfuse,\ndigitalocean, discord_webhook, docker_hub, doppler, dropbox, endorlabs,\nfleetbase, flutterwave, frameio, freshdesk, fullstory, github, gitlab,\ngocardless, google_api, grafana, groq, huggingface, intra42, jwt, klaviyo,\nlaunchdarkly, linearapi, locationiq, mailchimp, mailgun, mapbox, maxmind,\nmicrosoft_teams_webhook, nightfall, notion, npm, openai, otp_auth_url, pagarme,\npaystack, planetscale, planetscaledb, portainer, posthog, postman, prefect,\nprivate_key, pubnub_publish, pubnub_subscribe, pulumi, ramp, razorpay, readme,\nrechargepayments, replicate, rubygems, salesforce, sendgrid, sendinblue,\nshopify, slack_access, slack_bot, slack_refresh, slack_user, slack_webhook,\nslack_workflow_webhook, sourcegraph, sourcegraphcody, squareapp, squareup,\nstripe, supabase, tailscale, tines_webhook, trufflehog, twilio, ubidots,\nvoiceflow, web_url_with_credentials, zapierwebhook.\n\nIf a key is not present in the map that implies that entity was not detected. If\nan entity is detected then the value is a score. Here's how to interpret the\nscores:\n  - confidence: 'low', 0 \u003c score \u003c0.33\n  - confidence: 'medium', 0.33 \u003c= score \u003c 0.66\n  - confidence: 'high', 0.66 \u003c= score \u003c= 1.",
            "example": {
              "credentials": 0.7
            },
            "type": "object"
          },
          "toolResults": {
            "description": "Tool call results which are passed in to this request.",
            "items": {
              "$ref": "#/components/schemas/toolresult"
            },
            "type": "array"
          },
          "toolUses": {
            "description": "Tool uses as requested by a model.",
            "items": {
              "$ref": "#/components/schemas/tooluse"
            },
            "type": "array"
          },
          "topics": {
            "additionalProperties": {
              "type": "number"
            },
            "description": "The topic of the classification.\n\nThe current list can be obtained through the analyzers API, with the following\nconditions:\n  1. Includes all analyzers EXCEPT those in the 'Modality' group\n  2. Includes all analyzer detectors EXCEPT those in these groups:\n    - 'Secrets'\n    - 'Exploits'\n    - 'Intent'\n    - 'PIIs'\n    - 'Malcontents'\n\nExample of topics: category/enterprise, category/healthcare, category/medical,\ncategory/personal, contains/blank_image, contains/certificate_signing_request,\ncontains/database_url, contains/handwritten_text, contains/printed_text,\ncontains/public_key, contains/ssh_public_key, contains/web_url,\ndecoded/base32_data, decoded/base58_data, decoded/base64_data,\ndecoded/base64_url_data, decoded/base85_data, decoded/hexadecimal_data,\ndecoded/puny_code_data, decoded/quoted_printable_data,\ndecoded/url_encoding_data, department/compliance, department/cybersecurity,\ndepartment/finance, department/human_resources,\ndepartment/information_technology, department/legal, department/logistics,\ndepartment/marketing, department/performance_evaluation,\ndepartment/product_management, department/project_management, department/sales,\ndepartment/strategy, department/support, depict/check, depict/code,\ndepict/document, depict/unclassified, depict/whiteboard, domain/commercial,\ndomain/development, domain/financial, domain/general, domain/regulatory,\ndomain/workforce, extracted/csv_cell_content, extracted/document_text_content,\nextracted/handwritten_text_content, extracted/pdf_text_content,\nextracted/pptx_text_content, extracted/spreadsheet_text_content,\nextracted/typed_text_content, timeframe/current_year, timeframe/future,\ntimeframe/last_year, timeframe/next_year, timeframe/past,\ntranscribed/audio_text_content.\n\nIf a key is not present in the map that implies that entity was not detected. If\nan entity is detected then the value is a score. Here's how to interpret the\nscores:\n  - confidence: 'low', 0 \u003c score \u003c0.33\n  - confidence: 'medium', 0.33 \u003c= score \u003c 0.66\n  - confidence: 'high', 0.66 \u003c= score \u003c= 1.",
            "example": {
              "category/enterprise": 0.7,
              "department/logistics": 0.8,
              "depict/document": 0.8,
              "extracted/typed_text_content": 1,
              "timeframe/current_year": 0.6
            },
            "type": "object"
          }
        },
        "type": "object"
      },
      "extractioninformation": {
        "description": "Represents extracted information.",
        "properties": {
          "n": {
            "description": "The number of times it has been seen.",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "extractionrequest": {
        "description": "Represents the extraction that the user wants to extract.",
        "properties": {
          "annotations": {
            "additionalProperties": {
              "type": "string"
            },
            "description": "Annotations attached to the extraction.",
            "type": "object"
          },
          "data": {
            "contentEncoding": "base64",
            "description": "The binary data to request extraction for.",
            "type": "string"
          },
          "internal": {
            "description": "If true, this extraction is for internal use only. This can be used by agentic\nsystems to mark an extraction as internal only as opposed to user facing.",
            "type": "boolean"
          },
          "isFile": {
            "description": "If true, the data of the extraction is a file.",
            "type": "boolean"
          },
          "isStored": {
            "description": "If true, indicates that the file has been stored.",
            "type": "boolean"
          },
          "label": {
            "description": "A means of distinguishing what was extracted, such as prompt, input file or\ncode.",
            "type": "string"
          },
          "toolResults": {
            "description": "Tool call results which are passed in to this request.",
            "items": {
              "$ref": "#/components/schemas/toolresult"
            },
            "type": "array"
          },
          "toolUses": {
            "description": "Tool uses as requested by a model.",
            "items": {
              "$ref": "#/components/schemas/tooluse"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "extractionsummary": {
        "description": "Represents the summary of the extractions.",
        "properties": {
          "categories": {
            "additionalProperties": true,
            "description": "The categories are remapping of the modalities in a more human friendly way.",
            "type": "object"
          },
          "confidenceLevels": {
            "additionalProperties": true,
            "description": "The detected confidence levels.",
            "type": "object"
          },
          "dataSets": {
            "additionalProperties": true,
            "description": "The detected datasets.",
            "type": "object"
          },
          "dataTypes": {
            "additionalProperties": true,
            "description": "The detected dataTypes.",
            "type": "object"
          },
          "exploits": {
            "additionalProperties": true,
            "description": "The various exploits attempts.",
            "type": "object"
          },
          "intent": {
            "additionalProperties": true,
            "description": "The estimated intent embodied into the text.",
            "type": "object"
          },
          "keywords": {
            "additionalProperties": true,
            "description": "The keywords found during classification.",
            "type": "object"
          },
          "languages": {
            "additionalProperties": true,
            "description": "The language of the classification.",
            "type": "object"
          },
          "malcontents": {
            "additionalProperties": true,
            "description": "The various malcontents attempts.",
            "type": "object"
          },
          "modalities": {
            "additionalProperties": true,
            "description": "The modalities of data detected in the data.",
            "type": "object"
          },
          "topics": {
            "additionalProperties": true,
            "description": "The topic of the classification.",
            "type": "object"
          }
        },
        "type": "object"
      },
      "latency": {
        "description": "Holds information about latencies introduced by Apex.",
        "properties": {
          "accessPolicy": {
            "description": "How much time it took to run the access policy in nanoseconds.",
            "type": "integer"
          },
          "analysis": {
            "description": "How much time it took to run content analysis in nanoseconds.",
            "type": "integer"
          },
          "assignPolicy": {
            "description": "How much time it took to run the assign policy in nanoseconds.",
            "type": "integer"
          },
          "contentPolicy": {
            "description": "How much time it took to run content policy in nanoseconds.",
            "type": "integer"
          },
          "extraction": {
            "description": "How much time it took to run input or output extraction in nanoseconds.",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "mcpmessage": {
        "description": "Represents MCP message details.",
        "properties": {
          "direction": {
            "description": "The communication direction of the MCP message which can be from client to\nserver, or from server to client.",
            "enum": [
              "Client2Server",
              "Server2Client"
            ],
            "example": "Client2Server"
          },
          "isError": {
            "description": "IsError is true in case if a response is an error response as opposed to a\nresult. Note that this is not the same as a result which has isError set to true\nwithin the result. This is a protocol level error. This will always be false for\nrequests and notifications, and false for reponses when the response has a\nresult.",
            "type": "boolean"
          },
          "method": {
            "description": "This is the method name of the request or notification. Contrary to MCP this is\nset on responses as well if possible in which case the format will be of the\nform method/params.name.",
            "example": "tools/call",
            "type": "string"
          },
          "requestID": {
            "description": "The ID of a request or a response. We always extract this as a string even\nthough this can be a string or number in MCP. It is derived from the id field of\na request or a response.",
            "example": "2",
            "type": "string"
          },
          "sessionID": {
            "description": "The session ID that this MCP message belongs to. This is strictly speaking not\npart of MCP, and this can be empty.",
            "example": "1f02aa20-22d8-6e87-8432-be15d4f7b5b2",
            "type": "string"
          },
          "type": {
            "description": "The MCP message type which can be Request, Response or Notification.",
            "enum": [
              "Request",
              "Response",
              "Notification"
            ],
            "example": "Request"
          }
        },
        "required": [
          "direction",
          "type"
        ],
        "type": "object"
      },
      "mcpserver": {
        "description": "Represents an MCP server object.",
        "properties": {
          "allowedTools": {
            "description": "The allowed tools that the caller has access to. If empty, this means that the\ncaller has access to all tools provided by this MCP server.",
            "example": [
              "deepwiki_search",
              "deepwiki_fetch"
            ],
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "name": {
            "description": "The name of the MCP server.",
            "example": "deepwiki",
            "type": "string"
          },
          "url": {
            "description": "The URL of the MCP server.",
            "example": "https://mcp.deepwiki.com/mcp",
            "type": "string"
          }
        },
        "required": [
          "url"
        ],
        "type": "object"
      },
      "mcptoolannotations": {
        "description": "Represents the tool annotations as they can be optionally defined for MCP tools.",
        "properties": {
          "destructiveHint": {
            "description": "If true, the tool may perform destructive updates.",
            "type": "boolean"
          },
          "idempotentHint": {
            "description": "If true, repeated calls with same args have no additional effect.",
            "type": "boolean"
          },
          "openWorldHint": {
            "description": "If true, tool interacts with external entities.",
            "type": "boolean"
          },
          "readOnlyHint": {
            "description": "If true, the tool does not modify its environment.",
            "type": "boolean"
          },
          "title": {
            "description": "Human-readable title for the tool.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "modality": {
        "description": "Represents the modality of a some data.",
        "properties": {
          "group": {
            "description": "The group of data.\n\nThe current list can be obtained through the analyzers API by searching for\ndetector groups in the 'Modality' analyzer group.\n\nExample of group: application, archive, audio, code, document, executable, font,\nimage, text, unknown, video.",
            "example": "image",
            "type": "string"
          },
          "type": {
            "description": "The type of data.\n\nThe current list can be obtained through the analyzers API by searching for\ndetector names in the 'Modality' analyzer group.\n\nExample of type: 3dsm, 3gp, 3mf, ace, ada, ai, apk, applebplist, appleplist, ar,\narc, arj, asc, asf, asm, asp, au, autohotkey, autoit, avi, avif, awk, ax, batch,\nbazel, bcad, bib, bmp, bpg, brainfuck, brf, bzip, bzip3, c, cab, cat, cdf, chm,\nclojure, cmake, cobol, coff, coffeescript, com, cpl, cpp, crt, crx, cs, csproj,\ncss, csv, dart, deb, dex, dey, dicom, diff, django, dll, dm, dmg, dmigd,\ndmscript, doc, dockerfile, docx, dotx, dwg, dxf, dylib, elf, elixir, emf, eml,\nepub, erb, erlang, exe, flac, flv, fortran, fpx, gemfile, gemspec, gif,\ngitattributes, gitmodules, gleam, go, gradle, groovy, gzip, h, h5, handlebars,\nhaskell, hcl, heif, hlp, hpp, hta, htaccess, html, hwp, icns, ico, ics,\nignorefile, ini, internetshortcut, ipynb, iso, jar, java, javabytecode,\njavascript, jinja, jng, jnlp, jp2, jpeg, json, jsonl, jsx, julia, jxl, ko,\nkotlin, latex, lha, license, lisp, lnk, lock, lua, lz, lz4, m3u, m4, macho,\nmakefile, markdown, matlab, mht, midi, mkv, mp3, mp4, mpegts, mscompress, msi,\nmsix, mui, mum, npy, npz, objectivec, ocaml, ocx, odex, odin, odp, ods, odt,\nogg, one, onnx, otf, outlook, pascal, pcap, pdb, pdf, pebin, pem, perl, php,\npickle, png, po, postscript, powershell, ppt, pptx, prolog, proteindb, proto,\npsd, python, pythonbytecode, pytorch, qoi, qt, r, randomascii, rar, rdf, rlib,\nrll, rpm, rst, rtf, ruby, rust, scala, scheme, scr, scss, sevenzip, sgml, shell,\nsmali, snap, so, solidity, sql, sqlite, squashfs, srt, stlbinary, stltext, sum,\nsvg, swf, swift, symlinktext, sys, tar, tcl, textproto, tga, thumbsdb, tiff,\ntoml, torrent, tsv, tsx, ttf, twig, txt, txtascii, txtutf16, txtutf8,\ntypescript, vba, vbe, vcxproj, verilog, vhdl, visio, vtt, vue, wad, wasm, wav,\nwebm, webp, webtemplate, winregistry, wma, wmf, wmv, woff, woff2, xar, xcf, xls,\nxlsb, xlsx, xml, xpi, xz, yaml, yara, zig, zip, zlibstream, zst.",
            "example": "png",
            "type": "string"
          }
        },
        "required": [
          "group",
          "type"
        ],
        "type": "object"
      },
      "policeexternaluser": {
        "description": "PoliceExternalUser holds the information about the remote user for a\nPoliceRequest.",
        "properties": {
          "claims": {
            "description": "List of claims extracted from the user query.",
            "example": [
              "@org=acuvity.ai",
              "given_name=John",
              "family_name=Doe"
            ],
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "name": {
            "description": "The name of the external user.",
            "example": "John Doe",
            "type": "string"
          }
        },
        "required": [
          "claims",
          "name"
        ],
        "type": "object"
      },
      "policerequest": {
        "description": "This is a scan and police request.",
        "properties": {
          "annotations": {
            "additionalProperties": {
              "type": "string"
            },
            "description": "Annotations attached to the extraction.",
            "example": {
              "key1": "value1",
              "key2": "value2"
            },
            "type": "object"
          },
          "anonymization": {
            "default": "FixedSize",
            "description": "How to anonymize the data. If deanonymize is true, then VariablSize is required.",
            "enum": [
              "FixedSize",
              "VariableSize"
            ]
          },
          "bypassHash": {
            "description": "In the case of a contentPolicy that asks for a confirmation, this is the\nhash you must send back to bypass the block. This is only useful when a\ncontent policy has been set or is evaluated remotely.",
            "example": "6f37d752-bce1-4973-88f6-28b6c100ceb8",
            "type": "string"
          },
          "extractions": {
            "description": "The extractions to request.",
            "items": {
              "$ref": "#/components/schemas/extractionrequest"
            },
            "type": "array"
          },
          "messages": {
            "description": "Messages to process and provide detections for. Use data in extractions for\nprocessing binary data.",
            "example": [
              "Summarize the main points of this article in bullet points.",
              "Generate a list of creative product names for a futuristic tech gadget."
            ],
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "model": {
            "description": "The model used by the request.",
            "example": "claude-3-7-sonnet",
            "type": "string"
          },
          "provider": {
            "description": "The name of the provider to use for policy resolutions. If not set, it will\ndefault to the principal name (the application itself).",
            "example": "openai",
            "type": "string"
          },
          "tools": {
            "additionalProperties": {
              "$ref": "#/components/schemas/tool"
            },
            "description": "The various tools used by the request.",
            "example": "{\n  \"tool1\": {\n      \"name\": \"tool1\",\n      \"description\": \"This is a tool.\"\n  }\n}",
            "type": "object"
          },
          "trace": {
            "$ref": "#/components/schemas/traceref"
          },
          "type": {
            "description": "The type of text.",
            "enum": [
              "Input",
              "Output"
            ]
          },
          "user": {
            "$ref": "#/components/schemas/policeexternaluser"
          }
        },
        "type": "object"
      },
      "policeresponse": {
        "description": "This is a scan and police response.",
        "properties": {
          "ID": {
            "description": "ID is the identifier of the object.",
            "readOnly": true,
            "type": "string"
          },
          "alerts": {
            "description": "List of alerts that got raised during the policy resolution.",
            "items": {
              "$ref": "#/components/schemas/alertevent"
            },
            "type": "array"
          },
          "annotations": {
            "additionalProperties": {
              "type": "string"
            },
            "description": "Annotations attached to the log.",
            "type": "object"
          },
          "client": {
            "description": "The client used to send the request.",
            "example": "curl",
            "type": "string"
          },
          "clientVersion": {
            "description": "The version of the client used to send the request.",
            "example": "7.64.1",
            "type": "string"
          },
          "decision": {
            "description": "Tell what was the decision about the data.",
            "enum": [
              "Deny",
              "Allow",
              "Ask",
              "Bypassed",
              "ForbiddenUser",
              "Skipped"
            ]
          },
          "extractions": {
            "description": "The extractions to log.",
            "items": {
              "$ref": "#/components/schemas/extraction"
            },
            "type": "array"
          },
          "hash": {
            "description": "The hash of the input.",
            "type": "string"
          },
          "latency": {
            "$ref": "#/components/schemas/latency"
          },
          "mcpMessage": {
            "$ref": "#/components/schemas/mcpmessage"
          },
          "model": {
            "description": "The model used by the request.",
            "example": "claude-3-7-sonnet",
            "type": "string"
          },
          "namespace": {
            "description": "The namespace of the object.",
            "readOnly": true,
            "type": "string"
          },
          "pipelineName": {
            "description": "The name of the particular pipeline that extracted the text.",
            "type": "string"
          },
          "principal": {
            "$ref": "#/components/schemas/principal"
          },
          "provider": {
            "description": "The provider to use.",
            "example": "openai",
            "type": "string"
          },
          "reasons": {
            "description": "The various reasons returned by the policy engine.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "summary": {
            "$ref": "#/components/schemas/extractionsummary"
          },
          "time": {
            "description": "Set the time of the message request.",
            "format": "date-time",
            "type": "string"
          },
          "toolChoice": {
            "$ref": "#/components/schemas/toolchoice"
          },
          "tools": {
            "additionalProperties": {
              "$ref": "#/components/schemas/tool"
            },
            "description": "The various tools used by the request.",
            "example": "{\n  \"tool1\": {\n      \"name\": \"tool1\",\n      \"description\": \"This is a tool.\"\n  }\n}",
            "type": "object"
          },
          "type": {
            "description": "The type of text.",
            "enum": [
              "Input",
              "Output"
            ]
          }
        },
        "required": [
          "principal"
        ],
        "type": "object"
      },
      "principal": {
        "description": "Describe the principal.",
        "properties": {
          "IP": {
            "description": "The source IP address of the request.",
            "example": "192.0.2.42",
            "type": "string"
          },
          "app": {
            "$ref": "#/components/schemas/principalapp"
          },
          "authType": {
            "description": "The type of authentication.",
            "enum": [
              "Certificate",
              "UserToken",
              "AppToken",
              "Hostname",
              "Token",
              "ComponentToken",
              "External"
            ]
          },
          "claims": {
            "description": "List of claims extracted from the user query.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "teams": {
            "description": "The teams that were used to authorize the request.",
            "example": "admins",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "tokenName": {
            "description": "The name of the token, if any.",
            "example": "my-user-token",
            "type": "string"
          },
          "type": {
            "description": "The type of principal.",
            "enum": [
              "User",
              "App",
              "External"
            ],
            "example": [
              "User"
            ]
          },
          "user": {
            "$ref": "#/components/schemas/principaluser"
          }
        },
        "required": [
          "type"
        ],
        "type": "object"
      },
      "principalapp": {
        "description": "Describes the principal information of an application.",
        "properties": {
          "component": {
            "description": "The component of the application request.",
            "example": "frontend",
            "type": "string"
          },
          "labels": {
            "description": "The list of labels attached to an application request.",
            "example": [
              "country=us",
              "another-label"
            ],
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "name": {
            "description": "The name of the application.",
            "example": "MyApp",
            "type": "string"
          },
          "user": {
            "$ref": "#/components/schemas/principalappuser"
          }
        },
        "type": "object"
      },
      "principalappuser": {
        "description": "Describes the optional principal information of the user of an application which\nis being derived from a bearer token of a request.",
        "properties": {
          "email": {
            "description": "The Email address of the user. This will be derived from the email claims of a\ntoken like email, emailAddress or upn.",
            "example": "john.doe@acme.com",
            "type": "string"
          },
          "name": {
            "description": "The given name of the user. This will be derived from the common name claims of\na token like name or given_name.",
            "example": "John Doe",
            "type": "string"
          },
          "tokenValidated": {
            "description": "This will be true if the apex was able to validate the token in the request.",
            "example": false,
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "principaluser": {
        "description": "Describes the principal information of a user.",
        "properties": {
          "name": {
            "description": "Identification bit that will be used to identify the origin of the request.",
            "example": "user@company.com",
            "type": "string"
          }
        },
        "type": "object"
      },
      "scanrequest": {
        "description": "This is a scan request.",
        "properties": {
          "accessPolicy": {
            "description": "AccessPolicy allows to pass optional Rego access policy. If not set,\nThe action is always Allow,\nIf it is set, it will be run, and the final decision will be computed based\non that policy.\nIf the rego code does not start with package main, then the needed\nclassic package definition and  acuvity imports will be added\nautomatically.\nIf the code starts with package main, then everything remains untouched.",
            "type": "string"
          },
          "analyzers": {
            "description": "The analyzers parameter allows for customizing which analyzers should be used,\noverriding the default selection. Each analyzer entry can optionally include a\nprefix to modify its behavior:\n\n  - No prefix: Runs only the specified analyzers and any dependencies required\nfor deeper analyzis (slower but more acurate).\n  - '+' (enable): Activates an analyzer that is disabled by default.\n  - '-' (disable): Disables an analyzer that is enabled by default.\n  - '@' (direct execution): Runs the analyzer immediately, bypassing the deeper\nanalyzis (faster but less acurate).\n\nAn analyzers entry can be specified using:\n  - The analyzer name (e.g., 'Toxicity detector')\n  - The analyzer ID (e.g., 'en-text-toxicity-detector')\n  - The analyzer group (e.g., 'Detectors')\n  - A detector name (e.g., 'toxic')\n  - A detector label (e.g., 'insult')\n  - A detector group (e.g., 'Malcontents')\n\nIf left empty, all default analyzers will be executed.",
            "example": [
              "Malcontents"
            ],
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "annotations": {
            "additionalProperties": {
              "type": "string"
            },
            "description": "Annotations attached to the extraction.",
            "example": {
              "key1": "value1",
              "key2": "value2"
            },
            "type": "object"
          },
          "anonymization": {
            "default": "FixedSize",
            "description": "How to anonymize the data. If deanonymize is true, then VariablSize is required.",
            "enum": [
              "FixedSize",
              "VariableSize"
            ]
          },
          "bypassHash": {
            "description": "In the case of a contentPolicy that asks for a confirmation, this is the\nhash you must send back to bypass the block. This is only useful when a\ncontent policy has been set or is evaluated remotely.",
            "example": "6f37d752-bce1-4973-88f6-28b6c100ceb8",
            "type": "string"
          },
          "contentPolicy": {
            "description": "ContentPolicy allows to pass optional Rego content policy. If not set,\nThe action is always Allow, and there cannot be any alerts raised etc\nIf it is set, it will be run, and the final decision will be computed based\non that policy.\nIf the rego code does not start with package main, then the needed\nclassic package definition and  acuvity imports will be added\nautomatically.\nIf the code starts with package main, then everything remains untouched.",
            "type": "string"
          },
          "extractions": {
            "description": "The extractions to request.",
            "items": {
              "$ref": "#/components/schemas/extractionrequest"
            },
            "type": "array"
          },
          "keywords": {
            "description": "The keywords found during classification.",
            "example": [
              "legal",
              "technical",
              "scientific"
            ],
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "messages": {
            "description": "Messages to process and provide detections for. Use data in extractions for\nprocessing binary data.",
            "example": [
              "Summarize the main points of this article in bullet points.",
              "Generate a list of creative product names for a futuristic tech gadget."
            ],
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "minimalLogging": {
            "description": "If true, the system will not log the contents that were scanned.",
            "type": "boolean"
          },
          "model": {
            "description": "The model used by the request.",
            "example": "claude-3-7-sonnet",
            "type": "string"
          },
          "redactions": {
            "description": "The redactions to perform if they are detected.",
            "example": [
              "person",
              "ssn",
              "location"
            ],
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "tools": {
            "additionalProperties": {
              "$ref": "#/components/schemas/tool"
            },
            "description": "The various tools used by the request.",
            "example": "{\n  \"tool1\": {\n      \"name\": \"tool1\",\n      \"description\": \"This is a tool.\"\n  }\n}",
            "type": "object"
          },
          "type": {
            "description": "The type of text.",
            "enum": [
              "Input",
              "Output"
            ]
          }
        },
        "type": "object"
      },
      "scanresponse": {
        "description": "This is a scan response.",
        "properties": {
          "ID": {
            "description": "ID is the identifier of the object.",
            "readOnly": true,
            "type": "string"
          },
          "alerts": {
            "description": "List of alerts that got raised during the policy resolution.",
            "items": {
              "$ref": "#/components/schemas/alertevent"
            },
            "type": "array"
          },
          "annotations": {
            "additionalProperties": {
              "type": "string"
            },
            "description": "Annotations attached to the log.",
            "type": "object"
          },
          "client": {
            "description": "The client used to send the request.",
            "example": "curl",
            "type": "string"
          },
          "clientVersion": {
            "description": "The version of the client used to send the request.",
            "example": "7.64.1",
            "type": "string"
          },
          "decision": {
            "description": "Tell what was the decision about the data.",
            "enum": [
              "Deny",
              "Allow",
              "Ask",
              "Bypassed",
              "ForbiddenUser",
              "Skipped"
            ]
          },
          "extractions": {
            "description": "The extractions to log.",
            "items": {
              "$ref": "#/components/schemas/extraction"
            },
            "type": "array"
          },
          "hash": {
            "description": "The hash of the input.",
            "type": "string"
          },
          "latency": {
            "$ref": "#/components/schemas/latency"
          },
          "mcpMessage": {
            "$ref": "#/components/schemas/mcpmessage"
          },
          "model": {
            "description": "The model used by the request.",
            "example": "claude-3-7-sonnet",
            "type": "string"
          },
          "namespace": {
            "description": "The namespace of the object.",
            "readOnly": true,
            "type": "string"
          },
          "pipelineName": {
            "description": "The name of the particular pipeline that extracted the text.",
            "type": "string"
          },
          "principal": {
            "$ref": "#/components/schemas/principal"
          },
          "provider": {
            "description": "The provider to use.",
            "example": "openai",
            "type": "string"
          },
          "reasons": {
            "description": "The various reasons returned by the policy engine.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "summary": {
            "$ref": "#/components/schemas/extractionsummary"
          },
          "time": {
            "description": "Set the time of the message request.",
            "format": "date-time",
            "type": "string"
          },
          "toolChoice": {
            "$ref": "#/components/schemas/toolchoice"
          },
          "tools": {
            "additionalProperties": {
              "$ref": "#/components/schemas/tool"
            },
            "description": "The various tools used by the request.",
            "example": "{\n  \"tool1\": {\n      \"name\": \"tool1\",\n      \"description\": \"This is a tool.\"\n  }\n}",
            "type": "object"
          },
          "trace": {
            "$ref": "#/components/schemas/traceref"
          },
          "type": {
            "description": "The type of text.",
            "enum": [
              "Input",
              "Output"
            ]
          }
        },
        "required": [
          "principal"
        ],
        "type": "object"
      },
      "textualdetection": {
        "description": "Represents a textual detection done by policy.",
        "properties": {
          "end": {
            "description": "The end position of the detection in the original data.",
            "type": "integer"
          },
          "key": {
            "description": "The key that is used in the name's place, If empty, a sequence of X's are used.",
            "type": "string"
          },
          "name": {
            "description": "The name of the detection.",
            "type": "string"
          },
          "redacted": {
            "description": "If true this detection has been redacted.",
            "type": "boolean"
          },
          "redactedEnd": {
            "description": "The end position of the detection in the redacted data.",
            "type": "integer"
          },
          "redactedStart": {
            "description": "The start position of the detection in the redacted data.",
            "type": "integer"
          },
          "score": {
            "description": "The confidence score of the detection.",
            "type": "number"
          },
          "start": {
            "description": "The start position of the detection in the original data.",
            "type": "integer"
          },
          "type": {
            "description": "The type of detection.",
            "enum": [
              "Keyword",
              "PII",
              "Secret",
              "CDT"
            ]
          }
        },
        "type": "object"
      },
      "tool": {
        "description": "Represents a tool that can enhance a genAI model's capabilities.",
        "properties": {
          "MCPAnnotations": {
            "$ref": "#/components/schemas/mcptoolannotations"
          },
          "MCPServer": {
            "$ref": "#/components/schemas/mcpserver"
          },
          "category": {
            "description": "The category of the tool. This relays information about where the tool is being\nused. This can be empty if unknown or if this is a tool listing of MCP servers.",
            "enum": [
              "Client",
              "Server",
              "RemoteMCP"
            ],
            "example": "Client"
          },
          "description": {
            "description": "The description of the tool.",
            "example": "Get the current weather in a given location",
            "type": "string"
          },
          "name": {
            "description": "The name of the tool.",
            "example": "get_weather",
            "type": "string"
          },
          "type": {
            "description": "The type of the tool as can be optionally passed by the provider.",
            "example": "computer_20250124",
            "type": "string"
          }
        },
        "type": "object"
      },
      "toolchoice": {
        "description": "Represents the tool choice that can be passed along together with tools.",
        "properties": {
          "choice": {
            "default": "Auto",
            "description": "Model instructions on tool choice.",
            "enum": [
              "Auto",
              "Any",
              "None",
              "Tool"
            ]
          },
          "name": {
            "description": "If choice is Tool, this will be set to the name of the tool to use.",
            "type": "string"
          }
        },
        "required": [
          "choice"
        ],
        "type": "object"
      },
      "toolresult": {
        "description": "Represents the tool result as passed in by the user or application after calling\na tool.",
        "properties": {
          "callID": {
            "description": "The ID of the tool use as previously returned by a models tool use response.",
            "example": "toolu_019X5QaEeVTDFrQPHqMMgd1n",
            "type": "string"
          },
          "content": {
            "description": "The content of the tool call results.",
            "type": "string"
          },
          "isError": {
            "default": false,
            "description": "Indicates if the tool call failed.",
            "type": "boolean"
          }
        },
        "required": [
          "callID"
        ],
        "type": "object"
      },
      "tooluse": {
        "description": "Represents the tool use which are instructions by a model on what tool to call\nand how.",
        "properties": {
          "callID": {
            "description": "The ID of the tool use which the user or application must pass when posting back\nthe tool call results.",
            "example": "toolu_019X5QaEeVTDFrQPHqMMgd1n",
            "type": "string"
          },
          "input": {
            "description": "The input to the tool call. This should be a JSON object which must conform to\nthe JSON schema as was previously defined for the tool.",
            "type": "string"
          },
          "name": {
            "description": "The name of the tool to call.",
            "example": "get_weather",
            "type": "string"
          },
          "serverName": {
            "description": "The name of the remote MCP server that will execute this call.",
            "example": "deepwiki",
            "type": "string"
          }
        },
        "required": [
          "callID",
          "name"
        ],
        "type": "object"
      },
      "traceref": {
        "description": "Holds all references to a trace which are also the essentials of the span data.",
        "properties": {
          "kind": {
            "default": "Unspecified",
            "description": "The kind of the span.",
            "enum": [
              "Unspecified",
              "Internal",
              "Server",
              "Client",
              "Producer",
              "Consumer"
            ],
            "example": "Server"
          },
          "parentSpanID": {
            "description": "The parent span ID that is being referenced as hex encoded string.",
            "example": "00f067aa0ba902b7",
            "type": "string"
          },
          "spanEnd": {
            "description": "When the span ended.",
            "example": "2025-03-22T14:35:00.123456789Z",
            "format": "date-time",
            "type": "string"
          },
          "spanID": {
            "description": "The span ID that is being referenced.",
            "example": "6ba80aaa3b2f43d8",
            "type": "string"
          },
          "spanName": {
            "description": "The name of the span that is being collected.",
            "example": "acuvity_prompt_input_analysis",
            "type": "string"
          },
          "spanStart": {
            "description": "When the span started.",
            "example": "2025-03-22T14:35:00.123456789Z",
            "format": "date-time",
            "type": "string"
          },
          "statusCode": {
            "default": "Unset",
            "description": "Status Code of a span.",
            "enum": [
              "Unset",
              "OK",
              "Error"
            ],
            "example": "OK"
          },
          "statusMessage": {
            "description": "A developer-facing human readable error message.",
            "example": "Failed to make API call to service Foo.",
            "type": "string"
          },
          "traceID": {
            "description": "The Trace ID that is being referenced as hex encoded string.",
            "example": "4bf92f3577b34da6a3ce929d0e0e4736",
            "type": "string"
          },
          "transparentSpanID": {
            "description": "The transparent span ID that is being referenced. If the application operates in\ntransparent tracing mode, then this field must be set to the span ID that this\nspan is originally referencing.",
            "example": "6ba80aaa3b2f43d8",
            "type": "string"
          }
        },
        "required": [
          "spanEnd",
          "spanID",
          "spanName",
          "spanStart",
          "traceID"
        ],
        "type": "object"
      }
    },
    "securitySchemes": {
      "cookie": {
        "description": "Authentication using a3s cookie",
        "in": "cookie",
        "name": "x-a3s-token",
        "type": "apiKey"
      },
      "token": {
        "bearerFormat": "JWT",
        "description": "Bearer Token Authentication",
        "scheme": "bearer",
        "type": "http"
      }
    }
  },
  "info": {
    "contact": {
      "email": "info@acuvity.ai",
      "name": "Acuvity Team",
      "url": "https://acuvity.ai/"
    },
    "description": "Acuvity Apex provides access to scan and detection APIs",
    "license": {
      "name": "Apache 2.0",
      "url": "https://www.apache.org/licenses/LICENSE-2.0"
    },
    "title": "Apex API",
    "version": "1.0"
  },
  "openapi": "3.1.0",
  "paths": {
    "/_acuvity/analyzers": {
      "get": {
        "description": "List of all available analyzers.",
        "operationId": "get-all-Analyzers",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/analyzer"
                  },
                  "type": "array"
                }
              }
            },
            "description": "n/a"
          },
          "400": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/elementalerror"
                }
              }
            },
            "description": "Unable to determine response decoding."
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/elementalerror"
                }
              }
            },
            "description": "The caller is not authenticated."
          },
          "500": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/elementalerror"
                }
              }
            },
            "description": "Unable to retrieve list of analyzers."
          }
        },
        "tags": [
          "apex"
        ],
        "x-speakeasy-name-override": "listAnalyzers",
        "x-speakeasy-usage-example": {
          "description": "Now you can list all available analyzers that can be used in the Scan API.",
          "position": 3,
          "title": "List all available analyzers"
        }
      }
    },
    "/_acuvity/police": {
      "post": {
        "description": "Processes the scan and police request.",
        "operationId": "create-PoliceRequest-as-PoliceResponse",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/policerequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/policeresponse"
                }
              }
            },
            "description": "Successfully processing a scan and police request returns a police response."
          },
          "400": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/elementalerror"
                }
              }
            },
            "description": "The scan and police request could not be decoded."
          },
          "401": {
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              }
            },
            "description": "The caller is not authenticated."
          },
          "403": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/elementalerror"
                }
              }
            },
            "description": "The caller is not authorized or has a team or policy assignment issue."
          },
          "415": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/elementalerror"
                }
              }
            },
            "description": "Could not find a supported content type in the provided header."
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/elementalerror"
                }
              }
            },
            "description": "Sending an invalid scan and police request returns an unprocessable entity error. Your models might be outdated."
          },
          "429": {
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              }
            },
            "description": "Too many requests. You are being rate limited."
          },
          "500": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/elementalerror"
                }
              }
            },
            "description": "Processing the scan and police request failed because policies could not be assigned or running the analysis failed internally."
          }
        },
        "tags": [
          "apex"
        ],
        "x-speakeasy-ignore": true,
        "x-speakeasy-name-override": "policeRequest",
        "x-speakeasy-usage-example": {
          "description": "You can submit a scan and police request using the Scan API.",
          "position": 2,
          "title": "Process a scan and police request"
        }
      }
    },
    "/_acuvity/scan": {
      "post": {
        "description": "Processes the scan request.",
        "operationId": "create-ScanRequest-as-ScanResponse",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/scanrequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/scanresponse"
                }
              }
            },
            "description": "Successfully processing a scan request returns a scan response."
          },
          "400": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/elementalerror"
                }
              }
            },
            "description": "The scan request could not be decoded."
          },
          "401": {
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              }
            },
            "description": "The caller is not authenticated."
          },
          "403": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/elementalerror"
                }
              }
            },
            "description": "The caller is not authorized or has a team or policy assignment issue."
          },
          "415": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/elementalerror"
                }
              }
            },
            "description": "Could not find a supported content type in the provided header."
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/elementalerror"
                }
              }
            },
            "description": "Sending an invalid scan request returns an unprocessable entity error. Your models might be outdated."
          },
          "429": {
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              }
            },
            "description": "Too many requests. You are being rate limited."
          },
          "500": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/elementalerror"
                }
              }
            },
            "description": "Processing the scan request failed because policies could not be assigned or running the analysis failed internally."
          }
        },
        "tags": [
          "apex"
        ],
        "x-speakeasy-name-override": "scanRequest",
        "x-speakeasy-usage-example": {
          "description": "You can submit a scan request using the Scan API.",
          "position": 1,
          "title": "Process a scan request"
        }
      }
    }
  },
  "security": [
    {
      "token": []
    },
    {
      "cookie": []
    }
  ],
  "servers": [
    {
      "description": "The Apex API server which is specific to every organization.\nThe apex_domain and apex_port variables can be determined by a call to\nthe well-known Apex info endpoint on the backend.",
      "url": "https://{apex_domain}:{apex_port}",
      "variables": {
        "apex_domain": {
          "default": "apex.acuvity.ai",
          "description": "The Apex domain to use which is specific to each customer and environment.\nThis can be determined through the well known Apex info response from the Acuvity backend API."
        },
        "apex_port": {
          "default": "443",
          "description": "The port to use for the Apex URL. Note that this might need to be set to the no-MTLS port\nvalue of the well known Apex info response from the Acuvity backend API."
        }
      }
    }
  ],
  "tags": [
    {
      "description": "This tag is for group 'apex'",
      "name": "apex"
    },
    {
      "description": "This tag is for group 'core'",
      "name": "core"
    }
  ],
  "x-speakeasy-retries": {
    "backoff": {
      "exponent": 1.5,
      "initialInterval": 1000,
      "maxElapsedTime": 300000,
      "maxInterval": 60000
    },
    "retryConnectionErrors": true,
    "statusCodes": [
      408,
      423,
      429,
      502,
      503,
      504
    ],
    "strategy": "backoff"
  },
  "x-speakeasy-timeout": 60000
}
